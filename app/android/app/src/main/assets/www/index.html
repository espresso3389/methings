<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kugutz</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f4f1ea;
      --panel: #fffaf0;
      --ink: #2c2b28;
      --accent: #d24b2a;
      --muted: #7a7369;
      --border: #e4dccb;
      font-family: "Georgia", "Times New Roman", serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
    }
    header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(90deg, #f7efe1, #f2e6d1);
      position: sticky;
      top: 0;
      z-index: 3;
    }
    .banner {
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 16px;
      background: #fff2cc;
      color: #6d4c41;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 56px;
      z-index: 2;
    }
    .banner.show { display: flex; }
    .banner button {
      background: transparent;
      border: 1px solid #c9b37a;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .wrap {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 16px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.05);
    }
    .row {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 12px;
    }
    .row-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
    }
    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }
    .muted { color: var(--muted); }
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn.secondary {
      background: #8a867d;
    }
    .btn.danger {
      background: #d84b4b;
    }
    textarea {
      width: 100%;
      min-height: 90px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      font-family: inherit;
    }
    pre {
      margin: 0;
      white-space: pre-wrap;
    }
    ul {
      margin: 8px 0 0 0;
      padding: 0;
      list-style: none;
    }
    li {
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
    }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: #efe6d3;
      color: var(--muted);
      margin-left: 8px;
    }
    .status-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #999;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
      cursor: pointer;
    }
    .status-dot.ok { background: #2e7d32; }
    .status-dot.offline { background: #c62828; }
    .status-dot.starting { background: #616161; }
    .status-dot.stopping { background: #8d6e63; }
    .inline-status {
      display: inline-block;
      margin-left: 8px;
      font-size: 12px;
      color: var(--muted);
      padding: 2px 6px;
      border-radius: 999px;
      background: #efe6d3;
    }
    .inline-status.ok { background: #e1f1e2; color: #2e7d32; }
    .inline-status.warn { background: #fff2cc; color: #8d6e63; }
    .inline-status.bad { background: #f8d7da; color: #c62828; }
    .inline-status.neutral { background: #efe6d3; color: var(--muted); }
    .row-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--ink);
    }
    .toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: #2c2b28;
      color: #fffaf0;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
      z-index: 999;
    }
    .toast.show {
      opacity: 0.95;
    }
    @media (max-width: 820px) {
      .row, .row-3 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Kugutz</h1>
  </header>
  <div class="banner" id="permBanner">
    <div id="permBannerText">Permission requests pending</div>
    <button id="permBannerBtn">View</button>
  </div>
  <div class="wrap">
    <div class="panel">
      <strong>Status</strong>
      <div class="status-row">
        <span id="statusDot" class="status-dot starting"></span>
        <div class="muted" id="status">Booting local service...</div>
      </div>
      <div class="muted" id="statusDetail">Last action: (none)</div>
      <div class="muted" id="session">Session: (disabled)</div>
      <div class="row-actions">
        <button class="btn secondary" id="restartPython">Restart Python</button>
        <button class="btn danger" id="stopPython">Stop Python</button>
      </div>
    </div>
    <div class="panel">
      <strong>UI</strong>
      <div class="muted">Reset replaces local UI files with defaults. Local changes will be lost.</div>
      <div class="row-actions">
        <button class="btn secondary" id="resetUi">Reset UI to Defaults</button>
      </div>
    </div>
    <div class="panel">
      <strong>SSH</strong>
      <div class="muted" id="sshStatusText">Status: unknown</div>
      <div class="muted" id="sshAddressText">Address: (pending)</div>
      <div class="muted" id="sshPinText">PIN: (inactive)</div>
      <div class="row-actions">
        <label class="toggle">
          <input type="checkbox" id="sshEnabled" checked />
          <span>Enable SSHD</span>
        </label>
        <button class="btn secondary" id="sshPin">Allow PIN (30s)</button>
      </div>
    </div>

    <div class="row">
      <div class="panel">
        <strong>Logs</strong>
        <pre id="logStream">(no logs yet)</pre>
      </div>
    </div>

    <div class="row-3">
      <div class="panel">
        <strong>Permissions</strong><span class="inline-status" id="permStatus"></span>
        <div class="muted">Pending requests</div>
        <ul id="permList"></ul>
      </div>
      <div class="panel">
        <strong>Audit</strong><span class="inline-status" id="auditStatus"></span>
        <div class="muted">Recent events</div>
        <ul id="auditList"></ul>
      </div>
    </div>
  </div>
  <div id="toast" class="toast">Notice</div>

  <script>
    const statusEl = document.getElementById("status");
    const statusDot = document.getElementById("statusDot");
    const statusDetail = document.getElementById("statusDetail");
    const toast = document.getElementById("toast");
    const restartPython = document.getElementById("restartPython");
    const stopPython = document.getElementById("stopPython");
    const resetUi = document.getElementById("resetUi");
    const sshStatusText = document.getElementById("sshStatusText");
    const sshAddressText = document.getElementById("sshAddressText");
    const sshPinText = document.getElementById("sshPinText");
    const sshEnabled = document.getElementById("sshEnabled");
    const sshPin = document.getElementById("sshPin");
    const permStatus = document.getElementById("permStatus");
    const auditStatus = document.getElementById("auditStatus");
    const sessionEl = document.getElementById("session");
    const logStream = document.getElementById("logStream");
    const permList = document.getElementById("permList");
    const auditList = document.getElementById("auditList");
    const permScope = document.getElementById("permScope");
    const permDuration = document.getElementById("permDuration");
    const permBanner = document.getElementById("permBanner");
    const permBannerText = document.getElementById("permBannerText");
    const permBannerBtn = document.getElementById("permBannerBtn");

    let restartPending = false;
    let restartPendingTimer = null;
    let sessionId = null;
    let sshToggleBusy = false;

    function appendLog(line) {
      if (logStream.textContent === "(no logs yet)") logStream.textContent = "";
      logStream.textContent += line + "\n";
    }

    function setStatusDetail(text) {
      const ts = new Date().toLocaleTimeString();
      statusDetail.textContent = `${text} @ ${ts}`;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function requestPermission(tool, detail) {
      const scope = permScope ? permScope.value : "once";
      const durationMin = scope === "session" && permDuration
        ? parseInt(permDuration.value || "30", 10)
        : 0;
      const res = await fetch("http://127.0.0.1:8765/permissions/request", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ tool, detail, scope, duration_min: durationMin })
      });
      const req = await res.json();
      appendLog(`[permission] requested: ${req.id}`);
      await refreshPermissions();
      return req.id;
    }

    async function waitForPermission(requestId, timeoutMs = 30000) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        const res = await fetch(`http://127.0.0.1:8765/permissions/${requestId}`);
        const req = await res.json();
        if (req.status === "approved") return true;
        if (req.status === "denied" || req.status === "expired" || req.status === "used") return false;
        await sleep(1000);
      }
      return false;
    }

    async function ping() {
      try {
        const res = await fetch("http://127.0.0.1:8765/health");
        if (res.ok) {
          statusEl.textContent = "Local service online";
        } else {
          statusEl.textContent = "Local service error";
        }
      } catch (err) {
        statusEl.textContent = "Waiting for local service...";
      }
    }

    function setStatusDot(state) {
      statusDot.classList.remove("ok", "offline", "starting", "stopping");
      statusDot.classList.add(state);
    }

    function persistPythonStatus(status, dotState) {
      try {
        localStorage.setItem("pythonStatus", JSON.stringify({
          status: status || "",
          dot: dotState || "starting"
        }));
      } catch (_) {
        // ignore
      }
    }

    function restorePythonStatus() {
      try {
        const raw = localStorage.getItem("pythonStatus");
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data) return;
        const normalized = (data.status || "").toLowerCase();
        if (normalized === "ok") {
          statusEl.textContent = "Python: OK (native)";
        } else if (normalized === "offline") {
          statusEl.textContent = "Python: offline (native)";
        } else {
          statusEl.textContent = "Python: starting (native)";
        }
        setStatusDot(data.dot || "starting");
      } catch (_) {
        // ignore
      }
    }

    window.onPythonStatus = function(status) {
      const normalized = (status || "").toLowerCase();
      if (normalized === "ok") {
        statusEl.textContent = "Python: OK (native)";
        setStatusDot("ok");
        persistPythonStatus(status, "ok");
        setStatusDetail("Python reported OK");
        if (restartPending) {
          restartPending = false;
          if (restartPendingTimer) {
            clearTimeout(restartPendingTimer);
            restartPendingTimer = null;
          }
          showToast("Python restarted");
          appendLog("[status] restart complete");
        }
      } else if (normalized === "stopping") {
        statusEl.textContent = "Python: stopping (native)";
        setStatusDot("stopping");
        persistPythonStatus(status, "stopping");
        setStatusDetail("Python stopping");
      } else if (normalized === "offline") {
        statusEl.textContent = "Python: offline (native)";
        setStatusDot("offline");
        persistPythonStatus(status, "offline");
        setStatusDetail("Python offline");
      } else {
        statusEl.textContent = "Python: starting (native)";
        setStatusDot("starting");
        persistPythonStatus(status, "starting");
        setStatusDetail("Python starting");
      }
    };

    window.onPythonRestartRequested = function() {
      restartPending = true;
      if (restartPendingTimer) {
        clearTimeout(restartPendingTimer);
      }
      restartPendingTimer = setTimeout(() => {
        restartPending = false;
        setStatusDetail("Restart timed out");
      }, 30000);
    };

    function showToast(message) {
      toast.textContent = message;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 2000);
    }

    function getDeviceIp() {
      if (typeof AndroidBridge !== "undefined" && AndroidBridge.getWifiIp) {
        const ip = AndroidBridge.getWifiIp();
        if (ip) return ip;
      }
      return "<device-ip>";
    }

    async function refreshSshStatus() {
      try {
        const res = await fetch("http://127.0.0.1:8765/ssh/status");
        const data = await res.json();
        const running = data.running ? "running" : "stopped";
        const port = data.port || 2222;
        const ip = getDeviceIp();
        const pinUntil = data.pin_until || null;
        sshStatusText.textContent = `Status: ${running}`;
        sshAddressText.textContent = `Address: ${ip}:${port}`;
        if (pinUntil) {
          const now = Math.floor(Date.now() / 1000);
          const remaining = Math.max(0, pinUntil - now);
          const expiry = new Date(pinUntil * 1000).toLocaleTimeString();
          sshPinText.textContent = `PIN: until ${expiry} (${remaining}s)`;
        } else {
          sshPinText.textContent = "PIN: (inactive)";
        }
        if (sshEnabled) {
          sshToggleBusy = true;
          sshEnabled.checked = !!data.enabled;
          sshEnabled.disabled = false;
          sshToggleBusy = false;
        }
      } catch (_) {
        sshStatusText.textContent = "Status: offline";
        sshAddressText.textContent = "Address: (unavailable)";
        sshPinText.textContent = "PIN: (unavailable)";
        if (sshEnabled) {
          sshEnabled.disabled = false;
        }
      }
    }

    let uiVersion = null;
    async function pollUiVersion() {
      try {
        const res = await fetch("http://127.0.0.1:8765/ui/version");
        const data = await res.json();
        if (uiVersion !== null && data.version !== uiVersion) {
          window.location.reload();
          return;
        }
        uiVersion = data.version;
      } catch (_) {
        // ignore
      }
    }

    statusDot.addEventListener("click", () => {
      if (typeof AndroidBridge !== "undefined" && AndroidBridge.showPythonServiceDialog) {
        AndroidBridge.showPythonServiceDialog();
      } else {
        showToast("Open the native app to restart the Python service.");
      }
    });

    sessionId = null;
    sessionEl.textContent = "Session: (disabled)";

    function setInlineStatus(el, text, tone = "neutral") {
      if (!el) return;
      el.textContent = text || "";
      el.classList.remove("ok", "warn", "bad", "neutral");
      el.classList.add(tone);
      try {
        localStorage.setItem(`status:${el.id}`, JSON.stringify({ text, tone }));
      } catch (_) {
        // ignore
      }
    }

    function restoreInlineStatus(el) {
      if (!el) return;
      try {
        const raw = localStorage.getItem(`status:${el.id}`);
        if (!raw) return;
        const data = JSON.parse(raw);
        setInlineStatus(el, data.text, data.tone);
      } catch (_) {
        // ignore
      }
    }

    async function invokeTool(args = {}, requestId = null, toolName = "filesystem", detail = "List files") {
      const res = await fetch(`http://127.0.0.1:8765/tools/${toolName}/invoke`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ detail, args, request_id: requestId })
      });
      if (res.status === 403) {
        const data = await res.json();
        appendLog(`[permission] required: ${data.request.id}`);
        setInlineStatus(permStatus, "blocked", "warn");
        showToast("Permission required");
        await refreshPermissions();
        return;
      }
      const data = await res.json();
      appendLog(`[${toolName}] ${JSON.stringify(data)}`);
      // Shell UI removed; no inline status updates needed here.
      showToast(`${toolName} complete`);
      return data;
    }

    function nativeConsentAvailable() {
      return typeof AndroidBridge !== "undefined" && AndroidBridge.requestNativeConsent;
    }

    async function refreshPermissions() {
      let data;
      try {
        const res = await fetch("http://127.0.0.1:8765/permissions/pending");
        data = await res.json();
      } catch (err) {
        setInlineStatus(permStatus, "offline", "neutral");
        return;
      }
      permList.innerHTML = "";
      const pendingCount = data.pending.length;
      if (pendingCount > 0) {
        permBanner.classList.add("show");
        permBannerText.textContent = `${pendingCount} permission request${pendingCount === 1 ? "" : "s"} pending`;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.notifyPermissionPending) {
          AndroidBridge.notifyPermissionPending(`${pendingCount} pending request${pendingCount === 1 ? "" : "s"}`);
        }
      } else {
        permBanner.classList.remove("show");
      }
      if (!data.pending.length) {
        const li = document.createElement("li");
        li.textContent = "(none)";
        permList.appendChild(li);
        return;
      }
      data.pending.forEach(p => {
        const li = document.createElement("li");
        li.innerHTML = `${p.tool} <span class="pill">${p.id}</span>`;
        const actions = document.createElement("div");
        actions.className = "row-actions";
        const approve = document.createElement("button");
        approve.className = "btn";
        approve.textContent = "Approve";
        approve.onclick = async () => {
          await fetch(`http://127.0.0.1:8765/permissions/${p.id}/approve`, { method: "POST" });
          appendLog(`[permission] approved: ${p.id}`);
          setInlineStatus(permStatus, "approved", "ok");
          showToast("Permission approved");
          await refreshPermissions();
          if (p.tool === "filesystem") {
            await invokeTool({ action: "list", path: "." }, p.id, "filesystem");
          }
        };
        const deny = document.createElement("button");
        deny.className = "btn secondary";
        deny.textContent = "Deny";
        deny.onclick = async () => {
          await fetch(`http://127.0.0.1:8765/permissions/${p.id}/deny`, { method: "POST" });
          appendLog(`[permission] denied: ${p.id}`);
          setInlineStatus(permStatus, "denied", "bad");
          showToast("Permission denied");
          await refreshPermissions();
        };
        actions.appendChild(approve);
        actions.appendChild(deny);

        if (nativeConsentAvailable()) {
          const nativeBtn = document.createElement("button");
          nativeBtn.className = "btn";
          nativeBtn.textContent = "Native Consent";
          nativeBtn.onclick = () => {
            AndroidBridge.requestNativeConsent(p.id, p.tool, p.detail || "");
            setInlineStatus(permStatus, "native", "ok");
            showToast("Opened native consent");
          };
          actions.appendChild(nativeBtn);
        }

        li.appendChild(actions);
        permList.appendChild(li);
      });
    }

    async function refreshAudit() {
      let data;
      try {
        const res = await fetch("http://127.0.0.1:8765/audit/recent?limit=20");
        data = await res.json();
      } catch (err) {
        setInlineStatus(auditStatus, "offline", "neutral");
        return;
      }
      auditList.innerHTML = "";
      if (!data.events.length) {
        const li = document.createElement("li");
        li.textContent = "(none)";
        auditList.appendChild(li);
        setInlineStatus(auditStatus, "idle", "neutral");
        return;
      }
      data.events.forEach(ev => {
        const li = document.createElement("li");
        li.textContent = `${ev.event} @ ${new Date(ev.created_at).toLocaleTimeString()}`;
        auditList.appendChild(li);
      });
      setInlineStatus(auditStatus, "updated", "ok");
    }

    function startLogStream() {
      try {
        const es = new EventSource("http://127.0.0.1:8765/logs/stream");
        es.onmessage = (event) => {
          const payload = JSON.parse(event.data);
          appendLog(`[log] ${payload.event}`);
        };
      } catch (err) {
        appendLog("[log] stream unavailable");
      }
    }


    restartPython.addEventListener("click", () => {
      if (typeof AndroidBridge !== "undefined" && AndroidBridge.restartPythonService) {
        AndroidBridge.restartPythonService();
        window.onPythonRestartRequested && window.onPythonRestartRequested();
        showToast("Restart requested");
        appendLog("[action] restart requested");
        statusEl.textContent = "Python: starting (native)";
        setStatusDot("starting");
        persistPythonStatus("starting", "starting");
        setStatusDetail("Restart requested");
      } else if (typeof AndroidBridge !== "undefined" && AndroidBridge.showPythonServiceDialog) {
        AndroidBridge.showPythonServiceDialog();
      } else {
        showToast("Open the native app to restart the Python service.");
      }
    });

    stopPython.addEventListener("click", () => {
      if (typeof AndroidBridge !== "undefined" && AndroidBridge.stopPythonService) {
        if (!confirm("Stop the local Python service?")) return;
        AndroidBridge.stopPythonService();
        showToast("Stop requested");
        appendLog("[action] stop requested");
        statusEl.textContent = "Python: stopping (native)";
        setStatusDot("stopping");
        persistPythonStatus("stopping", "stopping");
        setStatusDetail("Stop requested");
      } else {
        showToast("Open the native app to stop the Python service.");
      }
    });

    resetUi.addEventListener("click", () => {
      if (!confirm("Reset UI to defaults? This will delete local UI changes.")) return;
      if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUiToDefaults) {
        AndroidBridge.resetUiToDefaults();
        showToast("UI reset requested");
        appendLog("[ui] reset requested");
        setTimeout(() => window.location.reload(), 1500);
      } else {
        showToast("Reset unavailable");
      }
    });

    sshEnabled.addEventListener("change", async () => {
      if (sshToggleBusy) return;
      const enabled = sshEnabled.checked;
      sshToggleBusy = true;
      sshEnabled.disabled = true;
      try {
        await fetch("http://127.0.0.1:8765/ssh/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled, ui_consent: true })
        });
        await refreshSshStatus();
        showToast(enabled ? "SSHD enabled" : "SSHD disabled");
      } catch (_) {
        showToast("Failed to update SSHD");
      } finally {
        sshEnabled.disabled = false;
        sshToggleBusy = false;
      }
    });

    sshPin.addEventListener("click", () => {
      sshPinText.textContent = "PIN: requested";
      if (typeof AndroidBridge !== "undefined" && AndroidBridge.allowSshPinAuth) {
        AndroidBridge.allowSshPinAuth(30);
        showToast("Waiting for PIN approvalâ€¦");
      } else {
        showToast("PIN auth not supported");
      }
    });

    window.onSshPinResult = (ok, expiresAt) => {
      if (!ok) {
        showToast("PIN auth denied");
        return;
      }
      if (expiresAt) {
        const now = Math.floor(Date.now() / 1000);
        const remaining = Math.max(0, expiresAt - now);
        showToast(`PIN auth allowed (${remaining}s)`);
      } else {
        showToast("PIN auth allowed");
      }
      refreshSshStatus();
    };

    permBannerBtn.addEventListener("click", () => {
      const permPanel = permList.closest(".panel");
      if (permPanel) {
        permPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });

    setInterval(ping, 2000);
    setInterval(refreshPermissions, 3000);
    setInterval(refreshAudit, 4000);
    setInterval(pollUiVersion, 3000);
    setInterval(refreshSshStatus, 5000);
    ping();
    pollUiVersion();
    refreshSshStatus();
    console.log("AndroidBridge available:", typeof AndroidBridge);
    if (typeof ensureSession === "function") {
      ensureSession();
    }
    refreshPermissions();
    refreshAudit();
    startLogStream();

    [
      permStatus,
      auditStatus,
    ].forEach(restoreInlineStatus);
    restorePythonStatus();
  </script>
</body>
</html>
