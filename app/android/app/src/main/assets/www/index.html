<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Kugutz</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0e0e10;
        --bg-raised: #18181b;
        --bg-overlay: #1e1e22;
        --surface: #24242a;
        --border: #2e2e36;
        --border-focus: #5b5bd6;
        --ink: #ececf1;
        --ink-secondary: #a1a1aa;
        --ink-muted: #71717a;
        --accent: #6366f1;
        --accent-soft: rgba(99,102,241,0.12);
        --accent-hover: #818cf8;
        --green: #22c55e;
        --green-soft: rgba(34,197,94,0.12);
        --red: #ef4444;
        --red-soft: rgba(239,68,68,0.12);
        --amber: #f59e0b;
        --amber-soft: rgba(245,158,11,0.12);
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-full: 9999px;
        --shadow: 0 2px 8px rgba(0,0,0,0.3);
        --shadow-lg: 0 8px 24px rgba(0,0,0,0.4);
        --transition: 180ms ease;
      }

      * { box-sizing: border-box; margin: 0; padding: 0; }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--ink);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
        font-size: 15px;
        line-height: 1.5;
      }

      /* --- Pages --- */
      .page {
        display: none;
        flex: 1;
        flex-direction: column;
        overflow: hidden;
      }
      .page.active { display: flex; }

      /* --- Topbar --- */
      .topbar {
        flex-shrink: 0;
        height: 52px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px 0 16px;
        border-bottom: 1px solid var(--border);
        background: var(--bg-raised);
      }
      .topbar .title {
        font-weight: 700;
        font-size: 17px;
        letter-spacing: -0.2px;
      }
      .icon-btn {
        width: 38px;
        height: 38px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border);
        background: var(--surface);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 18px;
        color: var(--ink-secondary);
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .icon-btn:active { transform: scale(0.95); }
      .icon-btn:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .icon-btn.secondary { background: transparent; border-color: transparent; }
      .icon-btn.secondary:hover { background: var(--surface); }

      /* --- Chat page --- */
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        -webkit-overflow-scrolling: touch;
      }
      .chat-welcome {
        text-align: center;
        color: var(--ink-muted);
        margin: auto 0;
        padding: 20px;
        font-size: 14px;
        line-height: 1.7;
      }
      .chat-welcome strong {
        display: block;
        color: var(--ink);
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 6px;
      }

      .msg {
        max-width: 85%;
        padding: 10px 14px;
        border-radius: var(--radius-lg);
        line-height: 1.6;
        word-wrap: break-word;
        overflow-wrap: anywhere;
        font-size: 15px;
      }
      .msg.user {
        align-self: flex-end;
        background: var(--accent);
        color: #fff;
        border-bottom-right-radius: 4px;
      }
      .msg.assistant {
        align-self: flex-start;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-bottom-left-radius: 4px;
      }
      .msg.error {
        align-self: center;
        background: var(--red-soft);
        color: var(--red);
        font-size: 13px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(239,68,68,0.2);
        max-width: 95%;
      }

      /* Markdown in messages */
      .msg pre {
        background: #0d0d0f;
        color: #d4d4d8;
        padding: 10px 12px;
        border-radius: var(--radius-sm);
        overflow-x: auto;
        white-space: pre;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 13px;
        margin: 8px 0;
        line-height: 1.5;
        border: 1px solid var(--border);
      }
      .msg.user pre { background: rgba(0,0,0,0.2); border-color: rgba(255,255,255,0.1); color: #fff; }
      .msg code:not(pre code) {
        background: rgba(255,255,255,0.08);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 0.88em;
      }
      .msg.user code:not(pre code) { background: rgba(255,255,255,0.18); }
      .msg p { margin: 4px 0; }
      .msg ul, .msg ol { margin: 4px 0; padding-left: 20px; }
      .msg li { margin: 2px 0; }
      .msg blockquote {
        border-left: 3px solid var(--accent);
        margin: 8px 0;
        padding: 2px 0 2px 12px;
        color: var(--ink-secondary);
      }

      /* Thinking indicator */
      .thinking-dots { display: inline-flex; gap: 4px; align-items: center; padding: 4px 0; }
      .thinking-dots span {
        width: 6px; height: 6px;
        border-radius: 50%;
        background: var(--ink-muted);
        animation: thinking 1.2s infinite;
      }
      .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
      .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }
      @keyframes thinking {
        0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
        30% { opacity: 1; transform: scale(1); }
      }

      /* Chat input */
      .chat-input-area {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        padding: 10px 12px 14px;
        border-top: 1px solid var(--border);
        background: var(--bg-raised);
        flex-shrink: 0;
      }
      .chat-mode-badge {
        flex-shrink: 0;
        font-size: 12px;
        font-weight: 600;
        color: var(--accent);
        background: var(--accent-soft);
        padding: 6px 10px;
        border-radius: var(--radius-full);
        letter-spacing: 0.3px;
        text-transform: uppercase;
        align-self: center;
      }
      .chat-input-area textarea {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 10px 14px;
        font-family: inherit;
        font-size: 15px;
        resize: none;
        background: var(--surface);
        color: var(--ink);
        min-height: 42px;
        max-height: 120px;
        line-height: 1.4;
        outline: none;
        transition: border-color var(--transition);
      }
      .chat-input-area textarea::placeholder { color: var(--ink-muted); }
      .chat-input-area textarea:focus { border-color: var(--border-focus); }
      .send-btn {
        border: none;
        border-radius: 50%;
        width: 42px;
        height: 42px;
        background: var(--accent);
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        transition: background var(--transition), opacity var(--transition);
      }
      .send-btn:hover { background: var(--accent-hover); }
      .send-btn:active { transform: scale(0.95); }
      .send-btn:disabled { opacity: 0.35; cursor: default; }

      /* --- Settings page --- */
      .settings-scroll {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 12px 16px 28px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .card {
        background: var(--bg-raised);
        border-radius: var(--radius-lg);
        padding: 16px;
        border: 1px solid var(--border);
      }

      .card-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .card-icon {
        width: 34px;
        height: 34px;
        border-radius: var(--radius-sm);
        display: grid;
        place-items: center;
        font-size: 16px;
        flex-shrink: 0;
      }
      .card-icon.purple { background: var(--accent-soft); color: var(--accent); }
      .card-icon.green { background: var(--green-soft); color: var(--green); }
      .card-icon.amber { background: var(--amber-soft); color: var(--amber); }
      .card-icon.red { background: var(--red-soft); color: var(--red); }
      .card-title { font-weight: 700; font-size: 15px; }
      .card-desc { color: var(--ink-muted); font-size: 13px; line-height: 1.5; margin-bottom: 12px; }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        font-weight: 600;
        padding: 4px 10px;
        border-radius: var(--radius-full);
        text-transform: uppercase;
        letter-spacing: 0.4px;
      }
      .status-badge::before {
        content: "";
        width: 6px; height: 6px;
        border-radius: 50%;
      }
      .status-badge.ok { background: var(--green-soft); color: var(--green); }
      .status-badge.ok::before { background: var(--green); }
      .status-badge.offline { background: var(--red-soft); color: var(--red); }
      .status-badge.offline::before { background: var(--red); }
      .status-badge.starting { background: var(--amber-soft); color: var(--amber); }
      .status-badge.starting::before { background: var(--amber); }
      .status-badge.stopping { background: var(--amber-soft); color: var(--amber); }
      .status-badge.stopping::before { background: var(--amber); }

      /* Buttons */
      .btn {
        border: none;
        border-radius: var(--radius-full);
        padding: 8px 16px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        font-family: inherit;
        background: var(--surface);
        color: var(--ink-secondary);
        border: 1px solid var(--border);
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .btn:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .btn:active { transform: scale(0.97); }
      .btn.primary {
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
      }
      .btn.primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
      .btn.danger {
        background: var(--red);
        color: #fff;
        border-color: var(--red);
      }
      .btn.danger:hover { background: #dc2626; border-color: #dc2626; }
      .btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }

      .muted { color: var(--ink-muted); font-size: 13px; word-break: break-word; overflow-wrap: anywhere; }

      /* Form fields */
      .field { margin-top: 10px; }
      .field label {
        display: block;
        color: var(--ink-muted);
        font-size: 12px;
        font-weight: 600;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .field select,
      .field input[type="text"],
      .field input[type="url"],
      .field input[type="password"] {
        width: 100%;
        padding: 9px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        font-family: inherit;
        font-size: 14px;
        background: var(--surface);
        color: var(--ink);
        outline: none;
        transition: border-color var(--transition);
      }
      .field select { appearance: auto; }
      .field select:focus,
      .field input:focus { border-color: var(--border-focus); }
      .field input::placeholder { color: var(--ink-muted); }

      /* Toggle switch */
      .toggle-row {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 4px 0;
      }
      .toggle-row .toggle-label { font-size: 14px; color: var(--ink-secondary); }
      .toggle {
        position: relative;
        width: 44px;
        height: 24px;
        flex-shrink: 0;
      }
      .toggle input { opacity: 0; width: 0; height: 0; position: absolute; }
      .toggle .slider {
        position: absolute;
        inset: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-full);
        cursor: pointer;
        transition: background var(--transition), border-color var(--transition);
      }
      .toggle .slider::before {
        content: "";
        position: absolute;
        width: 18px; height: 18px;
        left: 2px; top: 2px;
        background: var(--ink-muted);
        border-radius: 50%;
        transition: transform var(--transition), background var(--transition);
      }
      .toggle input:checked + .slider { background: var(--accent); border-color: var(--accent); }
      .toggle input:checked + .slider::before { transform: translateX(20px); background: #fff; }

      /* Checkbox row */
      .check-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 3px 0;
        font-size: 14px;
        color: var(--ink-secondary);
      }
      .check-row input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--accent);
        flex-shrink: 0;
      }

      /* Textarea (memory editor) */
      .memory-textarea {
        width: 100%;
        min-height: 100px;
        max-height: 280px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 13px;
        background: var(--surface);
        color: var(--ink);
        resize: vertical;
        outline: none;
        box-sizing: border-box;
        line-height: 1.5;
        transition: border-color var(--transition);
      }
      .memory-textarea::placeholder { color: var(--ink-muted); }
      .memory-textarea:focus { border-color: var(--border-focus); }

      /* Pre output */
      .output-pre {
        white-space: pre-wrap;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 12px;
        background: var(--surface);
        color: var(--ink-secondary);
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        max-height: 220px;
        overflow: auto;
        margin-top: 10px;
        line-height: 1.5;
      }

      /* PIN modal */
      .modal {
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        display: none; align-items: center; justify-content: center;
        padding: 20px; z-index: 999;
      }
      .modal.show { display: flex; }
      .modal-card {
        width: 100%; max-width: 340px;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 20px;
        box-shadow: var(--shadow-lg);
        text-align: center;
      }
      .modal-card .card-title { margin-bottom: 12px; font-size: 16px; }
      .pin-code {
        font-size: 32px;
        font-weight: 700;
        letter-spacing: 4px;
        margin: 8px 0;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        color: var(--accent);
      }
      .pin-countdown { color: var(--ink-muted); font-size: 13px; margin-bottom: 12px; }
      .pin-bar {
        width: 100%;
        height: 4px;
        background: var(--surface);
        border-radius: var(--radius-full);
        overflow: hidden;
        margin-bottom: 16px;
      }
      .pin-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.2s ease;
        border-radius: var(--radius-full);
      }

      /* Toast */
      .toast {
        position: fixed;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: var(--ink);
        color: var(--bg);
        padding: 10px 20px;
        border-radius: var(--radius-full);
        font-size: 13px;
        font-weight: 600;
        opacity: 0;
        transition: opacity 0.25s, transform 0.25s;
        pointer-events: none;
        z-index: 1000;
        box-shadow: var(--shadow);
      }
      .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

      /* Responsive */
      @media (max-width: 420px) {
        .settings-scroll { padding: 8px 10px 24px; }
        .card { padding: 14px; }
        .btn-group .btn { flex: 1; text-align: center; min-width: 0; }
      }
      @media (min-width: 640px) {
        .settings-scroll {
          max-width: 560px;
          margin: 0 auto;
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- ===== Chat Page ===== -->
    <div id="chatPage" class="page active">
      <div class="topbar">
        <div class="title">Kugutz</div>
        <button class="icon-btn" id="openSettingsBtn" title="Settings" aria-label="Settings">&#9881;</button>
      </div>
      <div class="chat-messages" id="chatMessages">
        <div class="chat-welcome" id="chatWelcome">
          <strong>Kugutz Brain</strong>
          Configure your AI provider in Settings,<br>then start chatting.
        </div>
      </div>
      <div class="chat-input-area">
        <div class="chat-mode-badge">Agent</div>
        <textarea id="chatInput" placeholder="Message..." rows="1"></textarea>
        <button class="send-btn" id="chatSend" title="Send">&#9654;</button>
      </div>
    </div>

    <!-- ===== Settings Page ===== -->
    <div id="settingsPage" class="page">
      <div class="topbar">
        <button class="icon-btn secondary" id="backToChatBtn" title="Back" aria-label="Back">&#8592;</button>
        <div class="title">Settings</div>
        <div style="width:38px;"></div>
      </div>
      <div class="settings-scroll">
        <!-- Brain Config -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon purple">&#9733;</div>
            <div class="card-title">Brain</div>
          </div>
          <div class="field">
            <label>Model</label>
            <select id="brainVendorModel">
              <option value="" disabled>Choose a model...</option>
              <optgroup label="OpenAI">
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2-codex">GPT-5.2 Codex</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2">GPT-5.2</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.1-codex-mini">GPT-5.1 Codex Mini</option>
              </optgroup>
              <optgroup label="Anthropic">
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-opus-4-6">Claude Opus 4.6</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-sonnet-4-5">Claude Sonnet 4.5</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-haiku-4-5">Claude Haiku 4.5</option>
              </optgroup>
              <option data-vendor="custom" value="custom">Custom...</option>
            </select>
          </div>
          <div id="brainCustomFields" style="display:none;">
            <div class="field">
              <label>Base URL</label>
              <input type="url" id="brainBaseUrl" placeholder="https://api.openai.com/v1" />
            </div>
            <div class="field">
              <label>Model ID</label>
              <input type="text" id="brainModelId" placeholder="gpt-5.2" />
            </div>
          </div>
          <div class="field">
            <label>API Key (plaintext)</label>
            <input type="text" id="brainApiKey" placeholder="(locked)" />
            <div class="muted" id="brainKeyStatus" style="margin-top:4px;"></div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="brainSave">Save</button>
          </div>
        </section>

        <!-- Web Search -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon green">&#9906;</div>
            <div class="card-title">Web Search</div>
          </div>
          <div class="card-desc">
            Default provider is DuckDuckGo. Brave Search is used only when an API key is configured here.
          </div>
          <div class="field">
            <label>Brave Search API Key (plaintext)</label>
            <input type="text" id="braveSearchApiKey" placeholder="(locked)" />
            <div class="muted" id="braveSearchKeyStatus" style="margin-top:4px;">Status unknown.</div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="braveSearchSave">Save</button>
            <button class="btn" id="braveSearchClear">Clear</button>
            <button class="btn" id="braveSearchCheck">Check</button>
          </div>
        </section>

        <!-- Memory -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon purple">&#9998;</div>
            <div class="card-title">Memory</div>
          </div>
          <div class="card-desc">Persistent notes the AI remembers across conversations.</div>
          <textarea id="memoryEditor"
            class="memory-textarea"
            placeholder="(empty -- the AI or you can add notes here)"></textarea>
          <div class="btn-group">
            <button class="btn primary" id="memorySave">Save</button>
            <button class="btn" id="memoryClear">Clear</button>
          </div>
        </section>

        <!-- SSHD -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon green">&#9741;</div>
            <div class="card-title">SSHD</div>
            <div id="sshStatus" class="status-badge starting" style="margin-left:auto;">checking</div>
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="sshEnabled" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Enable SSHD</span>
          </div>
          <div class="btn-group" style="margin-top:8px;">
            <button class="btn" id="authNotification">Notification</button>
            <button class="btn" id="authPin">PIN</button>
          </div>
          <p class="muted" id="sshDetail" style="margin-top:10px;">Waiting for status...</p>
          <div id="clientKeyRow" style="display:none;margin-top:8px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="muted" style="font-family:monospace;font-size:12px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" id="clientKeyFp"></span>
              <button class="btn" id="copyClientKey" style="padding:5px 10px;font-size:12px;">Copy</button>
            </div>
          </div>
        </section>

        <!-- Python Worker -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon amber">&#9881;</div>
            <div class="card-title">Python Worker</div>
            <div id="pythonStatus" class="status-badge offline" style="margin-left:auto;">offline</div>
          </div>
          <p class="muted">Emergency restart only.</p>
          <div class="btn-group">
            <button class="btn" id="restartPython">Restart</button>
          </div>
          <p class="muted" id="pythonDetail" style="margin-top:6px;"></p>
        </section>

        <!-- Python Packages -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon amber">&#9875;</div>
            <div class="card-title">Python Packages</div>
          </div>
          <div class="card-desc">
            Download wheels into an on-device cache, then install offline.
            Source builds are typically not supported on Android.
          </div>
          <div class="field">
            <label>Package spec</label>
            <input type="text" id="pipSpec" placeholder="e.g. pyusb requests==2.32.3" />
          </div>
          <div style="margin-top:8px;display:flex;gap:14px;flex-wrap:wrap;">
            <label class="check-row"><input type="checkbox" id="pipWithDeps" checked /> Include dependencies</label>
            <label class="check-row"><input type="checkbox" id="pipOnlyBinary" checked /> Wheels only</label>
          </div>
          <div class="field" style="margin-top:10px;">
            <label>Index URL (optional)</label>
            <input type="url" id="pipIndexUrl" placeholder="https://pypi.org/simple" />
          </div>
          <div class="btn-group">
            <button class="btn" id="pipDownload">Download wheels</button>
            <button class="btn primary" id="pipInstallOffline">Install (offline)</button>
            <button class="btn" id="pipInstallNet">Install (network)</button>
          </div>
          <pre id="pipStatus" class="output-pre" style="margin-top:10px;"></pre>
          <pre id="pipOutput" class="output-pre"></pre>
        </section>

        <!-- UI Maintenance -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon red">&#9888;</div>
            <div class="card-title">UI Maintenance</div>
          </div>
          <div class="row">
            <span class="muted">Reset the UI files to defaults.</span>
            <button class="btn" id="resetUi">Reset UI</button>
          </div>
        </section>

        <!-- Permissions -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon green">&#9872;</div>
            <div class="card-title">Permissions</div>
          </div>
          <div class="card-desc">
            If enabled, tool approvals are remembered (until you clear them), similar to Android runtime permissions.
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="permRemember" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Remember approvals</span>
          </div>
          <div class="btn-group">
            <button class="btn" id="permClear">Clear saved approvals</button>
          </div>
        </section>
      </div>
    </div>

    <!-- PIN Modal -->
    <div class="modal" id="pinModal" role="dialog" aria-modal="true" aria-labelledby="pinTitle">
      <div class="modal-card">
        <div class="card-title" id="pinTitle">PIN Authentication</div>
        <div class="pin-code" id="pinCode">------</div>
        <div class="pin-countdown" id="pinCountdown">PIN inactive.</div>
        <div class="pin-bar" aria-hidden="true">
          <div id="pinBarFill" class="pin-bar-fill"></div>
        </div>
        <button class="btn danger" id="pinClose" style="width:100%;">End PIN</button>
      </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
      // ==============================
      // Helpers
      // ==============================
      const API = "http://127.0.0.1:8765";
      function $(id) { return document.getElementById(id); }

      function showToast(msg, ms) {
        const t = $("toast");
        t.textContent = msg;
        t.classList.add("show");
        setTimeout(() => t.classList.remove("show"), ms || 2000);
      }

      // ==============================
      // Router
      // ==============================
      function navigateTo(pageId) {
        document.querySelectorAll(".page").forEach(p => p.classList.remove("active"));
        $(pageId).classList.add("active");
      }
      function handleHash() {
        const h = location.hash.replace("#", "") || "chat";
        if (h === "settings") {
          guardedOpenSettings();
        } else {
          navigateTo("chatPage");
        }
      }
      window.addEventListener("hashchange", handleHash);
      handleHash();

      $("openSettingsBtn").addEventListener("click", () => {
        location.hash = "settings";
      });
      $("backToChatBtn").addEventListener("click", () => {
        location.hash = "chat";
      });

      let pendingSettingsUnlock = null;
      function getSettingsUnlockRemainingMs() {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getSettingsUnlockRemainingMs) {
            const v = Number(AndroidBridge.getSettingsUnlockRemainingMs());
            return isFinite(v) ? Math.max(0, v) : 0;
          }
        } catch (_) {}
        return 0;
      }

      function setSettingsUiLocked(locked) {
        try {
          $("brainApiKey").disabled = locked;
          $("braveSearchApiKey").disabled = locked;
        } catch (_) {}
      }

      function requestSettingsUnlock() {
        if (pendingSettingsUnlock) return pendingSettingsUnlock;
        pendingSettingsUnlock = new Promise((resolve) => {
          window.__resolveSettingsUnlock = resolve;
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.requestSettingsUnlock) {
              AndroidBridge.requestSettingsUnlock();
            } else {
              resolve({ ok: true, remaining_ms: 30000, fallback: true });
            }
          } catch (_) {
            resolve({ ok: false });
          }
        }).finally(() => { pendingSettingsUnlock = null; });
        return pendingSettingsUnlock;
      }

      window.onSettingsUnlockResult = function(payload) {
        try {
          if (window.__resolveSettingsUnlock) {
            window.__resolveSettingsUnlock(payload || { ok: false });
            window.__resolveSettingsUnlock = null;
          }
        } catch (_) {}
      };

      function refreshSecretsFromBridge() {
        const locked = getSettingsUnlockRemainingMs() <= 0;
        setSettingsUiLocked(locked);
        if (locked) {
          $("brainApiKey").value = "";
          $("brainApiKey").placeholder = "(locked)";
          $("braveSearchApiKey").value = "";
          $("braveSearchApiKey").placeholder = "(locked)";
          return;
        }
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBrainApiKeyPlain) {
            $("brainApiKey").value = AndroidBridge.getBrainApiKeyPlain() || "";
            $("brainApiKey").placeholder = "";
          }
        } catch (_) {}
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBraveSearchApiKeyPlain) {
            $("braveSearchApiKey").value = AndroidBridge.getBraveSearchApiKeyPlain() || "";
            $("braveSearchApiKey").placeholder = "";
          }
        } catch (_) {}
      }

      async function guardedOpenSettings() {
        if (getSettingsUnlockRemainingMs() <= 0) {
          const r = await requestSettingsUnlock();
          if (!r || !r.ok) {
            showToast("Settings locked", 1600);
            location.hash = "chat";
            return;
          }
        }
        navigateTo("settingsPage");
        refreshSecretsFromBridge();
        if (typeof loadMemory === "function") loadMemory();
        if (typeof checkBraveSearchKey === "function") checkBraveSearchKey();
        if (typeof loadBrainConfig === "function") loadBrainConfig();
      }

      async function ensureSettingsUnlocked() {
        if (getSettingsUnlockRemainingMs() > 0) return true;
        const brainBefore = $("brainApiKey").value;
        const braveBefore = $("braveSearchApiKey").value;
        const r = await requestSettingsUnlock();
        if (!r || !r.ok) {
          showToast("Settings locked", 1600);
          return false;
        }
        setSettingsUiLocked(false);
        if (!brainBefore && !braveBefore) {
          refreshSecretsFromBridge();
        }
        return true;
      }

      // ==============================
      // Markdown renderer (minimal)
      // ==============================
      function renderMarkdown(text) {
        let h = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Fenced code blocks
        h = h.replace(/```(\w*)\n([\s\S]*?)```/g, function(_, lang, code) {
          return "<pre><code>" + code.replace(/<br\s*\/?>/g, "\n") + "</code></pre>";
        });

        // Inline code
        h = h.replace(/`([^`\n]+)`/g, "<code>$1</code>");

        // Bold
        h = h.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");

        // Italic
        h = h.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "<em>$1</em>");

        // Blockquote lines
        h = h.replace(/(^|\n)&gt; (.+)/g, "$1<blockquote>$2</blockquote>");

        // Paragraphs
        h = h.replace(/\n\n+/g, "</p><p>");
        h = "<p>" + h + "</p>";
        h = h.replace(/<p><\/p>/g, "");

        // Single newlines -> <br> (not inside <pre>)
        const parts = h.split(/(<pre[\s\S]*?<\/pre>)/g);
        for (let i = 0; i < parts.length; i++) {
          if (!parts[i].startsWith("<pre")) {
            parts[i] = parts[i].replace(/\n/g, "<br>");
          }
        }
        h = parts.join("");

        return h;
      }

      // ==============================
      // Chat
      // ==============================
      const chatMessages = $("chatMessages");
      const chatInput = $("chatInput");
      const chatSend = $("chatSend");
      const chatWelcome = $("chatWelcome");
      const CHAT_STORAGE_PREFIX = "kugutz.chat.conversation.v1.";
      const CHAT_SESSION_KEY = "kugutz.chat.session_id.v1";
      let conversation = [];
      let streaming = false;
      let chatSessionId = "";

      function genSessionId() {
        return "s_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 10);
      }

      function loadSessionId() {
        try {
          const existing = localStorage.getItem(CHAT_SESSION_KEY);
          if (existing && typeof existing === "string" && existing.trim()) return existing.trim();
        } catch (_) {}
        const created = genSessionId();
        try { localStorage.setItem(CHAT_SESSION_KEY, created); } catch (_) {}
        return created;
      }
      chatSessionId = loadSessionId();

      function convoStorageKey() {
        return CHAT_STORAGE_PREFIX + chatSessionId;
      }

      function saveConversation() {
        try {
          localStorage.setItem(convoStorageKey(), JSON.stringify(conversation));
        } catch (_) {}
      }

      function restoreConversation() {
        try {
          const raw = localStorage.getItem(convoStorageKey());
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return;
          conversation = parsed.filter(m =>
            m && (m.role === "user" || m.role === "assistant") && typeof m.content === "string"
          );
          for (const msg of conversation) {
            addMsg(msg.role, msg.content);
          }
        } catch (_) {}
      }

      function addMsg(role, content) {
        if (chatWelcome.parentNode) chatWelcome.remove();
        const div = document.createElement("div");
        div.className = "msg " + role;
        if (role === "assistant" || role === "user") {
          div.innerHTML = renderMarkdown(content);
        } else {
          div.textContent = content;
        }
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return div;
      }

      function addThinkingIndicator() {
        if (chatWelcome.parentNode) chatWelcome.remove();
        const div = document.createElement("div");
        div.className = "msg assistant";
        div.innerHTML = '<div class="thinking-dots"><span></span><span></span><span></span></div>';
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return div;
      }

      async function syncConversationFromServer() {
        try {
          const res = await fetch(API + "/brain/messages?limit=300&session_id=" + encodeURIComponent(chatSessionId));
          if (!res.ok) return;
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          const rebuilt = [];
          for (const msg of list) {
            if (!msg || (msg.role !== "user" && msg.role !== "assistant")) continue;
            if (typeof msg.text !== "string" || !msg.text.trim()) continue;
            rebuilt.push({ role: msg.role, content: msg.text });
          }
          if (!rebuilt.length) return;
          conversation = rebuilt.slice(-200);
          chatMessages.textContent = "";
          for (const msg of conversation) addMsg(msg.role, msg.content);
          saveConversation();
        } catch (_) {}
      }

      function autoResize() {
        chatInput.style.height = "auto";
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + "px";
      }
      chatInput.addEventListener("input", autoResize);
      chatInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
      });
      chatSend.addEventListener("click", sendChat);
      restoreConversation();
      syncConversationFromServer();

      async function sendChat() {
        if (streaming) return;
        const text = chatInput.value.trim();
        if (!text) return;
        chatInput.value = "";
        autoResize();

        conversation.push({ role: "user", content: text });
        saveConversation();
        addMsg("user", text);

        await sendAgentChat(text);
      }

      async function sendAgentChat(text) {
        streaming = true;
        chatSend.disabled = true;
        const aDiv = addThinkingIndicator();
        try {
          async function readError(res, fallbackPrefix) {
            const raw = await res.text().catch(() => "");
            try {
              const obj = raw ? JSON.parse(raw) : {};
              const msg = (obj && (obj.error || obj.detail || obj.message)) ? (obj.error || obj.detail || obj.message) : "";
              if (msg) return msg;
            } catch (_) {}
            if (raw && raw.trim()) return raw.trim().slice(0, 200);
            return fallbackPrefix + " (" + res.status + ")";
          }

          const boot = await fetch(API + "/brain/agent/bootstrap", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: "{}",
          });
          if (!boot.ok) {
            throw new Error(await readError(boot, "Agent bootstrap failed"));
          }

          const res = await fetch(API + "/brain/inbox/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ text, meta: { source: "chat_ui", session_id: chatSessionId } }),
          });
          if (!res.ok) {
            throw new Error(await readError(res, "Agent queue failed"));
          }
          const queued = await res.json();
          const itemId = queued.id || "";
          if (!itemId) {
            throw new Error("Agent item id missing");
          }

          const answer = await waitForAgentReply(itemId);
          if (!answer) {
            throw new Error("Agent timed out");
          }
          const memRe = /<<MEMORY_UPDATE>>([\s\S]*?)<<END_MEMORY>>/g;
          const cleaned = (answer || "").replace(memRe, "").trim();

          if (cleaned) {
            aDiv.innerHTML = renderMarkdown(cleaned);
            conversation.push({ role: "assistant", content: cleaned });
            saveConversation();
          } else {
            aDiv.remove();
          }
        } catch (err) {
          if (aDiv.parentNode) aDiv.remove();
          const msg = err.message || "Agent request failed";
          const friendly = {
            "brain_not_configured": "Configure Brain in Settings first.",
            "agent_vendor_not_supported": "Agent mode currently supports OpenAI-compatible providers only.",
          };
          addMsg("error", friendly[msg] || msg);
        } finally {
          streaming = false;
          chatSend.disabled = false;
        }
      }

      async function waitForAgentReply(itemId) {
        const deadline = Date.now() + 15 * 60 * 1000;
        let lastToolError = "";
        while (Date.now() < deadline) {
          const res = await fetch(
            API + "/brain/messages?limit=200&session_id=" + encodeURIComponent(chatSessionId)
          );
          if (!res.ok) {
            await new Promise(r => setTimeout(r, 700));
            continue;
          }
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          for (const msg of list) {
            const meta = msg && msg.meta ? msg.meta : {};
            if (meta.item_id !== itemId) continue;
            if (msg.role === "assistant" && typeof msg.text === "string" && msg.text.trim()) {
              return msg.text.trim();
            }
            if (msg.role === "tool" && typeof msg.text === "string") {
              try {
                const parsed = JSON.parse(msg.text);
                const result = parsed && parsed.result ? parsed.result : {};
                if (result.error) {
                  lastToolError = result.error;
                }
              } catch (_) {}
            }
          }
          await new Promise(r => setTimeout(r, 700));
        }
        if (lastToolError) {
          throw new Error(lastToolError);
        }
        return "";
      }

      // ==============================
      // Brain Config
      // ==============================
      const brainSelect = $("brainVendorModel");
      const brainCustom = $("brainCustomFields");

      function getSelectedPreset() {
        const opt = brainSelect.selectedOptions[0];
        if (!opt || !opt.dataset.vendor) return null;
        if (opt.dataset.vendor === "custom") return { vendor: "custom" };
        return {
          vendor: opt.dataset.vendor,
          base_url: opt.dataset.url,
          model: opt.value,
        };
      }

      brainSelect.addEventListener("change", () => {
        const p = getSelectedPreset();
        brainCustom.style.display = (p && p.vendor === "custom") ? "block" : "none";
      });

      async function loadBrainConfig() {
        try {
          const res = await fetch(API + "/brain/config");
          if (!res.ok) return;
          const data = await res.json();
          $("brainKeyStatus").textContent = data.has_api_key ? "API key is set." : "No API key configured.";

          const vendor = data.vendor || "";
          const model = data.model || "";
          let matched = false;
          for (const opt of brainSelect.options) {
            if (opt.dataset.vendor && opt.dataset.vendor !== "custom"
                && opt.dataset.vendor === vendor && opt.value === model) {
              opt.selected = true;
              matched = true;
              break;
            }
          }
          if (!matched && model) {
            for (const opt of brainSelect.options) {
              if (opt.value === "custom") { opt.selected = true; break; }
            }
            brainCustom.style.display = "block";
            $("brainBaseUrl").value = data.base_url || "";
            $("brainModelId").value = model;
          } else {
            brainCustom.style.display = "none";
          }
        } catch (_) {}
      }

      $("brainSave").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        const preset = getSelectedPreset();
        if (!preset) { showToast("Choose a model first"); return; }

        const payload = {};
        if (preset.vendor === "custom") {
          const baseUrl = $("brainBaseUrl").value.trim();
          const modelId = $("brainModelId").value.trim();
          if (!baseUrl || !modelId) { showToast("Fill in Base URL and Model"); return; }
          payload.vendor = "custom";
          payload.base_url = baseUrl;
          payload.model = modelId;
        } else {
          payload.vendor = preset.vendor;
          payload.base_url = preset.base_url;
          payload.model = preset.model;
        }

        const apiKey = $("brainApiKey").value.trim();
        payload.api_key = apiKey;

        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBrainApiKeyPlain) {
              AndroidBridge.setBrainApiKeyPlain(apiKey);
            }
          } catch (_) {}

          const res = await fetch(API + "/brain/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) { showToast("Failed to save config"); return; }
          await loadBrainConfig();
          refreshSecretsFromBridge();
          showToast("Brain config saved");
        } catch (_) {
          showToast("Connection error");
        }
      });

      loadBrainConfig();

      // ==============================
      // Memory Editor
      // ==============================
      const memoryEditor = $("memoryEditor");

      async function loadMemory() {
        try {
          const res = await fetch(API + "/brain/memory");
          if (!res.ok) return;
          const data = await res.json();
          memoryEditor.value = data.content || "";
        } catch (_) {}
      }

      $("memorySave").addEventListener("click", async () => {
        try {
          const res = await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: memoryEditor.value }),
          });
          if (res.ok) showToast("Memory saved");
          else showToast("Failed to save memory");
        } catch (_) { showToast("Connection error"); }
      });

      $("memoryClear").addEventListener("click", async () => {
        if (!confirm("Clear all memory? This cannot be undone.")) return;
        memoryEditor.value = "";
        try {
          await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: "" }),
          });
          showToast("Memory cleared");
        } catch (_) { showToast("Connection error"); }
      });

      loadMemory();

      // ==============================
      // Web Search Keys
      // ==============================
      async function checkBraveSearchKey() {
        try {
          $("braveSearchKeyStatus").textContent = "Checking...";
          try {
            if (getSettingsUnlockRemainingMs() > 0
                && typeof AndroidBridge !== "undefined"
                && AndroidBridge.getBraveSearchApiKeyPlain) {
              const k = (AndroidBridge.getBraveSearchApiKeyPlain() || "").trim();
              $("braveSearchKeyStatus").textContent = k ? "API key is set." : "No API key configured.";
              return;
            }
          } catch (_) {}
          const permission_id = await requestPermission("credentials", "Check Brave Search API key status");
          const res = await fetch(API + "/vault/credentials/has", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", permission_id }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          $("braveSearchKeyStatus").textContent = data.present ? "API key is set." : "No API key configured.";
        } catch (_) {
          $("braveSearchKeyStatus").textContent = "Failed to check status.";
        }
      }

      $("braveSearchCheck").addEventListener("click", checkBraveSearchKey);
      $("braveSearchSave").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        const key = $("braveSearchApiKey").value.trim();
        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain(key);
              refreshSecretsFromBridge();
              showToast("Brave key saved");
              await checkBraveSearchKey();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Set Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: key, permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key saved");
          await checkBraveSearchKey();
        } catch (_) {
          showToast("Failed to save key");
        }
      });

      $("braveSearchClear").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain("");
              refreshSecretsFromBridge();
              showToast("Brave key cleared");
              await checkBraveSearchKey();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Clear Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: "", permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key cleared");
          await checkBraveSearchKey();
        } catch (_) {
          showToast("Failed to clear key");
        }
      });

      // ==============================
      // Settings: SSHD, Python, etc.
      // ==============================
      const pythonStatus = $("pythonStatus");
      const pythonDetail = $("pythonDetail");
      const sshStatus = $("sshStatus");
      const sshEnabled = $("sshEnabled");
      const authNotification = $("authNotification");
      const authPin = $("authPin");
      const sshDetail = $("sshDetail");
      const clientKeyRow = $("clientKeyRow");
      const clientKeyFp = $("clientKeyFp");
      const copyClientKey = $("copyClientKey");
      let currentClientKeyPublic = "";
      const pinModal = $("pinModal");
      const pinCode = $("pinCode");
      const pinCountdown = $("pinCountdown");
      const pinClose = $("pinClose");
      const pinBarFill = $("pinBarFill");
      const pinDurationMs = 20000;
      let pinExpiresAt = null;
      let lastPin = null;

      function setStatus(el, value) {
        el.textContent = value;
        el.classList.remove("ok", "offline", "starting", "stopping");
        if (value === "ok") el.classList.add("ok");
        else if (value === "offline") el.classList.add("offline");
        else if (value === "stopping") el.classList.add("stopping");
        else el.classList.add("starting");
      }

      async function refreshPython() {
        try {
          const res = await fetch(API + "/python/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(pythonStatus, data.status || "offline");
        } catch (_) {
          setStatus(pythonStatus, "offline");
        }
      }

      async function refreshSsh() {
        try {
          const res = await fetch(API + "/ssh/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(sshStatus, data.running ? "ok" : "offline");
          sshEnabled.checked = !!data.enabled;
          sshDetail.textContent = "ssh " + (data.host || "aaa.bbb.ccc.ddd") + " -p " + (data.port || 2222);
          if (data.client_key_fingerprint) {
            clientKeyFp.textContent = data.client_key_fingerprint;
            clientKeyRow.style.display = "block";
          } else {
            clientKeyRow.style.display = "none";
          }
          currentClientKeyPublic = data.client_key_public || "";
        } catch (_) {
          setStatus(sshStatus, "offline");
          sshDetail.textContent = "SSHD status unavailable";
          clientKeyRow.style.display = "none";
        }
      }

      async function refreshPin() {
        try {
          const res = await fetch(API + "/ssh/pin/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.active) {
            pinExpiresAt = data.expires_at || null;
            if (!pinModal.classList.contains("show")) pinModal.classList.add("show");
            if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
            else if (lastPin && pinCode.textContent === "------") pinCode.textContent = lastPin;
            updatePinCountdown();
          } else {
            pinExpiresAt = null;
            pinBarFill.style.width = "0%";
            pinCountdown.textContent = "PIN inactive.";
            pinCode.textContent = "------";
            lastPin = null;
            if (pinModal.classList.contains("show")) {
              pinModal.classList.remove("show");
              await refreshSsh();
            }
          }
        } catch (_) {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN unavailable.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
        }
      }

      function updatePinCountdown() {
        if (!pinExpiresAt) {
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          return;
        }
        const rem = pinExpiresAt - Date.now();
        if (rem <= 0) {
          pinBarFill.style.width = "0%";
          pinExpiresAt = null;
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
          return;
        }
        pinCountdown.textContent = "Active (" + Math.ceil(rem / 1000) + "s)";
        pinBarFill.style.width = Math.round(Math.max(0, Math.min(1, rem / pinDurationMs)) * 100) + "%";
      }

      // ==============================
      // Permissions prefs
      // ==============================
      let permissionsRemember = true;
      async function loadPermissionPrefs() {
        try {
          const res = await fetch(API + "/permissions/prefs");
          if (!res.ok) throw 0;
          const data = await res.json();
          permissionsRemember = !!data.remember_approvals;
          $("permRemember").checked = permissionsRemember;
        } catch (_) {
          permissionsRemember = true;
          $("permRemember").checked = true;
        }
      }

      async function requestPermission(tool, detail) {
        const res = await fetch(API + "/permissions/request", {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify({ tool, detail, scope: (permissionsRemember ? "persistent" : "once") }),
        });
        if (!res.ok) throw new Error("permission request failed");
        const data = await res.json();
        if (data.status === "approved") return data.id;
        const deadline = Date.now() + 30000;
        while (Date.now() < deadline) {
          await new Promise(r => setTimeout(r, 500));
          try {
            const sr = await fetch(API + "/permissions/" + data.id);
            if (!sr.ok) continue;
            const sd = await sr.json();
            if (sd.status === "approved") return data.id;
            if (sd.status === "denied") throw new Error("permission denied");
          } catch (_) {}
        }
        throw new Error("permission timeout");
      }

      // ==============================
      // Pip helpers
      // ==============================
      async function refreshPipStatus() {
        try {
          const res = await fetch(API + "/pip/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          const lines = [];
          if (data.abi) lines.push("ABI: " + data.abi);
          if (data.wheelhouse_bundled) lines.push("Bundled wheels: " + data.wheelhouse_bundled);
          if (data.wheelhouse_user) lines.push("User wheel cache: " + data.wheelhouse_user);
          if (data.pip_find_links) lines.push("PIP_FIND_LINKS: " + data.pip_find_links);
          $("pipStatus").textContent = lines.join("\n");
        } catch (_) {
          $("pipStatus").textContent = "pip status unavailable.";
        }
      }

      function getPipSpec() {
        return String($("pipSpec").value || "").trim();
      }

      function setPipOutput(text) {
        $("pipOutput").textContent = text || "";
      }

      async function runPip(endpoint, payload, detail) {
        const permission_id = await requestPermission("pip", detail);
        payload = Object.assign({}, payload, { permission_id });
        const res = await fetch(API + endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        const code = data.code;
        const out = data.output || (data.error ? ("error: " + data.error) : "");
        setPipOutput((typeof code === "number" ? ("exit=" + code + "\n\n") : "") + out);
        if (!res.ok) throw new Error("pip failed");
        return data;
      }

      $("pipDownload").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Downloading wheels...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          const index_url = String($("pipIndexUrl").value || "").trim();
          await runPip(
            "/pip/download",
            { spec, with_deps, only_binary, index_url: (index_url || undefined) },
            "Download wheels: " + spec
          );
          await refreshPipStatus();
          showToast("Download complete", 1600);
        } catch (_) {
          showToast("Download failed", 2000);
        }
      });

      $("pipInstallOffline").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Installing (offline)...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          await runPip(
            "/pip/install",
            { spec, allow_network: false, no_deps: !with_deps, only_binary },
            "Install (offline): " + spec
          );
          showToast("Install complete", 1600);
        } catch (_) {
          showToast("Install failed", 2000);
        }
      });

      $("pipInstallNet").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Installing (network)...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          const index_url = String($("pipIndexUrl").value || "").trim();
          await runPip(
            "/pip/install",
            { spec, allow_network: true, no_deps: !with_deps, only_binary, index_url: (index_url || undefined) },
            "Install (network): " + spec
          );
          showToast("Install complete", 1600);
        } catch (_) {
          showToast("Install failed", 2000);
        }
      });

      $("permRemember").addEventListener("change", async () => {
        const enabled = !!$("permRemember").checked;
        permissionsRemember = enabled;
        try {
          const res = await fetch(API + "/permissions/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ remember_approvals: enabled }),
          });
          if (!res.ok) throw 0;
          showToast("Permission preference saved", 1500);
        } catch (_) {
          showToast("Failed to save preference", 2000);
        }
      });
      $("permClear").addEventListener("click", async () => {
        if (!window.confirm("Clear all saved tool approvals?")) return;
        try {
          const res = await fetch(API + "/permissions/clear", { method: "POST" });
          if (!res.ok) throw 0;
          showToast("Saved approvals cleared", 1800);
        } catch (_) {
          showToast("Failed to clear approvals", 2000);
        }
      });

      $("restartPython").addEventListener("click", async () => {
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.restartPythonWorker) {
          AndroidBridge.restartPythonWorker();
        } else {
          await fetch(API + "/python/restart", { method: "POST" });
        }
        pythonDetail.textContent = "Restart requested";
        setStatus(pythonStatus, "starting");
      });

      $("resetUi").addEventListener("click", () => {
        if (!window.confirm("Reset UI to defaults? This will overwrite any local changes.")) return;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUiToDefaults) {
          AndroidBridge.resetUiToDefaults();
        }
      });

      async function updateSshConfig() {
        const enabled = sshEnabled.checked;
        try {
          const res = await fetch(API + "/ssh/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ enabled }),
          });
          if (!res.ok) throw 0;
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to apply SSHD settings";
        }
      }

      sshEnabled.addEventListener("change", updateSshConfig);
      authNotification.addEventListener("click", async () => {
        sshDetail.textContent = "Enabling notification auth...";
        try {
          const permission_id = await requestPermission("ssh_noauth", "Enable SSH notification auth");
          const res = await fetch(API + "/ssh/noauth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 30 }),
          });
          if (!res.ok) throw 0;
          sshDetail.textContent = "Notification auth enabled";
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to enable notification auth";
        }
      });
      authPin.addEventListener("click", async () => {
        try {
          pinCode.textContent = "\u2022\u2022\u2022\u2022\u2022\u2022";
          pinCountdown.textContent = "Generating PIN...";
          pinBarFill.style.width = "0%";
          pinModal.classList.add("show");
          const permission_id = await requestPermission("ssh_pin", "Enable SSH PIN auth");
          const res = await fetch(API + "/ssh/pin/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 20 }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
          else if (lastPin) pinCode.textContent = lastPin;
          else pinCode.textContent = "PIN unavailable";
          pinModal.classList.add("show");
          pinExpiresAt = data.expires_at || (Date.now() + pinDurationMs);
          updatePinCountdown();
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to start PIN auth";
        }
      });

      copyClientKey.addEventListener("click", async () => {
        if (!currentClientKeyPublic) return;
        try {
          await navigator.clipboard.writeText(currentClientKeyPublic);
          copyClientKey.textContent = "Copied!";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        } catch (_) {
          copyClientKey.textContent = "Failed";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        }
      });

      pinClose.addEventListener("click", async () => {
        try {
          await fetch(API + "/ssh/pin/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({}),
          });
          await refreshPin();
          await refreshSsh();
        } catch (_) {
        } finally {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          lastPin = null;
          pinModal.classList.remove("show");
        }
      });

      window.onPythonStatus = function(status) {
        setStatus(pythonStatus, status);
      };

      loadPermissionPrefs();
      refreshPipStatus();
      refreshPython();
      refreshSsh();
      refreshPin();
      setInterval(refreshPython, 5000);
      setInterval(refreshSsh, 5000);
      setInterval(refreshPin, 1000);
      setInterval(updatePinCountdown, 1000);
    </script>
  </body>
</html>
