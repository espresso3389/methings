<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>me.things</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect x='6' y='10' width='20' height='12' rx='3' fill='none' stroke='%23ececf1' stroke-width='2'/><circle cx='12' cy='16' r='2' fill='%23ececf1'/><circle cx='20' cy='16' r='2' fill='%23ececf1'/><path d='M16 6v4' stroke='%23ececf1' stroke-width='2' stroke-linecap='round'/><circle cx='16' cy='4.5' r='1.5' fill='%23ececf1'/><rect x='1' y='13' width='3' height='6' rx='1.5' fill='none' stroke='%23ececf1' stroke-width='1.5'/><rect x='28' y='13' width='3' height='6' rx='1.5' fill='none' stroke='%23ececf1' stroke-width='1.5'/></svg>">
    <style>
      :root {
        color-scheme: dark;
        --bg: #0e0e10;
        --bg-raised: #18181b;
        --bg-overlay: #1e1e22;
        --surface: #24242a;
        --border: #2e2e36;
        --border-focus: #5b5bd6;
        --ink: #ececf1;
        --ink-secondary: #a1a1aa;
        --ink-muted: #71717a;
        --accent: #6366f1;
        --accent-soft: rgba(99,102,241,0.12);
        --accent-hover: #818cf8;
        --green: #22c55e;
        --green-soft: rgba(34,197,94,0.12);
        --red: #ef4444;
        --red-soft: rgba(239,68,68,0.12);
        --amber: #f59e0b;
        --amber-soft: rgba(245,158,11,0.12);
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-full: 9999px;
        --shadow: 0 2px 8px rgba(0,0,0,0.3);
        --shadow-lg: 0 8px 24px rgba(0,0,0,0.4);
        --transition: 180ms ease;
      }

      * { box-sizing: border-box; margin: 0; padding: 0; -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; }
      .msg, .msg *, textarea, input, [contenteditable] { -webkit-user-select: text; user-select: text; -webkit-touch-callout: default; }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--ink);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
        font-size: 15px;
        line-height: 1.5;
      }

      /* --- Pages --- */
      .page {
        display: none;
        flex: 1;
        flex-direction: column;
        overflow: hidden;
      }
      .page.active { display: flex; }

      /* --- Topbar --- */
      .topbar {
        flex-shrink: 0;
        height: 52px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px 0 16px;
        border-bottom: 1px solid var(--border);
        background: var(--bg-raised);
      }
      .topbar .title {
        font-weight: 700;
        font-size: 17px;
        letter-spacing: -0.2px;
      }
      .icon-btn {
        width: 38px;
        height: 38px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border);
        background: var(--surface);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 18px;
        color: var(--ink-secondary);
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .icon-btn:disabled {
        cursor: not-allowed;
        opacity: 0.55;
        filter: saturate(0.2);
      }
      .icon-btn:disabled:hover {
        background: var(--surface);
        border-color: var(--border);
        color: var(--ink-secondary);
      }
      .icon-btn svg,
      .send-btn svg,
      .attach-icon-btn svg {
        width: 15px;
        height: 15px;
        display: block;
      }
      .send-btn svg { width: 20px; height: 20px; }
      .icon-btn:active { transform: scale(0.95); }
      .icon-btn:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .icon-btn.active { background: var(--accent-soft); border-color: var(--accent); color: var(--accent-hover); }
      .icon-btn.secondary { background: transparent; border-color: transparent; }
      .icon-btn.secondary:hover { background: var(--surface); }
      .icon-btn.unlock {
        border-color: transparent;
        background: var(--accent);
        color: #fff;
      }
      .icon-btn.unlock:hover {
        border-color: transparent;
        filter: brightness(1.06);
      }
      .icon-btn.unlock:active { filter: brightness(0.96); }
      .icon-btn.small { width: 28px; height: 28px; font-size: 14px; border-radius: 6px; }
      .chat-search-bar {
        display: none;
        align-items: center;
        padding: 6px 12px;
        gap: 6px;
        background: var(--bg-raised);
        border-bottom: 1px solid var(--border);
        flex-shrink: 0;
      }
      .chat-search-bar.show { display: flex; }
      .chat-search-field {
        flex: 1;
        display: flex;
        align-items: center;
        height: 36px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        overflow: hidden;
      }
      .chat-search-field:focus-within { border-color: var(--border-focus); }
      .chat-search-bar input {
        flex: 1;
        background: transparent;
        border: none;
        color: var(--ink);
        font-size: 14px;
        padding: 0 10px;
        height: 100%;
        outline: none;
        min-width: 0;
      }
      .chat-search-count {
        font-size: 11px;
        color: var(--ink-muted);
        white-space: nowrap;
        flex-shrink: 0;
        line-height: 36px;
      }
      .chat-search-clear {
        display: grid;
        place-items: center;
        width: 28px;
        height: 28px;
        flex-shrink: 0;
        background: transparent;
        border: none;
        color: var(--ink-muted);
        font-size: 13px;
        cursor: pointer;
        border-radius: 4px;
        margin: 0 3px;
      }
      .chat-search-clear:hover:not(:disabled) { color: var(--ink); background: var(--bg-overlay); }
      .chat-search-clear:disabled { opacity: 0.3; cursor: default; }
      mark.search-hit { background: #facc15; color: #000; border-radius: 2px; }
      mark.search-hit.current { background: var(--amber); color: #000; }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      /* --- Chat page --- */
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        -webkit-overflow-scrolling: touch;
      }
      .chat-welcome {
        text-align: center;
        color: var(--ink-muted);
        margin: auto 0;
        padding: 20px;
        font-size: 14px;
        line-height: 1.7;
      }
      .chat-welcome strong {
        display: block;
        color: var(--ink);
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 6px;
      }

      .msg {
        max-width: 85%;
        padding: 10px 14px;
        border-radius: var(--radius-lg);
        line-height: 1.6;
        word-wrap: break-word;
        overflow-wrap: anywhere;
        font-size: 15px;
      }
      .msg.user {
        align-self: flex-end;
        background: var(--accent);
        color: #fff;
        border-bottom-right-radius: 4px;
      }
      .msg.assistant {
        align-self: flex-start;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-bottom-left-radius: 4px;
      }
      .msg.debug {
        border-style: dashed;
        border-color: rgba(245,158,11,0.45);
        background: var(--amber-soft);
      }
      .msg.assistant.debug { color: var(--ink); }
      .msg.debug::before {
        content: "DEBUG";
        display: inline-block;
        font-size: 10px;
        font-weight: 800;
        letter-spacing: 0.6px;
        color: var(--amber);
        background: rgba(245,158,11,0.12);
        border: 1px solid rgba(245,158,11,0.35);
        border-radius: var(--radius-full);
        padding: 2px 8px;
        margin: 0 10px 6px 0;
        vertical-align: middle;
      }
      /* Multi-party timeline styling (actor tags are injected by the server). */
      .msg.actor-codex {
        border-color: rgba(14,165,233,0.5);
        background: rgba(14,165,233,0.08);
      }
      .msg.actor-codex::before {
        content: "CODEX";
        color: var(--cyan);
        background: rgba(14,165,233,0.12);
        border-color: rgba(14,165,233,0.35);
      }
      .msg.error {
        align-self: center;
        background: var(--red-soft);
        color: var(--red);
        font-size: 13px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(239,68,68,0.2);
        max-width: 95%;
      }

      /* Markdown in messages */
      .msg pre {
        background: #0d0d0f;
        color: #d4d4d8;
        padding: 10px 12px;
        border-radius: var(--radius-sm);
        overflow-x: auto;
        white-space: pre;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 13px;
        margin: 8px 0;
        line-height: 1.5;
        border: 1px solid var(--border);
      }
      .msg.user pre { background: rgba(0,0,0,0.2); border-color: rgba(255,255,255,0.1); color: #fff; }
      .msg code:not(pre code) {
        background: rgba(255,255,255,0.08);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 0.88em;
      }
      .msg.user code:not(pre code) { background: rgba(255,255,255,0.18); }
      .msg p { margin: 4px 0; }
      .msg ul, .msg ol { margin: 4px 0; padding-left: 20px; }
      .msg li { margin: 2px 0; }
      .msg blockquote {
        border-left: 3px solid var(--accent);
        margin: 8px 0;
        padding: 2px 0 2px 12px;
        color: var(--ink-secondary);
      }

      /* Inline attachments in chat */
      .attach-wrap { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
      .attach-card {
        background: #0d0d0f;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 10px;
      }
      .attach-card.attach-card-audio {
        /* Audio should be minimal: just the player (no "card" chrome). */
        background: transparent;
        border: 0;
        padding: 0;
        position: relative;
      }
      .attach-card.attach-card-audio .attach-head,
      .attach-card.attach-card-audio .attach-hint {
        display: none;
      }
      .attach-card.attach-card-audio .attach-body audio {
        width: 100%;
        background: #0d0d0f;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 8px;
      }
      .attach-card.attach-card-audio .attach-actions {
        position: absolute;
        top: 8px;
        right: 8px;
        z-index: 2;
      }
      .attach-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .attach-head:not(:last-child) {
        margin-bottom: 8px;
      }
      .attach-actions { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }
      .attach-path {
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 12px;
        color: var(--ink-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .attach-icon-btn {
        width: 28px;
        height: 28px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(161,161,170,0.25);
        background: rgba(255,255,255,0.04);
        color: var(--ink-secondary);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 16px;
      }
      .attach-icon-btn:hover { background: rgba(255,255,255,0.08); color: var(--ink); }

      /* Fullscreen viewer */
      .viewer {
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.92);
        display: none;
        z-index: 1200;
        touch-action: none;
      }
      .viewer.show { display: flex; flex-direction: column; }
      .viewer-top {
        height: 54px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
      }
      .viewer-top .viewer-title {
        font-size: 13px;
        color: rgba(255,255,255,0.78);
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 60vw;
      }
      .viewer-body {
        flex: 1;
        display: grid;
        place-items: center;
        overflow: hidden;
        position: relative;
      }
      .viewer-img {
        max-width: 100%;
        max-height: 100%;
        transform-origin: 0 0;
        will-change: transform;
      }
      .viewer-video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #000;
      }
      .viewer-audio {
        width: min(92vw, 720px);
      }
      .viewer-iframe {
        width: 100%;
        height: 100%;
        border: 0;
        background: #fff;
      }
      .attach-body img,
      .attach-body video {
        width: 100%;
        max-height: 360px;
        object-fit: contain;
        background: #000;
        border-radius: var(--radius-sm);
      }
      .attach-body audio { width: 100%; }
      .attach-hint { color: var(--ink-muted); font-size: 12px; margin-top: 6px; }
      .attach-body pre { max-height: 200px; overflow: auto; margin: 0; font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace; font-size: 12px; line-height: 1.45; border-radius: var(--radius-sm); }
      .attach-body pre code.hljs { padding: 12px; }
      .attach-md { max-height: 200px; overflow: auto; font-size: 13px; line-height: 1.55; padding: 10px; background: var(--surface); border-radius: var(--radius-sm); }
      .viewer-text { width: 100%; height: 100%; overflow: auto; padding: 16px; font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace; font-size: 13px; line-height: 1.5; -webkit-user-select: text; user-select: text; -webkit-touch-callout: default; align-self: stretch; justify-self: stretch; }
      .viewer-text pre { margin: 0; }
      .viewer-text pre code.hljs { padding: 0; background: transparent; }
      .viewer-lined { display: flex; width: 100%; }
      .viewer-line-nums { flex-shrink: 0; padding-right: 12px; text-align: right; color: var(--ink-muted); -webkit-user-select: none; user-select: none; opacity: 0.5; border-right: 1px solid var(--border); margin-right: 12px; white-space: pre; font: inherit; }
      .viewer-lined pre { flex: 1; min-width: 0; overflow-x: auto; }
      .viewer-text .attach-md { max-height: none; overflow: visible; background: transparent; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; font-size: 15px; }
      .viewer-md-toggle { margin-right: 4px; }
      .viewer.immersive .viewer-top { display: none; }
      .viewer.immersive.show-controls .viewer-top { display: flex; }

      /* Marp — scroll mode (default): all slides vertical */
      .viewer.marp-mode { touch-action: auto; }
      .viewer-text.marp-active { padding: 0; }
      .marp-deck { width: 100%; }
      .marp-slide-wrap { width: 100%; }
      .marp-slide-wrap .marpit { width: 100%; }
      .marp-slide-wrap .marpit svg { display: block; width: 100%; height: auto; border-bottom: 1px solid rgba(255,255,255,0.06); }
      .marp-slide-wrap .marp-fallback { width: 100%; }
      .marp-slide-wrap .marp-fallback section { padding: 24px; color: var(--ink); border-bottom: 1px solid rgba(255,255,255,0.06); }
      .marp-nav { display: none; }
      .marp-nav button { width: 38px; height: 38px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--surface); cursor: pointer; display: grid; place-items: center; font-size: 18px; color: var(--ink-secondary); transition: background var(--transition), border-color var(--transition), color var(--transition); }
      .marp-nav button:hover { background: var(--bg-overlay); border-color: var(--border-focus); color: var(--ink); }
      .marp-nav button:disabled { opacity: 0.35; cursor: not-allowed; }
      .marp-counter { color: var(--ink-secondary); font-size: 13px; font-variant-numeric: tabular-nums; min-width: 48px; text-align: center; }
      /* Marp — slide mode (toggled): single slide, centered */
      .viewer.marp-slidemode .viewer-text.marp-active { display: flex !important; flex-direction: column; }
      .viewer.marp-slidemode .marp-deck { flex: 1; min-height: 0; display: flex; flex-direction: column; }
      .viewer.marp-slidemode .marp-slide-wrap { flex: 1; min-height: 0; overflow: hidden; display: flex; align-items: center; justify-content: center; }
      .viewer.marp-slidemode .marp-slide-wrap .marp-fallback { display: flex; align-items: center; justify-content: center; height: 100%; }
      /* Slide mode non-immersive: always show nav */
      .viewer.marp-slidemode .marp-nav { display: flex; align-items: center; justify-content: center; gap: 16px; padding: 10px; flex-shrink: 0; border-top: 1px solid rgba(255,255,255,0.08); }
      /* Slide mode + immersive: hide nav, but restore with controls */
      .viewer.marp-slidemode.immersive .marp-nav { display: none; }
      .viewer.marp-slidemode.immersive.show-controls .marp-nav { display: flex; }
      /* Inline Marp preview */
      .attach-marp-preview { max-height: 200px; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #000; border-radius: var(--radius-sm); }
      .attach-marp-preview > .marpit { width: 100%; }
      .attach-marp-preview > .marpit > svg { width: 100%; height: auto; }
      .attach-marp-preview > .marpit > svg:not(:first-of-type) { display: none; }
      .attach-marp-preview > .marp-fallback-thumb { padding: 16px; color: var(--ink); font-size: 13px; }

      /* Rendered markdown elements (inside .attach-md) */
      .attach-md h1 { font-size: 1.6em; font-weight: 700; margin: 16px 0 8px; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
      .attach-md h2 { font-size: 1.35em; font-weight: 700; margin: 14px 0 6px; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
      .attach-md h3 { font-size: 1.15em; font-weight: 600; margin: 12px 0 4px; }
      .attach-md h4 { font-size: 1.05em; font-weight: 600; margin: 10px 0 4px; }
      .attach-md h5 { font-size: 0.95em; font-weight: 600; margin: 8px 0 4px; }
      .attach-md h6 { font-size: 0.88em; font-weight: 600; margin: 8px 0 4px; color: var(--ink-secondary); }
      .attach-md p { margin: 6px 0; }
      .attach-md ul, .attach-md ol { margin: 6px 0; padding-left: 22px; }
      .attach-md li { margin: 2px 0; }
      .attach-md li > ul, .attach-md li > ol { margin: 2px 0; }
      .attach-md blockquote { border-left: 3px solid var(--accent); margin: 8px 0; padding: 4px 0 4px 12px; color: var(--ink-secondary); }
      .attach-md hr { border: none; border-top: 1px solid var(--border); margin: 12px 0; }
      .attach-md a { color: var(--accent-hover); text-decoration: underline; text-underline-offset: 2px; }
      .attach-md img { max-width: 100%; border-radius: var(--radius-sm); margin: 6px 0; }
      .attach-md table { border-collapse: collapse; width: 100%; margin: 8px 0; font-size: 13px; }
      .attach-md th, .attach-md td { border: 1px solid var(--border); padding: 6px 10px; text-align: left; }
      .attach-md th { background: var(--surface); font-weight: 600; }
      .attach-md pre { background: #0d0d0f; border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 10px 12px; overflow-x: auto; margin: 8px 0; font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace; font-size: 13px; line-height: 1.5; }
      .attach-md code:not(pre code) { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 4px; font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace; font-size: 0.88em; }
      .attach-md input[type="checkbox"] { margin-right: 6px; pointer-events: none; }

      /* Thinking indicator */
      .thinking-dots { display: inline-flex; gap: 4px; align-items: center; padding: 4px 0; }
      .thinking-dots span {
        width: 6px; height: 6px;
        border-radius: 50%;
        background: var(--ink-muted);
        animation: thinking 1.2s infinite;
      }
      .thinking-dots.mini span { width: 5px; height: 5px; }
      .msg-working { margin-top: 8px; }
      .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
      .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }
      @keyframes thinking {
        0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
        30% { opacity: 1; transform: scale(1); }
      }
      .thinking-wrap {
        display: flex;
        align-items: center;
      }
      .thinking-label {
        margin-left: 8px;
        color: var(--ink-muted);
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 220px;
        transition: opacity 0.2s;
      }
      .msg-working .thinking-label { margin-left: 6px; font-size: 11px; }
      .thinking-stop {
        margin-left: 12px;
        margin-right: -6px;
        width: 24px;
        height: 24px;
        border-radius: var(--radius-full);
        border: none;
        background: transparent;
        color: var(--ink-muted);
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: background var(--transition), color var(--transition);
      }
      .thinking-stop svg { width: 14px; height: 14px; display: block; }
      .thinking-stop:hover { background: var(--surface); color: var(--ink-secondary); }
      .thinking-stop:active { transform: scale(0.92); }

      /* Chat input */
      .chat-input-area {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        padding: 10px 12px 14px;
        border-top: 1px solid var(--border);
        background: var(--bg-raised);
        flex-shrink: 0;
      }
      .chat-input-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
      }
      .chat-left {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-shrink: 0;
      }
      .chat-left .icon-btn {
        width: 42px;
        height: 42px;
        border-radius: var(--radius-md);
        font-size: 18px;
      }
      .chat-left .icon-btn.primary {
        background: rgba(99,102,241,0.14);
        border-color: rgba(99,102,241,0.35);
        color: #c7d2fe;
      }
      .chat-left .icon-btn.danger {
        background: rgba(239,68,68,0.12);
        border-color: rgba(239,68,68,0.35);
        color: #fecaca;
      }
      .chat-input-area textarea {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 10px 14px;
        font-family: inherit;
        font-size: 15px;
        resize: none;
        background: var(--surface);
        color: var(--ink);
        min-height: 42px;
        max-height: 120px;
        line-height: 1.4;
        outline: none;
        transition: border-color var(--transition);
      }
      .chat-input-area textarea::placeholder { color: var(--ink-muted); }
      .chat-input-area textarea:focus { border-color: var(--border-focus); }
      .send-btn {
        border: none;
        border-radius: 50%;
        width: 42px;
        height: 42px;
        background: var(--accent);
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        transition: background var(--transition), opacity var(--transition);
      }
      .send-btn:hover { background: var(--accent-hover); }
      .send-btn:active { transform: scale(0.95); }
      .send-btn:disabled { opacity: 0.35; cursor: default; }

      .composer-attachments {
        display: none;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .composer-attachments.show { display: flex; }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 9999px;
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(161,161,170,0.25);
        max-width: 100%;
      }
      .chip .chip-name {
        font-size: 13px;
        color: var(--ink);
        font-weight: 600;
        max-width: 62vw;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .chip .chip-sub {
        font-size: 11px;
        color: var(--ink-muted);
        white-space: nowrap;
      }
      .chip .chip-x {
        width: 24px;
        height: 24px;
        border-radius: 9999px;
        border: 1px solid rgba(161,161,170,0.25);
        background: rgba(0,0,0,0.15);
        color: var(--ink-secondary);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 13px;
        flex-shrink: 0;
      }
      .chip .chip-x:hover { color: var(--ink); background: rgba(255,255,255,0.08); }

      /* --- Settings page --- */
      .settings-scroll {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 12px 16px 28px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .locked-banner {
        position: fixed;
        left: 16px;
        right: 16px;
        bottom: 18px;
        z-index: 60;
        box-sizing: border-box;
        padding: 10px 12px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(245,158,11,0.70);
        /* Opaque background for readability (avoid translucent soft colors). */
        background: #2b1e06;
        color: var(--ink);
        font-size: 13px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      }
      .locked-banner .lb-row {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }
      .locked-banner .lb-ico {
        width: 28px;
        height: 28px;
        border-radius: 10px;
        display: grid;
        place-items: center;
        background: #3a2a0b;
        border: 1px solid rgba(245,158,11,0.55);
        color: #ffd08a;
        flex-shrink: 0;
        margin-top: 1px;
      }
      .locked-banner .lb-ico svg { width: 16px; height: 16px; }
      .locked-banner .lb-title {
        font-weight: 800;
        letter-spacing: 0.2px;
        margin-bottom: 2px;
      }
      .locked-banner .lb-sub { color: rgba(236,236,241,0.86); }
      @media (min-width: 640px) {
        .locked-banner {
          width: min(560px, calc(100% - 32px));
          left: 50%;
          right: auto;
          transform: translateX(-50%);
        }
      }
      /* Do not dim the entire settings UI; only disabled controls should look disabled. */

      .card {
        background: var(--bg-raised);
        border-radius: var(--radius-lg);
        padding: 16px;
        border: 1px solid var(--border);
      }
      .card.section-target {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(99,102,241,0.3), 0 0 0 8px rgba(99,102,241,0.08);
      }

      .card-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .card-icon {
        width: 34px;
        height: 34px;
        border-radius: var(--radius-sm);
        display: grid;
        place-items: center;
        font-size: 16px;
        flex-shrink: 0;
      }
      .card-icon.purple { background: var(--accent-soft); color: var(--accent); }
      .card-icon.green { background: var(--green-soft); color: var(--green); }
      .card-icon.amber { background: var(--amber-soft); color: var(--amber); }
      .card-icon.red { background: var(--red-soft); color: var(--red); }
      .card-icon.blue { background: rgba(56,189,248,0.12); color: #38bdf8; }
      .card-icon.android { background: rgba(61,220,132,0.12); color: #3ddc84; }
      .card-icon svg { width: 18px; height: 18px; fill: currentColor; }
      .card-title { font-weight: 700; font-size: 15px; }
      .card-desc { color: var(--ink-muted); font-size: 13px; line-height: 1.5; margin-bottom: 12px; }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        font-weight: 600;
        padding: 4px 10px;
        border-radius: var(--radius-full);
        text-transform: uppercase;
        letter-spacing: 0.4px;
      }
      .status-badge::before {
        content: "";
        width: 6px; height: 6px;
        border-radius: 50%;
      }
      .status-badge.ok { background: var(--green-soft); color: var(--green); }
      .status-badge.ok::before { background: var(--green); }
      .status-badge.offline { background: var(--red-soft); color: var(--red); }
      .status-badge.offline::before { background: var(--red); }
      .status-badge.starting { background: var(--amber-soft); color: var(--amber); }
      .status-badge.starting::before { background: var(--amber); }
      .status-badge.stopping { background: var(--amber-soft); color: var(--amber); }
      .status-badge.stopping::before { background: var(--amber); }

      /* Buttons */
      .btn {
        border: none;
        border-radius: var(--radius-full);
        padding: 8px 16px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        font-family: inherit;
        background: var(--surface);
        color: var(--ink-secondary);
        border: 1px solid var(--border);
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .btn.nowrap {
        white-space: nowrap;
        /* Prevent flexbox from shrinking the button and clipping the caption on narrow screens. */
        flex-shrink: 0;
      }
      .btn:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .btn:active { transform: scale(0.97); }
      .btn:disabled {
        cursor: not-allowed;
        opacity: 1;
        filter: none;
        background: rgba(255,255,255,0.06);
        border-color: rgba(161,161,170,0.20);
        color: rgba(226,232,240,0.55);
      }
      .btn:disabled:hover {
        background: rgba(255,255,255,0.06);
        border-color: rgba(161,161,170,0.20);
        color: rgba(226,232,240,0.55);
      }
      .btn:disabled:active { transform: none; }
      .btn.primary {
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
      }
      .btn.primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
      .btn.primary:disabled {
        background: rgba(99,102,241,0.35);
        border-color: rgba(99,102,241,0.2);
        color: rgba(226,232,240,0.8);
        opacity: 1;
        filter: none;
      }
      .btn.primary:disabled:hover {
        background: rgba(99,102,241,0.35);
        border-color: rgba(99,102,241,0.2);
        color: rgba(226,232,240,0.8);
      }
      .btn.danger {
        background: var(--red);
        color: #fff;
        border-color: var(--red);
      }
      .btn.danger:hover { background: #dc2626; border-color: #dc2626; }
      .btn.danger:disabled {
        background: rgba(239,68,68,0.32);
        border-color: rgba(239,68,68,0.18);
        color: rgba(254,226,226,0.85);
        opacity: 1;
        filter: none;
      }
      .btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }

      .muted { color: var(--ink-muted); font-size: 13px; word-break: break-word; overflow-wrap: anywhere; }

      /* Media preview */
      .media-preview {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        background: #0d0d0f;
        padding: 10px;
      }
      .media-preview img,
      .media-preview video {
        width: 100%;
        border-radius: var(--radius-sm);
        background: #000;
        max-height: 360px;
        object-fit: contain;
      }
      .media-preview video:fullscreen,
      .media-preview video:-webkit-full-screen,
      .viewer-video:fullscreen,
      .viewer-video:-webkit-full-screen {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #000;
      }
      .media-preview audio { width: 100%; }
      .media-preview .hint { color: var(--ink-muted); font-size: 12px; margin-top: 6px; }

      .dropzone {
        border: 1px dashed rgba(161,161,170,0.45);
        background: rgba(99,102,241,0.06);
        border-radius: var(--radius-md);
        padding: 12px;
        transition: border-color var(--transition), background var(--transition);
      }
      .dropzone.dragover {
        border-color: rgba(129,140,248,0.9);
        background: rgba(99,102,241,0.14);
      }
      .dropzone .dz-title { font-weight: 700; font-size: 13px; }
      .dropzone .dz-sub { color: var(--ink-muted); font-size: 12px; margin-top: 4px; }

      .file-list {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        overflow: hidden;
        background: rgba(0,0,0,0.18);
      }
      .file-row {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid rgba(46,46,54,0.7);
      }
      .file-row:first-child { border-top: none; }
      .file-row:hover { background: rgba(255,255,255,0.04); }
      .file-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        color: var(--ink);
        font-weight: 600;
      }
      .file-meta {
        color: var(--ink-muted);
        font-size: 12px;
        white-space: nowrap;
      }
      .pill {
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        padding: 3px 8px;
        border-radius: var(--radius-full);
        border: 1px solid rgba(161,161,170,0.28);
        color: var(--ink-secondary);
        background: rgba(255,255,255,0.04);
        flex-shrink: 0;
      }

      /* Form fields */
      .field { margin-top: 10px; }
      .field label {
        display: block;
        color: var(--ink-muted);
        font-size: 12px;
        font-weight: 600;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .field select,
      .field input[type="text"],
      .field input[type="number"],
      .field input[type="url"],
      .field input[type="password"] {
        width: 100%;
        padding: 9px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        font-family: inherit;
        font-size: 14px;
        background: var(--surface);
        color: var(--ink);
        outline: none;
        transition: border-color var(--transition);
      }
      .field select { appearance: auto; }
      .field select:focus,
      .field input:focus { border-color: var(--border-focus); }
      .field input::placeholder { color: var(--ink-muted); }
      .field select:disabled,
      .field input:disabled {
        opacity: 0.65;
        filter: saturate(0.25);
        cursor: not-allowed;
        background: rgba(255,255,255,0.04);
      }

      /* Dialog prompt input */
      #dialogInput {
        width: 100%;
        padding: 9px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        font-family: inherit;
        font-size: 14px;
        background: var(--surface);
        color: var(--ink);
        outline: none;
        transition: border-color var(--transition);
        box-sizing: border-box;
      }
      #dialogInput:focus { border-color: var(--border-focus); }
      #dialogInput::placeholder { color: var(--ink-muted); }

      /* Toggle switch */
      .toggle-row {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 4px 0;
      }
      .toggle-row .toggle-label { font-size: 14px; color: var(--ink-secondary); }
      .toggle {
        position: relative;
        width: 44px;
        height: 24px;
        flex-shrink: 0;
      }
      .toggle input { opacity: 0; width: 0; height: 0; position: absolute; }
      .toggle .slider {
        position: absolute;
        inset: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-full);
        cursor: pointer;
        transition: background var(--transition), border-color var(--transition);
      }
      .toggle .slider::before {
        content: "";
        position: absolute;
        width: 18px; height: 18px;
        left: 2px; top: 2px;
        background: var(--ink-muted);
        border-radius: 50%;
        transition: transform var(--transition), background var(--transition);
      }
      .toggle input:checked + .slider { background: var(--accent); border-color: var(--accent); }
      .toggle input:checked + .slider::before { transform: translateX(20px); background: #fff; }
      .toggle input:disabled + .slider {
        opacity: 0.55;
        cursor: not-allowed;
        filter: saturate(0.2);
      }

      /* Checkbox row */
      .check-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 3px 0;
        font-size: 14px;
        color: var(--ink-secondary);
      }
      .check-row input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--accent);
        flex-shrink: 0;
      }
      .check-row input[type="checkbox"]:disabled {
        opacity: 0.55;
        filter: saturate(0.2);
      }

      /* Textarea (memory editor) */
      .memory-textarea {
        width: 100%;
        min-height: 100px;
        max-height: 280px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 13px;
        background: var(--surface);
        color: var(--ink);
        resize: vertical;
        outline: none;
        box-sizing: border-box;
        line-height: 1.5;
        transition: border-color var(--transition);
      }
      .memory-textarea::placeholder { color: var(--ink-muted); }
      .memory-textarea:focus { border-color: var(--border-focus); }
      .memory-textarea:disabled {
        opacity: 0.65;
        filter: saturate(0.25);
        cursor: not-allowed;
        background: rgba(255,255,255,0.04);
      }

      /* Pre output */
      .output-pre {
        white-space: pre-wrap;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 12px;
        background: var(--surface);
        color: var(--ink-secondary);
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        max-height: 220px;
        overflow: auto;
        margin-top: 10px;
        line-height: 1.5;
      }

      /* PIN modal */
      .modal {
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        display: none; align-items: center; justify-content: center;
        padding: 20px; z-index: 999;
      }
      .modal.show { display: flex; }
      .modal-card {
        width: 100%; max-width: 340px;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 20px;
        box-shadow: var(--shadow-lg);
        text-align: center;
      }
      .modal-card .card-title { margin-bottom: 12px; font-size: 16px; }
      .pin-code {
        font-size: 32px;
        font-weight: 700;
        letter-spacing: 4px;
        margin: 8px 0;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        color: var(--accent);
      }
      .pin-countdown { color: var(--ink-muted); font-size: 13px; margin-bottom: 12px; }
      .pin-bar {
        width: 100%;
        height: 4px;
        background: var(--surface);
        border-radius: var(--radius-full);
        overflow: hidden;
        margin-bottom: 16px;
      }
      .pin-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.2s ease;
        border-radius: var(--radius-full);
      }
      @keyframes meSyncPrepSlide {
        0% { transform: translateX(-65%); }
        100% { transform: translateX(250%); }
      }

      /* Toast */
      .toast {
        position: fixed;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: var(--ink);
        color: var(--bg);
        padding: 10px 20px;
        border-radius: var(--radius-full);
        font-size: 13px;
        font-weight: 600;
        opacity: 0;
        transition: opacity 0.25s, transform 0.25s;
        pointer-events: none;
        z-index: 1000;
        box-shadow: var(--shadow);
      }
      .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

      /* Responsive */
      @media (max-width: 420px) {
        .settings-scroll { padding: 8px 10px 24px; }
        .card { padding: 14px; }
        .btn-group .btn { flex: 1; text-align: center; min-width: 0; }
      }
      @media (min-width: 640px) {
        .settings-scroll {
          max-width: 560px;
          margin: 0 auto;
          width: 100%;
        }
      }

      .session-chip {
        font-size: 12px;
        font-weight: 650;
        padding: 6px 12px;
        border-radius: var(--radius-full);
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--ink-secondary);
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        cursor: pointer;
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .session-chip:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .session-chip:active { transform: scale(0.95); }
      .session-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 14px;
        max-height: min(420px, 60vh);
        overflow: auto;
        text-align: left;
      }
      .session-item {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border-radius: var(--radius-md);
        border: 1px solid var(--border);
        background: var(--surface);
        cursor: pointer;
        user-select: none;
        transition: background var(--transition), border-color var(--transition);
      }
      .session-item:hover { background: var(--bg-overlay); border-color: var(--ink-muted); }
      .session-item.active {
        border-color: var(--border-focus);
        background: var(--accent-soft);
      }
      .session-item .sid {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 12px;
        color: var(--ink);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .session-item.active .sid { color: var(--accent-hover); }
      .session-item .meta { font-size: 11px; color: var(--ink-muted); white-space: nowrap; }
      .session-item .session-del {
        width: 26px;
        height: 26px;
        flex-shrink: 0;
        border-radius: var(--radius-sm);
        border: 1px solid transparent;
        background: transparent;
        color: var(--ink-muted);
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: background var(--transition), color var(--transition), border-color var(--transition);
      }
      .session-item .session-del svg { width: 14px; height: 14px; display: block; }
      .session-item .session-del:hover { background: var(--red-soft); color: var(--red); border-color: rgba(239,68,68,0.25); }
      .session-item .session-del:active { transform: scale(0.9); }
      .session-item .session-edit {
        width: 26px;
        height: 26px;
        flex-shrink: 0;
        border-radius: var(--radius-sm);
        border: 1px solid transparent;
        background: transparent;
        color: var(--ink-muted);
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: background var(--transition), color var(--transition), border-color var(--transition);
      }
      .session-item .session-edit svg { width: 14px; height: 14px; display: block; }
      .session-item .session-edit:hover { background: var(--accent-soft); color: var(--accent); border-color: rgba(99,102,241,0.25); }
      .session-item .session-edit:active { transform: scale(0.9); }

      /* Permission card (inline in chat) */
      .perm-card {
        align-self: stretch;
        max-width: 100%;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-left: 3px solid var(--accent);
        border-radius: var(--radius-md);
        padding: 12px 14px;
      }
      .perm-card-title {
        font-size: 12px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--accent);
        margin-bottom: 10px;
      }
      .perm-card-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .perm-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        transition: background var(--transition), border-color var(--transition);
      }
      .perm-item-info {
        flex: 1;
        min-width: 0;
      }
      .perm-item-tool {
        font-size: 12px;
        font-weight: 650;
        color: var(--ink);
      }
      .perm-item-detail {
        font-size: 12px;
        color: var(--ink-muted);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .perm-item-actions {
        display: flex;
        gap: 4px;
        flex-shrink: 0;
      }
      .perm-item-actions .btn { padding: 4px 10px; font-size: 11px; }
      .perm-item.approved {
        background: var(--green-soft);
        border-color: rgba(34,197,94,0.25);
      }
      .perm-item.approved .perm-item-tool,
      .perm-item.approved .perm-item-detail { opacity: 0.7; }
      .perm-item.denied {
        background: var(--red-soft);
        border-color: rgba(239,68,68,0.25);
      }
      .perm-item.denied .perm-item-tool,
      .perm-item.denied .perm-item-detail { opacity: 0.7; text-decoration: line-through; }
      .perm-card-footer {
        display: flex;
        gap: 6px;
        margin-top: 10px;
      }
      .perm-card-footer .btn { font-size: 12px; padding: 6px 14px; }
      .perm-card.resolved { opacity: 0.6; }
      .perm-overlay {
        display: none;
        position: fixed;
        bottom: 16px; left: 16px; right: 16px;
        z-index: 1300;
        background: var(--bg-raised);
        border: 1px solid var(--accent);
        border-radius: var(--radius-md);
        padding: 12px 14px;
        box-shadow: 0 4px 24px rgba(0,0,0,0.5);
        max-height: 50vh;
        overflow-y: auto;
      }
      .perm-overlay.show { display: block; }

      /* Licenses page */
      .license-summary { margin-bottom: 8px; }
      .license-section { margin-top: 10px; }
      .license-section-title { font-size: 14px; font-weight: 700; margin-bottom: 6px; color: var(--ink-secondary); }
      .license-dep {
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        background: rgba(255,255,255,0.02);
        padding: 10px;
        margin-bottom: 8px;
      }
      .license-dep-title { font-size: 13px; font-weight: 700; margin-bottom: 6px; }
      .license-doc-title { font-size: 12px; color: var(--ink-muted); margin: 8px 0 4px; }
      .license-doc-text {
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 12px;
        line-height: 1.45;
        white-space: pre-wrap;
        background: #0d0d0f;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px;
        max-height: 240px;
        overflow: hidden;
        touch-action: auto;
      }
      .license-doc-md {
        font-size: 13px;
        line-height: 1.5;
        background: #0d0d0f;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px;
        max-height: 300px;
        overflow: hidden;
        touch-action: auto;
      }
      .license-doc {
        border-color: rgba(161,161,170,0.35);
      }
      .license-doc.license-doc-active {
        overflow: auto;
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(99,102,241,0.25);
      }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/15.0.7/marked.min.js"></script>
    <script type="module">
      import { Marp } from 'https://esm.sh/@marp-team/marp-core@4?bundle';
      import marpBrowser from 'https://esm.sh/@marp-team/marp-core@4/browser?bundle';
      window._Marp = Marp;
      window._marpBrowser = marpBrowser;
      window.dispatchEvent(new Event("marp-ready"));
    </script>
  </head>
  <body>
    <!-- ===== Chat Page ===== -->
    <div id="chatPage" class="page active">
      <div class="topbar">
        <div class="title">me.things</div>
        <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
          <button class="session-chip" id="sessionChip" title="Session menu" aria-label="Session menu">default</button>
          <button class="icon-btn" id="chatSearchBtn" title="Search messages" aria-label="Search messages"></button>
          <button class="icon-btn" id="openSettingsBtn" title="Settings" aria-label="Settings"></button>
        </div>
      </div>
      <div class="chat-search-bar" id="chatSearchBar">
        <div class="chat-search-field">
          <input type="text" id="chatSearchInput" placeholder="Search messages..." />
          <span class="chat-search-count" id="chatSearchCount"></span>
          <button class="chat-search-clear" id="chatSearchClear" title="Clear" disabled>&#10005;</button>
        </div>
        <button class="icon-btn small" id="chatSearchPrev" title="Previous" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"/></svg></button>
        <button class="icon-btn small" id="chatSearchNext" title="Next" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg></button>
      </div>
      <div class="chat-messages" id="chatMessages">
        <div class="chat-welcome" id="chatWelcome">
          <strong>me.things — it thinks, it does</strong>
          Configure your AI provider in Settings,<br>then start chatting.
        </div>
      </div>
      <div class="chat-input-area">
        <div class="composer-attachments" id="composerAttachments"></div>
        <div class="muted" id="recordingStatus" style="display:none;margin-top:-6px;margin-bottom:2px;">
          Recording...
        </div>
        <div class="chat-input-row">
          <div class="chat-left">
            <button class="icon-btn primary" id="chatUploadBtn" title="Attach file(s)" aria-label="Attach file(s)"></button>
            <button class="icon-btn" id="chatRecordBtn" title="Record audio" aria-label="Record audio"></button>
          </div>
          <textarea id="chatInput" placeholder="Message..." rows="1"></textarea>
          <button class="send-btn" id="chatSend" title="Send" aria-label="Send"></button>
        </div>
      </div>
      <input type="file" id="chatUploadInput" multiple style="display:none" />
    </div>

    <!-- ===== Settings Page ===== -->
    <div id="settingsPage" class="page">
      <div class="topbar">
        <button class="icon-btn secondary" id="backToChatBtn" title="Back" aria-label="Back"></button>
        <div class="title">Settings</div>
        <!-- Spacer to keep title centered (topbar uses space-between). -->
        <div style="width:38px; height:38px;" aria-hidden="true"></div>
      </div>
      <div class="settings-scroll">
        <!-- Brain Config -->
        <section class="card" id="settings-section-brain">
          <div class="card-header">
            <div class="card-icon purple">&#9733;</div>
            <div class="card-title">Brain</div>
          </div>
          <div class="field">
            <label>Model</label>
            <select id="brainVendorModel">
              <option value="" disabled>Choose a model...</option>
              <optgroup label="OpenAI">
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2-codex">GPT-5.2 Codex</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2">GPT-5.2</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.1-codex-mini">GPT-5.1 Codex Mini</option>
              </optgroup>
              <optgroup label="Anthropic">
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-opus-4-6">Claude Opus 4.6</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-sonnet-4-5">Claude Sonnet 4.5</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-haiku-4-5">Claude Haiku 4.5</option>
              </optgroup>
              <option data-vendor="custom" value="custom">Custom...</option>
            </select>
          </div>
          <div id="brainCustomFields" style="display:none;">
            <div class="field">
              <label>Base URL</label>
              <input type="url" id="brainBaseUrl" placeholder="https://api.openai.com/v1" />
            </div>
            <div class="field">
              <label>Model ID</label>
              <input type="text" id="brainModelId" placeholder="gpt-5.2" />
            </div>
          </div>
          <div class="field">
            <label>API Key</label>
            <input type="text" id="brainApiKey" placeholder="tap to unlock" autocomplete="off" autocapitalize="none" spellcheck="false" readonly />
            <div class="muted" id="brainKeyStatus" style="margin-top:4px;"></div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="brainSave" disabled>Save</button>
          </div>
        </section>

        <!-- Web Search -->
        <section class="card" id="settings-section-web_search">
          <div class="card-header">
            <div class="card-icon green">&#9906;</div>
            <div class="card-title">Web Search</div>
          </div>
          <div class="card-desc">
            Default provider is DuckDuckGo. Brave Search is used only when an API key is configured here.
          </div>
          <div class="field">
            <label>Brave Search API Key</label>
            <input type="text" id="braveSearchApiKey" placeholder="tap to unlock" autocomplete="off" autocapitalize="none" spellcheck="false" readonly />
            <div class="muted" id="braveSearchKeyStatus" style="margin-top:4px;">Status unknown.</div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="braveSearchSave" disabled>Save</button>
            <button class="btn" id="braveSearchClear" disabled>Clear</button>
          </div>
        </section>

        <!-- Memory -->
        <section class="card" id="settings-section-memory">
          <div class="card-header">
            <div class="card-icon purple">&#9998;</div>
            <div class="card-title">Memory</div>
          </div>
          <div class="card-desc">Persistent notes the AI remembers across conversations.</div>
          <textarea id="memoryEditor"
            class="memory-textarea"
            placeholder="(empty -- the AI or you can add notes here)"></textarea>
          <div class="btn-group">
            <button class="btn primary" id="memorySave">Save</button>
            <button class="btn" id="memoryClear">Clear</button>
          </div>
        </section>

        <!-- Task Notifications -->
        <section class="card" id="settings-section-task_notifications">
          <div class="card-header">
            <div class="card-icon amber">&#128276;</div>
            <div class="card-title">Task Notifications</div>
          </div>
          <div class="card-desc">Notify when the AI agent finishes a task while the app is backgrounded.</div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="notifyAndroid" data-setting-key="notify_android" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Android notification</span>
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="notifySound" data-setting-key="notify_sound" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Play notification sound</span>
          </div>
          <div class="field" style="margin-top:10px;">
            <label>Webhook URL</label>
            <input type="url" id="notifyWebhookUrl" data-setting-key="notify_webhook_url" placeholder="https://..." />
          </div>
          <div class="btn-group" style="margin-top:10px;">
            <button class="btn primary" id="notifySave">Save</button>
          </div>
        </section>

        <!-- Audio Recording -->
        <section class="card" id="settings-section-audio_recording">
          <div class="card-header">
            <div class="card-icon red">&#127908;</div>
            <div class="card-title">Audio Recording</div>
          </div>
          <div class="card-desc">Default settings for agent-initiated audio recording and PCM streaming.</div>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
            <div class="field">
              <label>Sample Rate</label>
              <select id="audioRecSampleRate">
                <option value="8000">8 kHz</option>
                <option value="16000">16 kHz</option>
                <option value="22050">22.05 kHz</option>
                <option value="44100">44.1 kHz</option>
                <option value="48000">48 kHz</option>
              </select>
            </div>
            <div class="field">
              <label>Channels</label>
              <select id="audioRecChannels">
                <option value="1">Mono</option>
                <option value="2">Stereo</option>
              </select>
            </div>
          </div>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
            <div class="field">
              <label>Bitrate</label>
              <select id="audioRecBitrate">
                <option value="64000">64 kbps</option>
                <option value="96000">96 kbps</option>
                <option value="128000">128 kbps</option>
                <option value="192000">192 kbps</option>
                <option value="256000">256 kbps</option>
              </select>
            </div>
            <div class="field">
              <label>Max Duration (s)</label>
              <input type="number" id="audioRecMaxDuration" min="5" max="3600" value="300" />
            </div>
          </div>
          <div class="btn-group" style="margin-top:10px;">
            <button class="btn primary" id="audioRecSave">Save</button>
          </div>
        </section>

        <!-- Video Recording -->
        <section class="card" id="settings-section-video_recording">
          <div class="card-header">
            <div class="card-icon purple">&#127909;</div>
            <div class="card-title">Video Recording</div>
          </div>
          <div class="card-desc">Default settings for agent-initiated video recording.</div>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
            <div class="field">
              <label>Resolution</label>
              <select id="videoRecResolution">
                <option value="720p">720p</option>
                <option value="1080p">1080p</option>
                <option value="4k">4K</option>
              </select>
            </div>
            <div class="field">
              <label>Codec</label>
              <select id="videoRecCodec">
                <option value="h265">H.265 (HEVC)</option>
                <option value="h264">H.264 (AVC)</option>
              </select>
            </div>
          </div>
          <div class="field" style="margin-top:10px;">
            <label>Max Duration (s)</label>
            <input type="number" id="videoRecMaxDuration" min="5" max="3600" value="300" />
          </div>
          <div class="btn-group" style="margin-top:10px;">
            <button class="btn primary" id="videoRecSave">Save</button>
          </div>
        </section>

        <!-- SSHD -->
        <section class="card" id="settings-section-sshd">
          <div class="card-header">
            <div class="card-icon green">&#9741;</div>
            <div class="card-title">SSHD</div>
            <div id="sshStatus" class="status-badge starting" style="margin-left:auto;">checking</div>
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="sshEnabled" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Enable SSHD</span>
          </div>
          <div class="btn-group" style="margin-top:8px;">
            <button class="btn" id="authNotification">Notification</button>
            <button class="btn" id="authPin">PIN</button>
          </div>
          <p class="muted" id="sshDetail" style="margin-top:10px;">Waiting for status...</p>
          <div id="clientKeyRow" style="display:none;margin-top:8px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="muted" style="font-family:monospace;font-size:12px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" id="clientKeyFp"></span>
              <button class="btn" id="copyClientKey" style="padding:5px 10px;font-size:12px;">Copy</button>
            </div>
          </div>
          <div style="margin-top:14px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <div class="muted" style="font-weight:600;">Authorized Keys</div>
              <button class="btn" id="sshKeysAdd" style="margin-left:auto;padding:5px 10px;font-size:12px;">+ Add</button>
              <button class="btn" id="sshKeysRefresh" style="padding:5px 10px;font-size:12px;">Refresh</button>
            </div>
            <div class="muted" style="margin-top:6px;">
              Keys in <span style="font-family:monospace;">files/user/.ssh/authorized_keys</span>. Adding/removing requires approval.
            </div>
            <div id="sshKeysList" style="margin-top:8px;"></div>
          </div>
        </section>

        <!-- Agent Service -->
        <section class="card" id="settings-section-agent_service">
          <div class="card-header">
            <div class="card-icon amber">&#9881;</div>
            <div class="card-title">Agent Service</div>
            <div id="pythonStatus" class="status-badge offline" style="margin-left:auto;">offline</div>
          </div>
          <p class="muted">Emergency restart only.</p>
          <div class="btn-group">
            <button class="btn" id="restartPython">Restart</button>
          </div>
          <p class="muted" id="pythonDetail" style="margin-top:6px;"></p>
        </section>

        <!-- Python Packages section removed (agent can install via pip as needed) -->

        <!-- User Interface -->
        <section class="card" id="settings-section-user_interface">
          <div class="card-header">
            <div class="card-icon blue">&#9881;</div>
            <div class="card-title">User Interface</div>
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="openLinksExternal" data-setting-key="open_links_external" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Open links in external browser</span>
          </div>
          <div class="muted">When enabled, links open in the default browser instead of an in-app tab.</div>
        </section>

        <!-- Reset & Restore -->
        <section class="card" id="settings-section-reset_restore">
          <div class="card-header">
            <div class="card-icon red">&#9888;</div>
            <div class="card-title">Reset &amp; Restore</div>
          </div>
          <div class="muted">Reset UI files or agent docs to defaults.</div>
          <div class="btn-group">
            <button class="btn" id="resetUi">Reset UI</button>
            <button class="btn" id="resetAgentDocs">Reset Agent Docs</button>
          </div>
        </section>

        <!-- Android -->
        <section class="card" id="settings-section-android">
          <div class="card-header">
            <div class="card-icon android"><svg viewBox="0 0 24 24"><path d="M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h1c.55 0 1-.45 1-1V8H6v10zM3.5 8C2.67 8 2 8.67 2 9.5v7c0 .83.67 1.5 1.5 1.5S5 17.33 5 16.5v-7C5 8.67 4.33 8 3.5 8zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48A5.84 5.84 0 0 0 12 1c-.96 0-1.86.23-2.66.63L7.85.15c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31A5.983 5.983 0 0 0 6 7h12c0-2.21-1.2-4.15-2.97-5.19-.01-.02-.01-.04 0-.05zM10 5H9V4h1v1zm5 0h-1V4h1v1z"/></svg></div>
            <div class="card-title">Android</div>
          </div>
          <div class="card-desc">
            OS-level app settings and defaults (not related to UI hot-reload or asset reset).
          </div>
          <div class="muted">Open Android settings for this app.</div>
          <div class="btn-group">
            <button class="btn nowrap" id="openAppSettings">App Settings</button>
            <button class="btn nowrap" id="openOpenByDefault">Open By Default</button>
          </div>
        </section>

        <!-- Permissions -->
        <section class="card" id="settings-section-permissions">
          <div class="card-header">
            <div class="card-icon green">&#9872;</div>
            <div class="card-title">Permissions</div>
          </div>
          <div class="card-desc">
            If enabled, tool approvals are remembered (until you clear them), similar to Android runtime permissions.
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="permRemember" data-setting-key="remember_approvals" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Remember approvals</span>
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="permDangerSkip" data-setting-key="dangerously_skip_permissions" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Dangerously skip permissions (auto-allow all)</span>
          </div>
          <div class="muted" style="margin-top:6px;">
            When enabled, all permission requests are granted automatically and logged in chat.
          </div>
          <div class="btn-group">
            <button class="btn" id="permClear">Clear Saved Approvals</button>
          </div>
        </section>

        <!-- Cloud -->
        <section class="card" id="settings-section-cloud">
          <div class="card-header">
            <div class="card-icon blue">&#9729;</div>
            <div class="card-title">Cloud</div>
          </div>
          <div class="card-desc">
            Controls extra confirmations for cloud requests that upload local files.
          </div>
          <div class="field">
            <label>Auto-upload without confirm (MB)</label>
            <input type="number" id="cloudAutoUploadMb" data-setting-key="auto_upload_no_confirm_mb" min="0" max="25" step="0.5" placeholder="1.0" />
            <div class="muted" style="margin-top:4px;">
              If a cloud request uploads more than this, the UI/agent should confirm before sending.
            </div>
          </div>
          <div class="field">
            <label>Min transfer speed (KB/s)</label>
            <input type="number" id="cloudMinKbps" data-setting-key="min_transfer_kbps" min="0" max="50000" step="50" placeholder="0" />
            <div class="muted" style="margin-top:4px;">
              If set (>0), abort cloud requests when average upload/download rate drops below this.
            </div>
          </div>
          <div class="field">
            <label style="display:flex; align-items:center; gap:10px;">
              <input type="checkbox" id="cloudImgResizeEnabled" data-setting-key="image_resize_enabled" />
              <span>Resize images before upload</span>
            </label>
            <div class="muted" style="margin-top:4px;">
              Reduces upload size for vision requests (helps avoid extra confirmations).
            </div>
          </div>
          <div class="field" style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
              <label>Max image dim (px)</label>
              <input type="number" id="cloudImgMaxDim" data-setting-key="image_resize_max_dim_px" min="64" max="4096" step="64" placeholder="512" />
            </div>
            <div>
              <label>JPEG quality</label>
              <input type="number" id="cloudImgJpegQ" data-setting-key="image_resize_jpeg_quality" min="30" max="95" step="1" placeholder="70" />
            </div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="cloudPrefsSave">Save</button>
          </div>
        </section>

        <!-- me.sync -->
        <section class="card" id="settings-section-me_sync">
          <div class="card-header">
            <div class="card-icon blue">&#8646;</div>
            <div class="card-title">me.sync</div>
          </div>
          <div class="muted">Export settings/state to another device via QR/deep-link.</div>
          <p class="muted" id="meSyncStatus" style="margin-top:8px;">Not prepared.</p>
          <div class="btn-group">
            <button class="btn" id="meSyncPrepareExport">Export</button>
            <button class="btn primary" id="meSyncImport">Import</button>
          </div>
        </section>

        <!-- App Update -->
        <section class="card" id="settings-section-app_update">
          <div class="card-header">
            <div class="card-icon blue">&#8635;</div>
            <div class="card-title">App Update</div>
            <div id="appUpdateStatus" class="status-badge starting" style="margin-left:auto;">checking</div>
          </div>
          <div class="muted">Checks GitHub Releases and installs newer APKs.</div>
          <p class="muted" id="appUpdateDetail" style="margin-top:8px;">Checking latest release...</p>
          <div id="appUpdateDownloadIndicator" class="thinking-dots mini" style="display:none; margin-top:8px;">
            <span></span><span></span><span></span>
            <span class="thinking-label" style="margin-left:8px;">Downloading installer...</span>
          </div>
          <div class="btn-group">
            <button class="btn" id="checkAppUpdate">Check Update</button>
            <button class="btn" id="installAppUpdate">Install Update</button>
            <button class="btn" id="openInstallUnknownSources" style="display:none;">Allow Install Permission</button>
          </div>
        </section>

        <!-- About -->
        <section class="card" id="settings-section-about">
          <div class="card-header">
            <div class="card-icon blue">&#8505;</div>
            <div class="card-title">About</div>
          </div>
          <div class="muted">Version and project information.</div>
          <p class="muted" id="appVersionText" style="margin-top:8px;">Version: checking...</p>
          <p class="muted">Commit: <a id="appCommitLink" href="#" target="_blank" rel="noopener">checking...</a></p>
          <p class="muted">Repo: <a id="appRepoLink" href="https://github.com/espresso3389/methings" target="_blank" rel="noopener">https://github.com/espresso3389/methings</a></p>
          <div class="btn-group">
            <button class="btn" id="openLicensesPage">Licenses</button>
            <button class="btn" id="shareAppBtn">Share App</button>
          </div>
        </section>
      </div>
    </div>

    <!-- ===== Licenses Page ===== -->
    <div id="licensesPage" class="page">
      <div class="topbar">
        <button class="icon-btn secondary" id="backToSettingsFromLicenses" title="Back" aria-label="Back"></button>
        <div class="title">Licenses</div>
        <div style="width:38px; height:38px;" aria-hidden="true"></div>
      </div>
      <div class="settings-scroll">
        <div id="licensesSections"></div>
      </div>
    </div>

    <!-- PIN Modal -->
    <div class="modal" id="pinModal" role="dialog" aria-modal="true" aria-labelledby="pinTitle">
      <div class="modal-card">
        <div class="card-title" id="pinTitle">PIN Authentication</div>
        <div class="pin-code" id="pinCode">------</div>
        <div class="pin-countdown" id="pinCountdown">PIN inactive.</div>
        <div class="pin-bar" aria-hidden="true">
          <div id="pinBarFill" class="pin-bar-fill"></div>
        </div>
        <button class="btn danger" id="pinClose" style="width:100%;">End PIN</button>
      </div>
    </div>

    <!-- Session Modal -->
    <div class="modal" id="sessionModal" role="dialog" aria-modal="true" aria-labelledby="sessionTitle">
      <div class="modal-card" style="text-align:left; max-width:360px;">
        <div class="card-header">
          <div class="card-icon purple">&#9654;</div>
          <div class="card-title" id="sessionTitle" style="margin-bottom:0;">Sessions</div>
          <button class="icon-btn secondary" id="sessionClose" style="margin-left:auto; width:32px; height:32px;" title="Close" aria-label="Close"></button>
        </div>
        <div class="session-list" id="sessionList"></div>
        <div style="display:flex; align-items:center; gap:6px; margin-top:10px;">
          <button class="icon-btn" id="sessionNew" style="width:30px; height:30px;" title="New session" aria-label="New session"></button>
          <button class="icon-btn" id="sessionRefresh" style="width:30px; height:30px;" title="Refresh" aria-label="Refresh"></button>
        </div>
      </div>
    </div>

    <!-- App Dialog (replaces native confirm/prompt) -->
    <div class="modal" id="dialogModal" role="dialog" aria-modal="true">
      <div class="modal-card" style="text-align:left; max-width:340px;">
        <div class="card-title" id="dialogTitle" style="margin-bottom:8px; font-size:15px;"></div>
        <div class="muted" id="dialogMessage" style="font-size:13px; margin-bottom:14px; white-space:pre-line;"></div>
        <div id="dialogInputWrap" style="display:none; margin-bottom:14px;">
          <input type="text" id="dialogInput" autocomplete="off" autocapitalize="none" spellcheck="false" />
        </div>
        <div class="btn-group" id="dialogButtons"></div>
      </div>
    </div>

    <!-- me.sync Export Modal -->
    <div class="modal" id="meSyncModal" role="dialog" aria-modal="true" aria-labelledby="meSyncModalTitle">
      <div class="modal-card" style="text-align:left; max-width:360px;">
        <div class="card-header">
          <div class="card-icon blue">&#8646;</div>
          <div class="card-title" id="meSyncModalTitle" style="margin-bottom:0;">me.sync Export</div>
          <button class="icon-btn secondary" id="meSyncModalClose" style="margin-left:auto; width:32px; height:32px;" title="Close" aria-label="Close"></button>
        </div>
        <div class="muted" id="meSyncModalStatus" style="margin-top:8px;">Preparing export...</div>
        <div id="meSyncPrepareWrap" style="display:none; margin-top:10px;">
          <div style="height:8px; border:1px solid var(--border); border-radius:999px; overflow:hidden; background:rgba(255,255,255,0.06);">
            <div id="meSyncPrepareBar" style="height:100%; width:40%; border-radius:999px; background:linear-gradient(90deg, rgba(56,189,248,0.35), rgba(56,189,248,0.95), rgba(56,189,248,0.35)); animation: meSyncPrepSlide 1.1s linear infinite;"></div>
          </div>
          <div class="muted" id="meSyncPrepareText" style="margin-top:8px;">Preparing export (00:00)</div>
        </div>
        <div id="meSyncQrWrap" style="display:none; margin-top:10px; text-align:center;">
          <img id="meSyncQrImage" alt="me.sync QR" style="width:260px; height:260px; image-rendering: pixelated; border:1px solid rgba(0,0,0,0.12); border-radius:10px; background:#fff;" />
          <div class="muted" id="meSyncExpireText" style="margin-top:8px;"></div>
        </div>
        <div class="btn-group" style="margin-top:12px;">
          <button class="btn" id="meSyncExportCancel">Cancel</button>
          <button class="btn" id="meSyncCopyUri">Copy URI</button>
        </div>
      </div>
    </div>

    <!-- me.sync Import Progress Modal -->
    <div class="modal" id="meSyncImportModal" role="dialog" aria-modal="true" aria-labelledby="meSyncImportModalTitle">
      <div class="modal-card" style="text-align:left; max-width:360px;">
        <div class="card-header">
          <div class="card-icon blue">&#10515;</div>
          <div class="card-title" id="meSyncImportModalTitle" style="margin-bottom:0;">me.sync Import</div>
          <button class="icon-btn secondary" id="meSyncImportModalClose" style="margin-left:auto; width:32px; height:32px;" title="Close" aria-label="Close"></button>
        </div>
        <div class="muted" id="meSyncImportModalStatus" style="margin-top:8px;">Starting import...</div>
        <div id="meSyncImportProgressWrap" style="display:block; margin-top:10px;">
          <div style="height:8px; border:1px solid var(--border); border-radius:999px; overflow:hidden; background:rgba(255,255,255,0.06);">
            <div style="height:100%; width:40%; border-radius:999px; background:linear-gradient(90deg, rgba(34,197,94,0.35), rgba(34,197,94,0.95), rgba(34,197,94,0.35)); animation: meSyncPrepSlide 1.1s linear infinite;"></div>
          </div>
          <div class="muted" id="meSyncImportProgressText" style="margin-top:8px;">Elapsed 00:00</div>
        </div>
      </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Fullscreen Media Viewer -->
    <div class="viewer" id="viewer" role="dialog" aria-modal="true">
      <div class="viewer-top" id="viewerTop">
        <button class="icon-btn secondary" id="viewerClose" title="Close" aria-label="Close"></button>
        <div class="viewer-title" id="viewerTitle"></div>
        <button class="icon-btn" id="viewerSourceToggle" title="View source" aria-label="View source" style="display:none;"></button>
        <button class="icon-btn" id="viewerShare" title="Share" aria-label="Share"></button>
      </div>
      <div class="viewer-body" id="viewerBody">
        <img class="viewer-img" id="viewerImg" alt="" />
        <video class="viewer-video" id="viewerVideo" controls playsinline style="display:none;"></video>
        <audio class="viewer-audio" id="viewerAudio" controls style="display:none;"></audio>
        <iframe class="viewer-iframe" id="viewerIframe" style="display:none;" referrerpolicy="no-referrer"></iframe>
        <div class="viewer-text" id="viewerText" style="display:none;"></div>
      </div>
    </div>

    <div class="perm-overlay" id="permOverlay"></div>

    <script>
      // ==============================
      // Helpers
      // ==============================
      const API = location.origin;
      const WS_BASE = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      function $(id) { return document.getElementById(id); }

      const ICON = {
        settings: '<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.05-1.59a.5.5 0 0 0 .12-.64l-2-3.46a.5.5 0 0 0-.6-.22l-2.42.98a7.23 7.23 0 0 0-1.63-.94l-.37-2.6A.5.5 0 0 0 13.8 2h-3.6a.5.5 0 0 0-.49.42l-.37 2.6c-.58.23-1.12.54-1.63.94l-2.42-.98a.5.5 0 0 0-.6.22l-2 3.46a.5.5 0 0 0 .12.64l2.05 1.59c-.04.31-.06.63-.06.94s.02.63.06.94l-2.05 1.59a.5.5 0 0 0-.12.64l2 3.46a.5.5 0 0 0 .6.22l2.42-.98c.5.39 1.05.7 1.63.94l.37 2.6a.5.5 0 0 0 .49.42h3.6a.5.5 0 0 0 .49-.42l.37-2.6c.58-.23 1.12-.54 1.63-.94l2.42.98a.5.5 0 0 0 .6-.22l2-3.46a.5.5 0 0 0-.12-.64l-2.05-1.59ZM12 15.5A3.5 3.5 0 1 1 12 8.5a3.5 3.5 0 0 1 0 7Z"/></svg>',
        attach: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21.44 11.05 12.25 20.24a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.82-2.83l8.49-8.48"/></svg>',
        mic: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>',
        stop: '<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><rect x="7" y="7" width="10" height="10" rx="2"/></svg>',
        send: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>',
        back: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>',
        close: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M18 6 6 18"/><path d="M6 6l12 12"/></svg>',
        share: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><path d="M8.6 13.5 15.4 17.5"/><path d="M15.4 6.5 8.6 10.5"/></svg>',
        plus: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 5v14"/><path d="M5 12h14"/></svg>',
        refresh: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12a9 9 0 1 1-2.64-6.36"/><path d="M21 3v6h-6"/></svg>',
        externalLink: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>',
        code: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>',
        doc: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>',
        expand: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg>',
        collapse: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>',
        slideSingle: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="8" y1="8" x2="16" y2="8"/><line x1="8" y1="12" x2="14" y2="12"/></svg>',
        slideScroll: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="3" y="1" width="18" height="9" rx="1.5"/><line x1="7" y1="4" x2="15" y2="4"/><line x1="7" y1="7" x2="12" y2="7"/><rect x="3" y="14" width="18" height="9" rx="1.5"/><line x1="7" y1="17" x2="15" y2="17"/><line x1="7" y1="20" x2="12" y2="20"/></svg>',
        search: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        edit: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>',
      };

      // Set static button icons (record button is handled by setRecordUi()).
      try { $("chatSearchBtn").innerHTML = ICON.search; } catch (_) {}
      try { $("openSettingsBtn").innerHTML = ICON.settings; } catch (_) {}
      try { $("chatUploadBtn").innerHTML = ICON.attach; } catch (_) {}
      try { $("chatSend").innerHTML = ICON.send; } catch (_) {}
      try { $("backToChatBtn").innerHTML = ICON.back; } catch (_) {}
      try { $("backToSettingsFromLicenses").innerHTML = ICON.back; } catch (_) {}
      try { $("viewerClose").innerHTML = ICON.close; } catch (_) {}
      try { $("viewerShare").innerHTML = ICON.share; } catch (_) {}
      try { $("viewerSourceToggle").innerHTML = ICON.code; } catch (_) {}
      try { $("sessionNew").innerHTML = ICON.plus; } catch (_) {}
      try { $("sessionRefresh").innerHTML = ICON.refresh; } catch (_) {}
      try { $("sessionClose").innerHTML = ICON.close; } catch (_) {}

      function showToast(msg, ms) {
        const t = $("toast");
        t.textContent = msg;
        t.classList.add("show");
        setTimeout(() => t.classList.remove("show"), ms || 2000);
      }

      // ==============================
      // App Dialog (confirm / prompt)
      // ==============================
      const _dlg = {
        modal: $("dialogModal"),
        title: $("dialogTitle"),
        message: $("dialogMessage"),
        inputWrap: $("dialogInputWrap"),
        input: $("dialogInput"),
        buttons: $("dialogButtons"),
        resolve: null,
      };

      function appConfirm(title, message, opts) {
        var cancelLabel = (opts && opts.cancel) || "Cancel";
        var okLabel = (opts && opts.ok) || "Confirm";
        var okClass = (opts && opts.okClass) || "danger";
        return new Promise((resolve) => {
          if (_dlg.resolve) { _dlg.resolve(null); }
          _dlg.title.textContent = title;
          _dlg.message.textContent = message;
          _dlg.inputWrap.style.display = "none";
          _dlg.buttons.innerHTML =
            "<button class='btn' id='_dlgCancel'>" + cancelLabel + "</button>" +
            "<button class='btn " + okClass + "' id='_dlgOk'>" + okLabel + "</button>";
          _dlg.resolve = resolve;
          _dlg.modal.classList.add("show");
          $("_dlgCancel").addEventListener("click", () => { _dlg.resolve = null; _dlg.modal.classList.remove("show"); resolve(false); });
          $("_dlgOk").addEventListener("click", () => { _dlg.resolve = null; _dlg.modal.classList.remove("show"); resolve(true); });
        });
      }

      function appPrompt(title, message, placeholder) {
        return new Promise((resolve) => {
          if (_dlg.resolve) { _dlg.resolve(null); }
          _dlg.title.textContent = title;
          _dlg.message.textContent = message;
          _dlg.input.value = "";
          _dlg.input.placeholder = placeholder || "";
          _dlg.inputWrap.style.display = "";
          _dlg.buttons.innerHTML =
            "<button class='btn' id='_dlgCancel'>Cancel</button>" +
            "<button class='btn primary' id='_dlgOk'>OK</button>";
          _dlg.resolve = resolve;
          _dlg.modal.classList.add("show");
          setTimeout(() => _dlg.input.focus(), 60);
          _dlg.input.onkeydown = (e) => { if (e.key === "Enter") { e.preventDefault(); $("_dlgOk").click(); } };
          $("_dlgCancel").addEventListener("click", () => { _dlg.resolve = null; _dlg.modal.classList.remove("show"); resolve(null); });
          $("_dlgOk").addEventListener("click", () => { _dlg.resolve = null; _dlg.modal.classList.remove("show"); resolve(_dlg.input.value); });
        });
      }

      // ==============================
      // Sessions (Chat UI)
      // ==============================
      const sessionChip = $("sessionChip");
      const sessionModal = $("sessionModal");
      const sessionList = $("sessionList");

      function setSessionChipText() {
        try { sessionChip.textContent = String(chatSessionId || "default"); } catch (_) {}
      }

      function openSessionModal() {
        try { sessionModal.classList.add("show"); } catch (_) {}
        refreshSessionMenu();
      }

      function closeSessionModal() {
        try { sessionModal.classList.remove("show"); } catch (_) {}
      }

      async function refreshSessionMenu() {
        const cur = String(chatSessionId || "").trim();
        try {
          const res = await fetch(API + "/brain/sessions?limit=60");
          const data = res.ok ? await res.json().catch(() => ({})) : {};
          const items = Array.isArray(data.sessions) ? data.sessions : [];
          const uniq = [];
          function addSid(s) { if (s && !uniq.includes(s)) uniq.push(s); }
          addSid("default");
          addSid(cur);
          for (const s of loadKnownSessions()) addSid(s);
          for (const it of items) addSid(String(it.session_id || "").trim());

          const rows = [];
          for (const sid of uniq.filter(Boolean)) {
            const found = items.find(x => String(x.session_id || "").trim() === sid) || null;
            const count = found ? Number(found.count || 0) : 0;
            const last = found ? Number(found.last_created_at || 0) : 0;
            const meta = [];
            if (count) meta.push(String(count) + " msg");
            if (last) {
              const d = new Date(last);
              const now = new Date();
              const diff = now - d;
              if (diff < 60000) meta.push("just now");
              else if (diff < 3600000) meta.push(Math.floor(diff / 60000) + "m ago");
              else if (diff < 86400000) meta.push(Math.floor(diff / 3600000) + "h ago");
              else meta.push(d.toLocaleDateString());
            }
            const isCur = sid === cur;
            const eSid = sid.replace(/'/g, "&#39;");
            const hSid = sid.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
            rows.push(
              "<div class='session-item" + (isCur ? " active" : "") + "' data-sid='" + eSid + "'>" +
                "<div style='min-width:0; flex:1;'>" +
                  "<div class='sid'>" + hSid + "</div>" +
                  (meta.length ? "<div class='meta'>" + meta.join(" &middot; ") + "</div>" : "") +
                "</div>" +
                (isCur ? "<div style='font-size:10px; font-weight:700; letter-spacing:0.4px; text-transform:uppercase; color:var(--accent); background:var(--accent-soft); border:1px solid rgba(99,102,241,0.25); border-radius:var(--radius-full); padding:2px 8px;'>active</div>" : "") +
                "<button class='session-edit' data-edit='" + eSid + "' title='Rename session'>" + ICON.edit + "</button>" +
                "<button class='session-del' data-del='" + eSid + "' title='Delete session'>" + ICON.close + "</button>" +
              "</div>"
            );
          }
          sessionList.innerHTML = rows.join("") || "<div class='muted'>(no sessions)</div>";
          for (const el of sessionList.querySelectorAll(".session-item[data-sid]")) {
            el.addEventListener("click", async (e) => {
              if (e.target.closest(".session-del") || e.target.closest(".session-edit")) return;
              const sid = String(el.getAttribute("data-sid") || "").trim();
              if (!sid) return;
              await switchChatSession(sid);
              closeSessionModal();
            });
          }
          for (const btn of sessionList.querySelectorAll(".session-del[data-del]")) {
            btn.addEventListener("click", async (e) => {
              e.stopPropagation();
              const sid = String(btn.getAttribute("data-del") || "").trim();
              if (!sid) return;
              if (!await appConfirm("Delete session", "Delete '" + sid + "'?\nThis removes the on-device transcript.")) return;
              try {
                const r = await fetch(API + "/brain/session/delete", {
                  method: "POST",
                  headers: { "Content-Type": "application/json; charset=utf-8" },
                  body: JSON.stringify({ session_id: sid }),
                });
                if (!r.ok) showToast("Removed locally (app update needed to delete transcript)", 1800);
              } catch (_) {}
              try { localStorage.removeItem(CHAT_STORAGE_PREFIX + sid); } catch (_) {}
              removeKnownSession(sid);
              if (sid === String(chatSessionId || "").trim()) {
                await switchChatSession("default");
              }
              await refreshSessionMenu();
              showToast("Session deleted", 1100);
            });
          }
          for (const btn of sessionList.querySelectorAll(".session-edit[data-edit]")) {
            btn.addEventListener("click", async (e) => {
              e.stopPropagation();
              const oldSid = String(btn.getAttribute("data-edit") || "").trim();
              if (!oldSid) return;
              let prev = oldSid;
              let newName = "";
              while (true) {
                newName = String(await appPrompt("Rename session", "New name for '" + oldSid + "'", prev) || "").trim();
                if (!newName || newName === oldSid) return;
                if (isSessionIdTaken(newName)) {
                  const retry = await appConfirm("Name taken", "Session '" + newName + "' already exists. Please choose a different name.", { cancel: "Cancel", ok: "Retry", okClass: "primary" });
                  if (!retry) return;
                  prev = newName;
                  continue;
                }
                break;
              }
              try {
                const r = await fetch(API + "/brain/session/rename", {
                  method: "POST",
                  headers: { "Content-Type": "application/json; charset=utf-8" },
                  body: JSON.stringify({ old_id: oldSid, new_id: newName }),
                });
                if (!r.ok) { showToast("Rename failed", 1400); return; }
              } catch (_) { showToast("Rename failed", 1400); return; }
              removeKnownSession(oldSid);
              saveKnownSession(newName);
              try { localStorage.removeItem(CHAT_STORAGE_PREFIX + oldSid); } catch (_) {}
              if (oldSid === String(chatSessionId || "").trim()) {
                chatSessionId = newName;
                try { localStorage.setItem(CHAT_SESSION_KEY, newName); } catch (_) {}
                setSessionChipText();
              }
              await refreshSessionMenu();
              showToast("Session renamed", 900);
            });
          }
        } catch (_) {
          sessionList.innerHTML = "<div class='muted'>(sessions unavailable)</div>";
        }
      }

      // ==============================
      // Router
      // ==============================

      function navigateTo(pageId) {
        document.querySelectorAll(".page").forEach(p => p.classList.remove("active"));
        $(pageId).classList.add("active");
      }
      function handleHash() {
        try {
          const h = location.hash.replace("#", "") || "chat";
          if (h === "settings") {
            // Route-only. Keep it minimal; opening settings should not require unlock.
            openSettings();
          } else if (h === "licenses") {
            openLicensesPageView();
          } else {
            navigateTo("chatPage");
          }
        } catch (_) {
          // Fail-safe: never brick navigation due to JS errors.
          try { navigateTo("chatPage"); } catch (_) {}
        }
      }
      window.addEventListener("hashchange", handleHash);
      handleHash();

      $("openSettingsBtn").addEventListener("click", () => {
        // Open immediately (more robust than relying purely on hashchange timing).
        try {
          openSettings();
        } catch (_) {
          try { showToast("Failed to open settings", 1600); } catch (_) {}
        }
        location.hash = "settings";
      });
      $("backToChatBtn").addEventListener("click", () => {
        location.hash = "chat";
      });
      $("backToSettingsFromLicenses").addEventListener("click", () => {
        location.hash = "settings";
      });

      let pendingSettingsUnlock = null;
      function getSettingsUnlockRemainingMs() {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getSettingsUnlockRemainingMs) {
            const v = Number(AndroidBridge.getSettingsUnlockRemainingMs());
            return isFinite(v) ? Math.max(0, v) : 0;
          }
        } catch (_) {}
        return 0;
      }

      function requestSettingsUnlock() {
        if (pendingSettingsUnlock) return pendingSettingsUnlock;
        pendingSettingsUnlock = new Promise((resolve) => {
          window.__resolveSettingsUnlock = resolve;
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.requestSettingsUnlock) {
              AndroidBridge.requestSettingsUnlock();
            } else {
              resolve({ ok: true, remaining_ms: 30000, fallback: true });
            }
          } catch (_) {
            resolve({ ok: false });
          }
        }).finally(() => { pendingSettingsUnlock = null; });
        return pendingSettingsUnlock;
      }

      window.onSettingsUnlockResult = function(payload) {
        try {
          if (window.__resolveSettingsUnlock) {
            window.__resolveSettingsUnlock(payload || { ok: false });
            window.__resolveSettingsUnlock = null;
          }
        } catch (_) {}
      };

      // ==============================
      // Secret Fields (Biometric-on-demand)
      // ==============================
      const SECRET_PLACEHOLDER = "tap to unlock";
      function isBridgeUnlocked() {
        return getSettingsUnlockRemainingMs() > 0;
      }
      function lockSecretField(el) {
        if (!el) return;
        el.dataset.secretLocked = "1";
        el.dataset.secretOriginal = "";
        el.readOnly = true;
        el.value = "";
        el.placeholder = SECRET_PLACEHOLDER;
      }
      function markSecretOriginal(el) {
        if (!el) return;
        el.dataset.secretOriginal = String(el.value || "");
      }
      function isSecretDirty(el) {
        if (!el) return false;
        if (String(el.dataset.secretLocked || "1") !== "0") return false;
        return String(el.value || "") !== String(el.dataset.secretOriginal || "");
      }
      function currentBrainKeyContext() {
        const preset = getSelectedPreset ? getSelectedPreset() : null;
        if (!preset) return { vendor: "", base_url: "" };
        if (preset.vendor === "custom") {
          return { vendor: "custom", base_url: String($("brainBaseUrl").value || "").trim() };
        }
        return { vendor: String(preset.vendor || ""), base_url: String(preset.base_url || "") };
      }
      async function unlockBrainKeyField() {
        const el = $("brainApiKey");
        if (!el) return false;
        const r = await requestSettingsUnlock();
        if (!r || !r.ok) return false;
        const ctx = currentBrainKeyContext();
        let v = "";
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBrainApiKeyFor) {
            v = AndroidBridge.getBrainApiKeyFor(ctx.vendor, ctx.base_url) || "";
          } else if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBrainApiKeyPlain) {
            v = AndroidBridge.getBrainApiKeyPlain() || "";
          }
        } catch (_) {}
        el.dataset.secretLocked = "0";
        el.readOnly = false;
        el.placeholder = "";
        el.value = String(v || "");
        markSecretOriginal(el);
        try { el.focus(); } catch (_) {}
        return true;
      }
      async function unlockBraveKeyField() {
        const el = $("braveSearchApiKey");
        if (!el) return false;
        const r = await requestSettingsUnlock();
        if (!r || !r.ok) return false;
        let v = "";
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBraveSearchApiKeyPlain) {
            v = AndroidBridge.getBraveSearchApiKeyPlain() || "";
          }
        } catch (_) {}
        el.dataset.secretLocked = "0";
        el.readOnly = false;
        el.placeholder = "";
        el.value = String(v || "");
        markSecretOriginal(el);
        try { el.focus(); } catch (_) {}
        return true;
      }

      function refreshSecretFieldsLockState() {
        // If the bridge re-locks (timeout), re-hide secrets in the UI.
        if (isBridgeUnlocked()) return;
        try { lockSecretField($("brainApiKey")); } catch (_) {}
        try { lockSecretField($("braveSearchApiKey")); } catch (_) {}
      }
      setInterval(refreshSecretFieldsLockState, 700);

      const SETTINGS_SECTIONS = [
        { id: "brain", domId: "settings-section-brain", label: "Brain" },
        { id: "web_search", domId: "settings-section-web_search", label: "Web Search" },
        { id: "memory", domId: "settings-section-memory", label: "Memory" },
        { id: "task_notifications", domId: "settings-section-task_notifications", label: "Task Notifications" },
        { id: "audio_recording", domId: "settings-section-audio_recording", label: "Audio Recording" },
        { id: "video_recording", domId: "settings-section-video_recording", label: "Video Recording" },
        { id: "sshd", domId: "settings-section-sshd", label: "SSHD" },
        { id: "agent_service", domId: "settings-section-agent_service", label: "Agent Service" },
        { id: "user_interface", domId: "settings-section-user_interface", label: "User Interface" },
        { id: "reset_restore", domId: "settings-section-reset_restore", label: "Reset & Restore" },
        { id: "android", domId: "settings-section-android", label: "Android" },
        { id: "permissions", domId: "settings-section-permissions", label: "Permissions" },
        { id: "cloud", domId: "settings-section-cloud", label: "Cloud" },
        { id: "me_sync", domId: "settings-section-me_sync", label: "me.sync" },
        { id: "app_update", domId: "settings-section-app_update", label: "App Update" },
        { id: "about", domId: "settings-section-about", label: "About" },
      ];
      const settingsSectionMap = (function() {
        const m = {};
        for (const s of SETTINGS_SECTIONS) m[s.id] = s;
        return m;
      })();

      function normalizeSettingsSectionToken(raw) {
        return String(raw || "")
          .trim()
          .toLowerCase()
          .replace(/^settings\s*[:/]\s*/i, "")
          .replace(/[-\s]+/g, "_");
      }

      function buildSettingsKeyToSectionMap() {
        const m = {};
        try {
          const nodes = document.querySelectorAll("[data-setting-key]");
          nodes.forEach((node) => {
            const raw = String(node.getAttribute("data-setting-key") || "").trim();
            if (!raw) return;
            const sectionEl = node.closest("section.card[id^='settings-section-']");
            if (!sectionEl) return;
            const sid = normalizeSettingsSectionToken(sectionEl.id.replace(/^settings-section-/, ""));
            if (!sid) return;
            raw.split(",").forEach((part) => {
              const key = normalizeSettingsSectionToken(part);
              if (!key || m[key]) return;
              m[key] = sid;
            });
          });
        } catch (_) {}
        return m;
      }

      function getSettingsKeyToSectionMap() {
        return buildSettingsKeyToSectionMap();
      }

      function resolveSettingsSection(raw) {
        const token = normalizeSettingsSectionToken(raw);
        if (!token) return null;
        if (settingsSectionMap[token]) return settingsSectionMap[token];
        const byKey = getSettingsKeyToSectionMap();
        if (byKey[token] && settingsSectionMap[byKey[token]]) {
          return settingsSectionMap[byKey[token]];
        }
        return null;
      }

      function highlightSettingsSection(el) {
        if (!el) return;
        try {
          document.querySelectorAll(".card.section-target").forEach((n) => n.classList.remove("section-target"));
          el.classList.add("section-target");
          setTimeout(() => {
            try { el.classList.remove("section-target"); } catch (_) {}
          }, 1800);
        } catch (_) {}
      }

      function openSettingsSection(sectionRaw) {
        openSettings();
        try { location.hash = "settings"; } catch (_) {}
        const section = resolveSettingsSection(sectionRaw);
        if (!section) return false;
        const el = $(section.domId);
        if (!el) return false;
        requestAnimationFrame(() => {
          try { el.scrollIntoView({ behavior: "smooth", block: "start" }); } catch (_) { try { el.scrollIntoView(); } catch (_) {} }
          highlightSettingsSection(el);
        });
        return true;
      }

      window.uiOpenSettingsSection = function(sectionId) {
        return openSettingsSection(sectionId);
      };

      window.uiGetSettingsSections = function() {
        const keyMap = getSettingsKeyToSectionMap();
        return SETTINGS_SECTIONS.map(function(s) {
          const keys = [];
          for (const k in keyMap) {
            if (keyMap[k] === s.id) keys.push(k);
          }
          return { id: s.id, label: s.label, setting_keys: keys };
        });
      };

      let _licensesLoaded = false;
      let _licenseDocTouchWired = false;
      function deactivateLicenseDocs() {
        try {
          document.querySelectorAll(".license-doc.license-doc-active").forEach((el) => el.classList.remove("license-doc-active"));
        } catch (_) {}
      }
      function wireLicenseDocTouchPolicy() {
        if (_licenseDocTouchWired) return;
        _licenseDocTouchWired = true;
        document.addEventListener("pointerdown", (ev) => {
          const t = ev && ev.target;
          if (!t || !t.closest) return;
          const docEl = t.closest(".license-doc");
          if (docEl) {
            try {
              document.querySelectorAll(".license-doc.license-doc-active").forEach((el) => {
                if (el !== docEl) el.classList.remove("license-doc-active");
              });
              docEl.classList.add("license-doc-active");
            } catch (_) {}
            return;
          }
          if (t.closest("#licensesPage")) {
            deactivateLicenseDocs();
          }
        }, true);
      }

      async function loadLicensesData() {
        const root = $("licensesSections");
        root.innerHTML = "";
        wireLicenseDocTouchPolicy();
        try {
          const res = await fetch("licenses/full_licenses.json", { cache: "no-store" });
          if (!res.ok) throw 0;
          const data = await res.json();
          const sections = Array.isArray(data.sections) ? data.sections : [];
          if (!sections.length) {
            root.innerHTML = "<div class='muted'>(empty)</div>";
            return;
          }
          const frag = document.createDocumentFragment();
          for (const sec of sections) {
            const deps = Array.isArray(sec.dependencies) ? sec.dependencies : [];
            if (!deps.length) continue;
            const secBox = document.createElement("div");
            secBox.className = "license-section";
            const h = document.createElement("div");
            h.className = "license-section-title";
            h.textContent = String(sec.label || sec.ecosystem || "Other");
            secBox.appendChild(h);
            for (const d of deps) {
              const depBox = document.createElement("div");
              depBox.className = "license-dep";
              const title = document.createElement("div");
              title.className = "license-dep-title";
              const name = String(d.name || "(unknown)");
              const ver = String(d.version || "").trim();
              title.textContent = ver ? (name + "@" + ver) : name;
              depBox.appendChild(title);
              const docs = Array.isArray(d.documents) ? d.documents : [];
              if (!docs.length) {
                const miss = document.createElement("div");
                miss.className = "muted";
                miss.textContent = "No bundled license text found.";
                depBox.appendChild(miss);
              } else {
                for (const doc of docs) {
                  const dt = document.createElement("div");
                  dt.className = "license-doc-title";
                  dt.textContent = String(doc.title || "LICENSE");
                  depBox.appendChild(dt);
                  const body = document.createElement("div");
                  const fmt = String(doc.format || "text").toLowerCase();
                  const txt = String(doc.text || "");
                  try {
                    if (fmt === "markdown") {
                      body.className = "license-doc license-doc-md";
                      body.innerHTML = renderMarkdown(txt);
                    } else {
                      body.className = "license-doc license-doc-text";
                      body.textContent = txt;
                    }
                  } catch (_) {
                    body.className = "license-doc license-doc-text";
                    body.textContent = txt;
                  }
                  depBox.appendChild(body);
                }
              }
              secBox.appendChild(depBox);
            }
            frag.appendChild(secBox);
          }
          root.innerHTML = "";
          root.appendChild(frag);
        } catch (_) {
          root.innerHTML = "<div class='muted'>Failed to load license data.</div>";
        }
      }

      function openLicensesPageView() {
        navigateTo("licensesPage");
        deactivateLicenseDocs();
        if (_licensesLoaded) return;
        _licensesLoaded = true;
        loadLicensesData();
      }

      function openSettings() {
        // Keep this minimal and robust. Heavy/permission-gated settings loaders run on demand.
        navigateTo("settingsPage");
        // Do not globally lock the page. Secrets are revealed only on explicit biometric unlock.
        try { lockSecretField($("brainApiKey")); } catch (_) {}
        try { lockSecretField($("braveSearchApiKey")); } catch (_) {}
      }
      async function ensureSensitiveUnlocked() {
        const r = await requestSettingsUnlock();
        if (!r || !r.ok) {
          showToast("Authentication required", 1600);
          return false;
        }
        return true;
      }

      // ==============================
      // Markdown renderer (minimal)
      // ==============================
      function escapeHtml(s) { return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;"); }

      function renderMarkdownFallback(text) {
        let h = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        h = h.replace(/```(\w*)\n([\s\S]*?)```/g, function(_, lang, code) {
          return "<pre><code>" + code.replace(/<br\s*\/?>/g, "\n") + "</code></pre>";
        });
        h = h.replace(/`([^`\n]+)`/g, "<code>$1</code>");
        h = h.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        h = h.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "<em>$1</em>");
        h = h.replace(/(^|\n)&gt; (.+)/g, "$1<blockquote>$2</blockquote>");
        h = h.replace(/\n\n+/g, "</p><p>");
        h = "<p>" + h + "</p>";
        h = h.replace(/<p><\/p>/g, "");
        const parts = h.split(/(<pre[\s\S]*?<\/pre>)/g);
        for (let i = 0; i < parts.length; i++) {
          if (!parts[i].startsWith("<pre")) parts[i] = parts[i].replace(/\n/g, "<br>");
        }
        return parts.join("");
      }

      function renderMarkdown(text) {
        if (typeof marked !== "undefined" && marked.parse) {
          try {
            const html = marked.parse(text, { gfm: true, breaks: true });
            // Apply hljs to code blocks in a temporary container
            const tmp = document.createElement("div");
            tmp.innerHTML = html;
            tmp.querySelectorAll("pre code[class*='language-']").forEach(function(el) {
              try { hljs.highlightElement(el); } catch (_) {}
            });
            return tmp.innerHTML;
          } catch (_) {}
        }
        return renderMarkdownFallback(text);
      }

      // ==============================
      // Marp presentation helpers
      // ==============================
      function isMarpMarkdown(text) {
        const m = text.match(/^---\s*\n([\s\S]*?)\n---/);
        return m != null && /^marp\s*:\s*true\s*$/m.test(m[1]);
      }

      function renderMarpSlides(container, text) {
        const deck = document.createElement("div");
        deck.className = "marp-deck";
        const slideWrap = document.createElement("div");
        slideWrap.className = "marp-slide-wrap";
        deck.appendChild(slideWrap);

        let slides;
        let usedMarp = false;

        // Try Marp-core first
        if (window._Marp) {
          try {
            const marp = new window._Marp({ script: false, html: true });
            const result = marp.render(text);
            const wrapper = document.createElement("div");
            wrapper.className = "marpit";
            wrapper.innerHTML = "<style>" + result.css + "</style>" + result.html;
            slideWrap.appendChild(wrapper);
            if (window._marpBrowser) {
              try { window._marpBrowser(slideWrap); } catch (_) {}
            }
            // Marp output may nest SVGs in various ways; try multiple selectors
            slides = wrapper.querySelectorAll("svg[data-marpit-svg]");
            if (!slides.length) slides = wrapper.querySelectorAll("svg");
            if (slides.length) usedMarp = true;
            else { slideWrap.removeChild(wrapper); }
          } catch (e) {
            console.warn("Marp render failed, using fallback:", e);
            usedMarp = false;
          }
        }

        // Fallback: split on --- and render with marked.js
        if (!usedMarp) {
          const stripped = text.replace(/^---\s*\n[\s\S]*?\n---\n?/, "");
          const parts = stripped.split(/\n---\n/);
          const fb = document.createElement("div");
          fb.className = "marp-fallback";
          parts.forEach(function(part) {
            const trimmed = part.trim();
            if (!trimmed) return;
            const sec = document.createElement("section");
            sec.className = "attach-md";
            sec.innerHTML = renderMarkdown(trimmed);
            fb.appendChild(sec);
          });
          slideWrap.appendChild(fb);
          slides = fb.querySelectorAll("section");
        }

        if (!slides || slides.length === 0) return null;

        let current = 0;
        const total = slides.length;

        function show(idx, scroll) {
          current = Math.max(0, Math.min(total - 1, idx));
          var isSlideMode = viewer.classList.contains("marp-slidemode");
          for (let i = 0; i < total; i++) {
            slides[i].classList.toggle("active", i === current);
            slides[i].style.display = isSlideMode ? ((i === current) ? "block" : "none") : "";
          }
          if (!isSlideMode && scroll) {
            try { slides[current].scrollIntoView({ behavior: "smooth", block: "start" }); } catch (_) {}
          }
          counter.textContent = (current + 1) + " / " + total;
          prevBtn.disabled = current === 0;
          nextBtn.disabled = current === total - 1;
        }
        deck._show = show;
        deck._slideCount = total;
        deck._enterPresentation = function() {
          for (let i = 0; i < total; i++) {
            slides[i].style.display = (i === current) ? "block" : "none";
          }
        };
        deck._exitPresentation = function() {
          for (let i = 0; i < total; i++) {
            slides[i].style.display = "";
          }
        };

        // Navigation bar
        const nav = document.createElement("div");
        nav.className = "marp-nav";
        const prevBtn = document.createElement("button");
        prevBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>';
        prevBtn.title = "Previous slide";
        prevBtn.setAttribute("aria-label", "Previous slide");
        prevBtn.addEventListener("click", function() { show(current - 1); });
        const counter = document.createElement("span");
        counter.className = "marp-counter";
        const nextBtn = document.createElement("button");
        nextBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>';
        nextBtn.title = "Next slide";
        nextBtn.setAttribute("aria-label", "Next slide");
        nextBtn.addEventListener("click", function() { show(current + 1); });
        nav.appendChild(prevBtn);
        nav.appendChild(counter);
        nav.appendChild(nextBtn);
        deck.appendChild(nav);

        show(0);

        // Swipe navigation
        let swX0 = 0, swY0 = 0, swT0 = 0;
        slideWrap.addEventListener("touchstart", function(ev) {
          if (!ev.touches || ev.touches.length !== 1) return;
          swX0 = ev.touches[0].clientX;
          swY0 = ev.touches[0].clientY;
          swT0 = Date.now();
        }, { passive: true });
        slideWrap.addEventListener("touchend", function(ev) {
          if (!ev.changedTouches || ev.changedTouches.length === 0) return;
          const dx = ev.changedTouches[0].clientX - swX0;
          const dy = ev.changedTouches[0].clientY - swY0;
          const dt = Date.now() - swT0;
          if (dt < 400 && Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy) * 1.5) {
            if (dx < 0) show(current + 1);
            else show(current - 1);
          }
        }, { passive: true });

        // Keyboard navigation
        deck._marpKeyHandler = function(ev) {
          if (ev.key === "ArrowLeft" || ev.key === "ArrowUp") { show(current - 1); ev.preventDefault(); }
          else if (ev.key === "ArrowRight" || ev.key === "ArrowDown" || ev.key === " ") { show(current + 1); ev.preventDefault(); }
        };

        container.appendChild(deck);
        return deck;
      }

      const _marpPendingPreviews = [];
      window.addEventListener("marp-ready", function () {
        _marpPendingPreviews.forEach(function (item) {
          item.container.innerHTML = "";
          renderMarpPreview(item.container, item.text, item.page);
        });
        _marpPendingPreviews.length = 0;
      });

      function renderMarpPreview(container, text, page) {
        const idx = (typeof page === "number" && page >= 0) ? page : 0;
        if (window._Marp) {
          try {
            const marp = new window._Marp({ script: false, html: true });
            const result = marp.render(text);
            const wrapper = document.createElement("div");
            wrapper.className = "marpit";
            wrapper.innerHTML = "<style>" + result.css + "</style>" + result.html;
            // Keep only the target slide SVG for the preview thumbnail
            const svgs = wrapper.querySelectorAll("svg");
            const target = Math.min(idx, svgs.length - 1);
            for (let i = 0; i < svgs.length; i++) { if (i !== target) svgs[i].remove(); }
            container.appendChild(wrapper);
            return;
          } catch (_) {}
        }
        // Fallback: render target slide with marked.js; re-render when Marp loads
        _marpPendingPreviews.push({ container, text, page: idx });
        const stripped = text.replace(/^---\s*\n[\s\S]*?\n---\n?/, "");
        const parts = stripped.split(/\n---\n/);
        const slideText = parts[Math.min(idx, parts.length - 1)] || "";
        const thumb = document.createElement("div");
        thumb.className = "marp-fallback-thumb attach-md";
        thumb.innerHTML = renderMarkdown(slideText.trim());
        container.appendChild(thumb);
      }

      let _viewerMarpExpand = null;
      function openMarpViewer(path, content, page) {
        const rel = safeRelPath(path);
        if (!rel) return;
        viewerSourceToggle.style.display = "none";
        viewerSourceToggle.onclick = null;
        viewerCurrentRel = rel;
        viewerMode = "text";
        viewerTitle.textContent = rel;
        resetViewerPanels();
        viewerText.style.display = "block";
        viewerText.innerHTML = "";
        viewerText.classList.add("marp-active");
        viewer.classList.add("marp-mode");
        viewer.classList.remove("marp-slidemode");
        if (_viewerMdToggle) { try { _viewerMdToggle.remove(); } catch (_) {} _viewerMdToggle = null; }
        if (_viewerMarpExpand) { try { _viewerMarpExpand.remove(); } catch (_) {} _viewerMarpExpand = null; }

        const marpDeck = renderMarpSlides(viewerText, content);
        _currentMarpDeck = marpDeck;

        // Source toggle
        const srcPre = document.createElement("pre");
        const srcCode = document.createElement("code");
        srcCode.className = "language-markdown";
        srcCode.textContent = content;
        srcPre.appendChild(srcCode);
        const srcLined = wrapWithLineNumbers(srcPre, content);
        srcLined.style.display = "none";
        viewerText.appendChild(srcLined);

        let srcHighlighted = false;
        let showSource = false;
        let slideMode = false;

        // Slide mode toggle
        const expandBtn = document.createElement("button");
        expandBtn.className = "icon-btn viewer-md-toggle";
        expandBtn.title = "Slide mode";
        expandBtn.setAttribute("aria-label", "Slide mode");
        expandBtn.innerHTML = ICON.slideSingle;
        expandBtn.addEventListener("click", function() {
          slideMode = !slideMode;
          _currentSlideMode = slideMode;
          if (slideMode) {
            viewer.classList.add("marp-slidemode");
            if (marpDeck) marpDeck._enterPresentation();
            expandBtn.innerHTML = ICON.slideScroll;
            expandBtn.title = "Scroll mode";
            if (marpDeck && marpDeck._marpKeyHandler) { _marpKeyHandler = marpDeck._marpKeyHandler; document.addEventListener("keydown", _marpKeyHandler); }
          } else {
            viewer.classList.remove("marp-slidemode");
            if (marpDeck) marpDeck._exitPresentation();
            expandBtn.innerHTML = ICON.slideSingle;
            expandBtn.title = "Slide mode";
            if (_marpKeyHandler) { document.removeEventListener("keydown", _marpKeyHandler); _marpKeyHandler = null; }
          }
        });

        // Source toggle
        const toggleBtn = document.createElement("button");
        toggleBtn.className = "icon-btn viewer-md-toggle";
        toggleBtn.title = "View source";
        toggleBtn.setAttribute("aria-label", "View source");
        toggleBtn.innerHTML = ICON.code;
        toggleBtn.addEventListener("click", function() {
          showSource = !showSource;
          if (showSource) {
            if (marpDeck) marpDeck.style.display = "none";
            srcLined.style.display = "";
            viewerText.classList.remove("marp-active");
            expandBtn.style.display = "none";
            if (!srcHighlighted) { try { hljs.highlightElement(srcCode); } catch (_) {} srcHighlighted = true; }
            toggleBtn.innerHTML = ICON.doc;
            toggleBtn.title = "View slides";
            if (_marpKeyHandler) { document.removeEventListener("keydown", _marpKeyHandler); _marpKeyHandler = null; }
          } else {
            if (marpDeck) marpDeck.style.display = "";
            srcLined.style.display = "none";
            viewerText.classList.add("marp-active");
            expandBtn.style.display = "";
            toggleBtn.innerHTML = ICON.code;
            toggleBtn.title = "View source";
            if (slideMode && marpDeck && marpDeck._marpKeyHandler) { _marpKeyHandler = marpDeck._marpKeyHandler; document.addEventListener("keydown", _marpKeyHandler); }
          }
        });

        const viewerTop = $("viewerTop");
        viewerTop.insertBefore(expandBtn, viewerShare);
        viewerTop.insertBefore(toggleBtn, viewerShare);
        _viewerMarpExpand = expandBtn;
        _viewerMdToggle = toggleBtn;

        viewer.classList.add("show");
        history.pushState({ viewer: true }, "");
        // Navigate to requested page after viewer is visible so scrollIntoView works.
        if (typeof page === "number" && page >= 0 && marpDeck && marpDeck._show) {
          requestAnimationFrame(function() { marpDeck._show(page, true); });
        }
      }

      // ==============================
      // Media helpers
      // ==============================
      function parsePageFragment(p) {
        const m = String(p || "").match(/^(.+?)#page=(\d+)$/);
        if (m) return { path: m[1], page: parseInt(m[2], 10) };
        return { path: String(p || ""), page: -1 };
      }

      function extOf(name) {
        const n = String(name || "").trim().toLowerCase().replace(/#.*$/, "");
        const i = n.lastIndexOf(".");
        const e = i >= 0 ? n.slice(i + 1) : "";
        // Be robust to invisible chars accidentally copied into paths (e.g. ZWSP).
        return String(e).replace(/[^a-z0-9]+/g, "");
      }
      function isLikelyAudioWebm(name) {
        const s = String(name || "").toLowerCase();
        // Fallback: if the path/name contains the recorder prefix anywhere, treat as audio.
        if (s.includes("audio_recording")) return true;
        // Recorder filenames may use either "_" or "-" after "audio_recording".
        // Examples:
        // - audio_recording_2026-02-09T00-54-59-123Z.webm
        // - audio_recording-2026-02-09T01-18-15-881Z.webm
        if (/(^|\/)audio_recording[-_]/.test(s)) return true;
        // Some paths don't include a leading "/" (they're rel_paths). Match both forms.
        if (s.includes("uploads/recordings/")) return true;
        return false;
      }
      function kindFor(name) {
        const e = extOf(name);
        if (["png","jpg","jpeg","gif","webp","bmp","svg"].includes(e)) return "image";
        if (e === "webm") return isLikelyAudioWebm(name) ? "audio" : "video";
        if (["mp4","mkv","mov","m4v","3gp"].includes(e)) return "video";
        if (["mp3","wav","ogg","m4a","aac","flac"].includes(e)) return "audio";
        if (["txt","md","json","log","py","js","ts","html","css","sh","yaml","yml","toml","xml","csv","cfg","ini","conf","kt","java","c","cpp","h","rs","go","rb","pl"].includes(e)) return "text";
        return "bin";
      }

      function mimeForPath(p) {
        const e = extOf(p);
        if (["png"].includes(e)) return "image/png";
        if (["jpg","jpeg"].includes(e)) return "image/jpeg";
        if (["gif"].includes(e)) return "image/gif";
        if (["webp"].includes(e)) return "image/webp";
        if (["svg"].includes(e)) return "image/svg+xml";
        if (["mp4","m4v"].includes(e)) return "video/mp4";
        if (e === "webm") return isLikelyAudioWebm(p) ? "audio/webm" : "video/webm";
        if (["mov"].includes(e)) return "video/quicktime";
        if (["3gp"].includes(e)) return "video/3gpp";
        if (["mp3"].includes(e)) return "audio/mpeg";
        if (["wav"].includes(e)) return "audio/wav";
        if (["ogg"].includes(e)) return "audio/ogg";
        if (["m4a","aac"].includes(e)) return "audio/aac";
        if (["flac"].includes(e)) return "audio/flac";
        if (["json"].includes(e)) return "application/json";
        if (["txt","md","log","py","js","ts","html","css","sh","yaml","yml","toml","xml","csv","cfg","ini","conf","kt","java","c","cpp","h","rs","go","rb","pl"].includes(e)) return "text/plain";
        return "application/octet-stream";
      }

      // Pause inline media when it scrolls out of view (with a small grace period).
      // This prevents audio/video from continuing to play after the user scrolls away.
      const mediaPauseTimers = new WeakMap(); // HTMLMediaElement -> timeout id
      const mediaLastInView = new WeakMap(); // HTMLMediaElement -> bool
      let mediaObserver = null;
      function ensureMediaObserver() {
        if (mediaObserver) return mediaObserver;
        // Root is the scrollable message list so "out of view" means out of the chat viewport.
        const rootEl = document.getElementById("chatMessages") || null;
        mediaObserver = new IntersectionObserver((entries) => {
          for (const entry of entries) {
            const el = entry.target;
            if (!(el && typeof el.pause === "function")) continue;
            const inView = !!entry.isIntersecting && (entry.intersectionRatio || 0) >= 0.15;
            mediaLastInView.set(el, inView);

            const existing = mediaPauseTimers.get(el);
            if (existing) {
              clearTimeout(existing);
              mediaPauseTimers.delete(el);
            }

            if (!inView) {
              // Redemption time: if it comes back into view quickly, don't pause.
              const t = setTimeout(() => {
                try {
                  if (mediaLastInView.get(el) === false && !el.paused) el.pause();
                } catch (_) {}
              }, 500);
              mediaPauseTimers.set(el, t);
            }
          }
        }, { root: rootEl, threshold: [0, 0.15, 0.5, 1.0] });
        return mediaObserver;
      }
      function watchInlineMedia(el) {
        try { ensureMediaObserver().observe(el); } catch (_) {}
      }

      function safeRelPath(p) {
        // Normalize common "rel_path:" render variants:
        // - Trailing punctuation: "captures/latest.jpg." or "...jpg," breaks ext detection.
        // - Wrapped in quotes/backticks/brackets.
        // - Fragment like #page=3 (used for Marp slide navigation) is stripped here;
        //   callers needing the page should use parsePageFragment() before safeRelPath().
        let s = String(p || "").trim();
        // Strip zero-width/invisible separators that can break ext detection.
        s = s.replace(/[\u200b-\u200f\u202a-\u202e\ufeff]/g, "");
        s = s.replace(/#.*$/, "");
        s = s.replace(/^\/+/, "");
        s = s.replace(/^["'`<(\[]+/, "");
        s = s.replace(/["'`>\])]+$/, "");
        s = s.replace(/[.,;:]+$/, "");
        if (!s) return "";
        if (s.split("/").some(seg => seg === "..")) return "";
        return s;
      }

      function fileUrl(rel) {
        if (rel.startsWith("$sys/"))
          return API + "/sys/file?path=" + encodeURIComponent(rel.slice(5));
        return API + "/user/file?path=" + encodeURIComponent(rel);
      }

      function extractRelPathsFromText(text) {
        const t = String(text || "");
        const out = [];
        const seen = new Set();

        function add(raw) {
          // Dedup on clean path (fragment-stripped) but preserve raw form for page info.
          const p = safeRelPath(raw);
          if (p && !seen.has(p)) { out.push(raw.trim()); seen.add(p); }
        }

        // JSON-ish: "rel_path":"captures/foo.jpg" or "captures/foo.jpg#page=3"
        const reJson = /"rel_path"\s*:\s*"([^"]+)"/gi;
        let m;
        while ((m = reJson.exec(t)) !== null) add(m[1]);

        // Plain: rel_path: captures/foo.jpg
        // Also support spaces by capturing to end-of-line (common for uploaded filenames like "Slack - Ding.mp3").
        const rePlainQuoted = /\brel_path\b\s*[:=]\s*`([^`]+)`/gi;
        while ((m = rePlainQuoted.exec(t)) !== null) add(m[1]);
        const rePlainEol = /\brel_path\b\s*[:=]\s*([$a-zA-Z0-9._\-\/][$a-zA-Z0-9._\-\/ ]*\.[a-zA-Z0-9]+(?:#page=\d+)?)/gi;
        while ((m = rePlainEol.exec(t)) !== null) add(m[1]);

        // Loose fallback (common folders + media extensions).
        const reLoose = /\b(?:captures|uploads|downloads)\/[a-zA-Z0-9._\-\/]+\.(?:png|jpe?g|gif|webp|bmp|svg|mp4|webm|mkv|mov|m4v|3gp|mp3|wav|ogg|m4a|aac|flac|txt|md|json|log|py|js|ts|html|css|sh|yaml|yml|toml|xml|csv|cfg|ini|conf|kt|java|c|cpp|h|rs|go|rb|pl)\b(?:#page=\d+)?/gi;
        while ((m = reLoose.exec(t)) !== null) add(m[0]);

        return out.slice(0, 4);
      }

      function extractHtmlPathsFromText(text) {
        const t = String(text || "");
        const out = [];
        const seen = new Set();
        let m;

        const re1 = /\bhtml_path\b\s*[:=]\s*([^\r\n]+)/gi;
        while ((m = re1.exec(t)) !== null) {
          const { path: rawPath, page } = parsePageFragment(m[1]);
          const p = safeRelPath(rawPath);
          if (!p || !p.toLowerCase().endsWith(".html")) continue;
          const withPage = (page >= 0) ? (p + "#page=" + page) : p;
          if (!seen.has(withPage)) { out.push(withPage); seen.add(withPage); }
        }

        const re2 = /\bopen_html\b\s*[:=]\s*([^\r\n]+)/gi;
        while ((m = re2.exec(t)) !== null) {
          const { path: rawPath, page } = parsePageFragment(m[1]);
          const p = safeRelPath(rawPath);
          if (!p || !p.toLowerCase().endsWith(".html")) continue;
          const withPage = (page >= 0) ? (p + "#page=" + page) : p;
          if (!seen.has(withPage)) { out.push(withPage); seen.add(withPage); }
        }

        return out.slice(0, 3);
      }

      function renderInlineHtmlLinks(msgDiv, rawText) {
        const paths = extractHtmlPathsFromText(rawText);
        if (!paths.length) return;

        try {
          const old = msgDiv.querySelector(".html-wrap");
          if (old) old.remove();
        } catch (_) {}

        const wrap = document.createElement("div");
        wrap.className = "html-wrap";
        wrap.style.marginTop = "10px";

        for (const p0 of paths) {
          const { path: pCleanRaw, page: pPage } = parsePageFragment(p0);
          const p = safeRelPath(pCleanRaw);
          if (!p) continue;
          const pWithPage = (pPage >= 0) ? (p + "#page=" + pPage) : p;
          const card = document.createElement("div");
          card.className = "attach-card";
          card.style.cursor = "pointer";

          const head = document.createElement("div");
          head.className = "attach-head";
          const pathEl = document.createElement("div");
          pathEl.className = "attach-path";
          pathEl.textContent = p;
          const actions = document.createElement("div");
          actions.className = "attach-actions";
          const shareBtn = document.createElement("button");
          shareBtn.className = "attach-icon-btn";
          shareBtn.title = "Share";
          shareBtn.setAttribute("aria-label", "Share");
          shareBtn.innerHTML = ICON.share;
          shareBtn.addEventListener("click", async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            try {
              if (typeof AndroidBridge !== "undefined" && AndroidBridge.shareUserFile) {
                AndroidBridge.shareUserFile(p, mimeForPath(p));
                return;
              }
              const url = fileUrl(p);
              if (navigator.share) {
                await navigator.share({ title: p, url });
              } else if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(url);
                showToast("Link copied", 1400);
              } else {
                showToast("Share not available", 1600);
              }
            } catch (_) {
              showToast("Share failed", 1800);
            }
          });
          const openBtn = document.createElement("button");
          openBtn.className = "attach-icon-btn";
          openBtn.title = "Open";
          openBtn.setAttribute("aria-label", "Open");
          openBtn.innerHTML = ICON.externalLink;
          const open = () => {
            try {
              openHtmlViewer(pWithPage);
              return;
            } catch (_) {
              if (typeof AndroidBridge !== "undefined") {
                try { location.href = "methings://open_user_html?path=" + encodeURIComponent(p); } catch (_) {}
                return;
              }
              try {
                window.open(fileUrl(p), "_blank", "noopener,noreferrer");
              } catch (_) {}
            }
          };
          openBtn.addEventListener("click", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            open();
          });
          actions.appendChild(shareBtn);
          actions.appendChild(openBtn);
          head.appendChild(pathEl);
          head.appendChild(actions);
          card.appendChild(head);
          card.addEventListener("click", open);
          wrap.appendChild(card);
        }

        if (wrap.childNodes.length) msgDiv.appendChild(wrap);
      }

      function renderInlineAttachments(msgDiv, rawText) {
        const paths = extractRelPathsFromText(rawText);
        if (!paths.length) return;

        // Avoid duplicating attachment cards when the same bubble is re-rendered/upgraded
        // by polling/rotation recovery.
        try {
          const old = msgDiv.querySelector(".attach-wrap");
          if (old) old.remove();
        } catch (_) {}

        const wrap = document.createElement("div");
        wrap.className = "attach-wrap";

        for (const p0 of paths) {
          const { path: p0Clean, page: p0Page } = parsePageFragment(p0);
          const p = safeRelPath(p0Clean);
          if (!p) continue;
          let kind = kindFor(p);
          const pLower = String(p).toLowerCase();
          const forceAudioWebm =
            (extOf(p) === "webm") &&
            (pLower.includes("uploads/recordings/") || pLower.includes("audio_recording"));
          // Defensive: some Android builds treat .webm as video by default. If the path clearly
          // indicates an audio recording, force audio rendering.
          try {
            if (kind === "video" && extOf(p) === "webm" && isLikelyAudioWebm(p)) kind = "audio";
            // Stronger heuristic: our mic recordings are stored under uploads/recordings.
            // Always render these as audio even if the extension is .webm.
            if (extOf(p) === "webm" && String(p).toLowerCase().includes("uploads/recordings/")) kind = "audio";
          } catch (_) {}
          const card = document.createElement("div");
          card.className = "attach-card";
          if (kind === "audio" || forceAudioWebm) card.classList.add("attach-card-audio");

          const head = document.createElement("div");
          head.className = "attach-head";
          const pathEl = document.createElement("div");
          pathEl.className = "attach-path";
          pathEl.textContent = p;
          const actions = document.createElement("div");
          actions.className = "attach-actions";
          const shareBtn = document.createElement("button");
          shareBtn.className = "attach-icon-btn";
          shareBtn.title = "Share";
          shareBtn.setAttribute("aria-label", "Share");
          shareBtn.innerHTML = ICON.share;
          shareBtn.addEventListener("click", async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            try {
              if (typeof AndroidBridge !== "undefined" && AndroidBridge.shareUserFile) {
                AndroidBridge.shareUserFile(p, mimeForPath(p));
              } else {
                showToast("Share not available", 1600);
              }
            } catch (_) {
              showToast("Share failed", 1800);
            }
          });
          actions.appendChild(shareBtn);
          head.appendChild(pathEl);
          head.appendChild(actions);

          const body = document.createElement("div");
          body.className = "attach-body";
          const hint = document.createElement("div");
          hint.className = "attach-hint";
          hint.textContent = "Loading preview...";

          card.appendChild(head);
          card.appendChild(body);
          card.appendChild(hint);

          wrap.appendChild(card);

          (async () => {
            try {
              const src = fileUrl(p);
              if (kind === "image") {
                const img = document.createElement("img");
                img.alt = p;
                img.loading = "lazy";
                img.src = src;
                img.dataset.relPath = p;
                img.style.cursor = "zoom-in";
                const open = () => { try { openViewerFor(p); } catch (_) {} };
                img.addEventListener("click", open);
                card.addEventListener("click", (ev) => {
                  // Don't steal clicks from the Share icon.
                  if (ev.target && (ev.target.closest && ev.target.closest(".attach-icon-btn"))) return;
                  open();
                });
                img.addEventListener("error", () => { hint.textContent = "Preview failed"; });
                img.addEventListener("load", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                body.appendChild(img);
                hint.textContent = "Image (tap to zoom)";
              } else if (kind === "video") {
                if (forceAudioWebm) {
                  const a = document.createElement("audio");
                  a.controls = true;
                  a.preload = "metadata";
                  a.src = src;
                  a.addEventListener("loadedmetadata", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                  a.addEventListener("error", () => { try { card.remove(); } catch (_) {} });
                  body.appendChild(a);
                  watchInlineMedia(a);
                  card.style.cursor = "pointer";
                  card.addEventListener("click", (ev) => {
                    if (ev.target && ev.target.closest && ev.target.closest(".attach-icon-btn")) return;
                    if (ev.target && ev.target.closest && ev.target.closest("audio,video")) return;
                    try { openMediaViewer(p, "audio"); } catch (_) {}
                  });
                  hint.textContent = "Audio (tap to open)";
                  return;
                }
                const v = document.createElement("video");
                v.controls = true;
                v.playsInline = true;
                v.preload = "metadata";
                v.src = src;
                attachVideoFullscreenFix(v);
                v.addEventListener("loadedmetadata", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                v.addEventListener("error", () => { try { card.remove(); } catch (_) {} });
                body.appendChild(v);
                watchInlineMedia(v);
                card.style.cursor = "pointer";
                card.addEventListener("click", (ev) => {
                  if (ev.target && ev.target.closest && ev.target.closest(".attach-icon-btn")) return;
                  if (ev.target && ev.target.closest && ev.target.closest("audio,video")) return;
                  try { openMediaViewer(p, "video"); } catch (_) {}
                });
                hint.textContent = "Video (tap to open)";
              } else if (kind === "audio") {
                const a = document.createElement("audio");
                a.controls = true;
                a.preload = "metadata";
                a.src = src;
                a.addEventListener("loadedmetadata", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                a.addEventListener("error", () => { try { card.remove(); } catch (_) {} });
                body.appendChild(a);
                watchInlineMedia(a);
                card.style.cursor = "pointer";
                card.addEventListener("click", (ev) => {
                  if (ev.target && ev.target.closest && ev.target.closest(".attach-icon-btn")) return;
                  if (ev.target && ev.target.closest && ev.target.closest("audio,video")) return;
                  try { openMediaViewer(p, "audio"); } catch (_) {}
                });
                // Audio attachments are rendered as a minimal player; the card header/hint are hidden by CSS.
                hint.textContent = "Audio (tap to open)";
              } else if (kind === "text") {
                const ext = extOf(p);
                try {
                  const res = await fetch(src);
                  const content = await res.text();
                  if (ext === "md" && isMarpMarkdown(content)) {
                    const preview = document.createElement("div");
                    preview.className = "attach-marp-preview";
                    renderMarpPreview(preview, content, p0Page);
                    body.appendChild(preview);
                    const srcPre = document.createElement("pre");
                    srcPre.style.display = "none";
                    const srcCode = document.createElement("code");
                    srcCode.className = "language-markdown";
                    srcCode.textContent = content;
                    srcPre.appendChild(srcCode);
                    body.appendChild(srcPre);
                    let srcHighlighted = false;
                    let showSource = false;
                    const toggleBtn = document.createElement("button");
                    toggleBtn.className = "attach-icon-btn";
                    toggleBtn.title = "View source";
                    toggleBtn.setAttribute("aria-label", "View source");
                    toggleBtn.innerHTML = ICON.code;
                    toggleBtn.addEventListener("click", (ev) => {
                      ev.preventDefault();
                      ev.stopPropagation();
                      showSource = !showSource;
                      if (showSource) {
                        preview.style.display = "none";
                        srcPre.style.display = "";
                        if (!srcHighlighted) { try { hljs.highlightElement(srcCode); } catch (_) {} srcHighlighted = true; }
                        toggleBtn.innerHTML = ICON.doc;
                        toggleBtn.title = "View rendered";
                      } else {
                        preview.style.display = "";
                        srcPre.style.display = "none";
                        toggleBtn.innerHTML = ICON.code;
                        toggleBtn.title = "View source";
                      }
                    });
                    actions.appendChild(toggleBtn);
                    hint.textContent = "Marp deck (tap to present)";
                  } else if (ext === "md") {
                    const mdDiv = document.createElement("div");
                    mdDiv.className = "attach-md";
                    mdDiv.innerHTML = renderMarkdown(content);
                    body.appendChild(mdDiv);
                    const srcPre = document.createElement("pre");
                    srcPre.style.display = "none";
                    const srcCode = document.createElement("code");
                    srcCode.className = "language-markdown";
                    srcCode.textContent = content;
                    srcPre.appendChild(srcCode);
                    body.appendChild(srcPre);
                    let srcHighlighted = false;
                    let showSource = false;
                    const toggleBtn = document.createElement("button");
                    toggleBtn.className = "attach-icon-btn";
                    toggleBtn.title = "View source";
                    toggleBtn.setAttribute("aria-label", "View source");
                    toggleBtn.innerHTML = ICON.code;
                    toggleBtn.addEventListener("click", (ev) => {
                      ev.preventDefault();
                      ev.stopPropagation();
                      showSource = !showSource;
                      if (showSource) {
                        mdDiv.style.display = "none";
                        srcPre.style.display = "";
                        if (!srcHighlighted) { try { hljs.highlightElement(srcCode); } catch (_) {} srcHighlighted = true; }
                        toggleBtn.innerHTML = ICON.doc;
                        toggleBtn.title = "View rendered";
                      } else {
                        mdDiv.style.display = "";
                        srcPre.style.display = "none";
                        toggleBtn.innerHTML = ICON.code;
                        toggleBtn.title = "View source";
                      }
                    });
                    actions.appendChild(toggleBtn);
                    hint.textContent = "Markdown (tap to view)";
                  } else {
                    const pre = document.createElement("pre");
                    const code = document.createElement("code");
                    const langMap = { py:"python", js:"javascript", ts:"typescript", kt:"kotlin", sh:"bash", yml:"yaml", rs:"rust", rb:"ruby", pl:"perl", h:"c", cpp:"cpp" };
                    code.className = "language-" + (langMap[ext] || ext);
                    code.textContent = content;
                    pre.appendChild(code);
                    body.appendChild(pre);
                    try { hljs.highlightElement(code); } catch (_) {}
                    hint.textContent = ext.toUpperCase() + " (tap to view)";
                  }
                  card.style.cursor = "pointer";
                  card.addEventListener("click", (ev) => {
                    if (ev.target && ev.target.closest && ev.target.closest(".attach-icon-btn")) return;
                    if (ext === "html" || ext === "htm") {
                      const pWithPage = (p0Page >= 0) ? (p + "#page=" + p0Page) : p;
                      try { openHtmlViewer(pWithPage); } catch (_) {}
                      return;
                    }
                    try { openTextViewer(p, content, ext, p0Page); } catch (_) {}
                  });
                  if (ext === "html" || ext === "htm") {
                    hint.textContent = "HTML (tap to open live view)";
                  }
                  try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {}
                } catch (_) {
                  hint.textContent = "Preview failed.";
                }
              } else {
                hint.textContent = "No inline preview for this file type.";
              }
            } catch (e) {
              hint.textContent = "Preview failed.";
            }
          })();
        }

        if (wrap.childNodes.length) {
          msgDiv.appendChild(wrap);
          try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {}
        }
      }

      // ==============================
      // Fullscreen viewer (image/video/audio/text)
      // ==============================
      const viewer = $("viewer");
      const viewerClose = $("viewerClose");
      const viewerSourceToggle = $("viewerSourceToggle");
      const viewerShare = $("viewerShare");
      const viewerTitle = $("viewerTitle");
      const viewerImg = $("viewerImg");
      const viewerVideo = $("viewerVideo");
      const viewerAudio = $("viewerAudio");
      const viewerIframe = $("viewerIframe");
      const viewerBody = $("viewerBody");
      const viewerText = $("viewerText");
      const isEmbeddedWebView = (typeof AndroidBridge !== "undefined");

      let viewerPaths = [];
      let viewerIndex = 0;
      let viewerCurrentRel = "";
      let viewerMode = "";
      let vScale = 1.0;
      let vTx = 0.0;
      let vTy = 0.0;
      let vTouchMode = "";
      let vStartDist = 0.0;
      let vStartScale = 1.0;
      let vStartTx = 0.0;
      let vStartTy = 0.0;
      let vStartX = 0.0;
      let vStartY = 0.0;
      let vSwipeStartX = 0.0;
      let vSwipeStartY = 0.0;
      let vSwipeAt = 0;
      let vPinchMidX = 0.0;
      let vPinchMidY = 0.0;
      let vOriginX = 0.0;
      let vOriginY = 0.0;
      let _lockedVideoOrientation = false;

      function _isVideoFullscreen(videoEl) {
        if (!videoEl) return false;
        const fs = document.fullscreenElement || document.webkitFullscreenElement || null;
        if (fs) return fs === videoEl;
        return !!(document.webkitIsFullScreen && videoEl.webkitDisplayingFullscreen);
      }

      function _unlockVideoOrientation() {
        if (!_lockedVideoOrientation) return;
        _lockedVideoOrientation = false;
        try {
          if (screen && screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
        } catch (_) {}
      }

      async function _syncVideoFullscreenOrientation(videoEl) {
        if (!videoEl) return;
        if (!_isVideoFullscreen(videoEl)) {
          _unlockVideoOrientation();
          return;
        }
        try {
          if (!screen || !screen.orientation || !screen.orientation.lock) return;
          const vw = Number(videoEl.videoWidth || 0);
          const vh = Number(videoEl.videoHeight || 0);
          const target = (vw > 0 && vh > 0 && vw >= vh) ? "landscape" : "portrait";
          try { screen.orientation.unlock(); } catch (_) {}
          await screen.orientation.lock(target);
          _lockedVideoOrientation = true;
        } catch (_) {}
      }

      function attachVideoFullscreenFix(videoEl) {
        if (!videoEl) return;
        const onFsMaybeChanged = () => { _syncVideoFullscreenOrientation(videoEl); };
        document.addEventListener("fullscreenchange", onFsMaybeChanged);
        document.addEventListener("webkitfullscreenchange", onFsMaybeChanged);
        videoEl.addEventListener("webkitbeginfullscreen", onFsMaybeChanged);
        videoEl.addEventListener("webkitendfullscreen", onFsMaybeChanged);
      }

      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
      function applyViewerTransform() {
        viewerImg.style.transform = `translate(${vTx}px, ${vTy}px) scale(${vScale})`;
      }
      function resetViewerTransform() {
        vScale = 1.0; vTx = 0.0; vTy = 0.0;
        applyViewerTransform();
      }
      function resetViewerPanels() {
        viewerImg.style.display = "none";
        viewerVideo.style.display = "none";
        viewerAudio.style.display = "none";
        viewerIframe.style.display = "none";
        viewerText.style.display = "none";
      }
      function collectViewerPaths() {
        const imgs = Array.from(document.querySelectorAll('.attach-body img[data-rel-path]'));
        const out = [];
        const seen = new Set();
        for (const im of imgs) {
          const p = safeRelPath(im.dataset.relPath || "");
          if (p && !seen.has(p)) { out.push(p); seen.add(p); }
        }
        return out;
      }
      async function setViewerImage(p) {
        const rel = safeRelPath(p);
        if (!rel) return;
        viewerCurrentRel = rel;
        viewerMode = "image";
        viewerTitle.textContent = rel;
        resetViewerPanels();
        viewerImg.style.display = "";
        viewerImg.src = fileUrl(rel);
        viewerImg.alt = rel;
        resetViewerTransform();
      }
      async function openViewerFor(p) {
        const rel = safeRelPath(p);
        if (!rel) return;
        viewerSourceToggle.style.display = "none";
        viewerSourceToggle.onclick = null;
        viewerPaths = collectViewerPaths();
        const idx = viewerPaths.indexOf(rel);
        viewerIndex = idx >= 0 ? idx : 0;
        viewer.classList.add("show");
        history.pushState({ viewer: true }, "");
        await setViewerImage(rel);
      }
      function openMediaViewer(path, kind) {
        const rel = safeRelPath(path);
        if (!rel) return;
        viewerSourceToggle.style.display = "none";
        viewerSourceToggle.onclick = null;
        viewerCurrentRel = rel;
        viewerMode = (kind === "video") ? "video" : "audio";
        viewerTitle.textContent = rel;
        if (_viewerMdToggle) { try { _viewerMdToggle.remove(); } catch (_) {} _viewerMdToggle = null; }
        resetViewerPanels();
        resetViewerTransform();
        const src = fileUrl(rel);
        if (kind === "video") {
          viewerVideo.src = src;
          viewerVideo.style.display = "";
        } else {
          viewerAudio.src = src;
          viewerAudio.style.display = "";
        }
        viewer.classList.add("show");
        history.pushState({ viewer: true }, "");
      }
      function openHtmlViewer(path) {
        const { path: cleanPath, page } = parsePageFragment(path);
        const rel = safeRelPath(cleanPath);
        if (!rel) return;
        viewerCurrentRel = (page >= 0) ? (rel + "#page=" + page) : rel;
        viewerMode = "html";
        viewerTitle.textContent = rel;
        if (_viewerMdToggle) { try { _viewerMdToggle.remove(); } catch (_) {} _viewerMdToggle = null; }
        resetViewerPanels();
        const src = fileUrl(rel) + (page >= 0 ? ("#page=" + page) : "");
        viewerIframe.src = src;
        viewerIframe.style.display = "";
        const srcPre = document.createElement("pre");
        const srcCode = document.createElement("code");
        srcCode.className = "language-html";
        srcCode.textContent = "";
        srcPre.appendChild(srcCode);
        const srcLined = wrapWithLineNumbers(srcPre, "");
        srcLined.style.display = "none";
        viewerText.innerHTML = "";
        viewerText.appendChild(srcLined);
        viewerSourceToggle.style.display = "";
        viewerSourceToggle.innerHTML = ICON.code;
        viewerSourceToggle.title = "View source";
        viewerSourceToggle.setAttribute("aria-label", "View source");
        let sourceLoaded = false;
        let showSource = false;
        const loadSourceOnce = async () => {
          if (sourceLoaded) return;
          sourceLoaded = true;
          try {
            const res = await fetch(src);
            const txt = await res.text();
            srcCode.textContent = String(txt || "");
            try { hljs.highlightElement(srcCode); } catch (_) {}
            // Rebuild line numbers now that content is loaded.
            const nums = srcLined.querySelector(".viewer-line-nums");
            if (nums) {
              const lineCount = String(txt || "").split("\n").length;
              let s = "";
              for (let i = 1; i <= lineCount; i++) s += i + "\n";
              nums.textContent = s.trimEnd();
            }
          } catch (_) {
            srcCode.textContent = "<!-- Failed to load source -->";
          }
        };
        viewerSourceToggle.onclick = async () => {
          showSource = !showSource;
          if (showSource) {
            await loadSourceOnce();
            viewerIframe.style.display = "none";
            viewerText.style.display = "block";
            srcLined.style.display = "";
            viewerSourceToggle.innerHTML = ICON.doc;
            viewerSourceToggle.title = "View rendered";
          } else {
            viewerText.style.display = "none";
            srcLined.style.display = "none";
            viewerIframe.style.display = "";
            viewerSourceToggle.innerHTML = ICON.code;
            viewerSourceToggle.title = "View source";
          }
        };
        viewer.classList.add("show");
        history.pushState({ viewer: true }, "");
      }
      let _viewerMdToggle = null;
      let _marpKeyHandler = null;
      let _currentMarpDeck = null;
      let _currentSlideMode = false;
      let _viewerClosingFromPopstate = false;
      function closeViewer() {
        if (!viewer.classList.contains("show")) return;
        if (_marpKeyHandler) { document.removeEventListener("keydown", _marpKeyHandler); _marpKeyHandler = null; }
        viewerText.classList.remove("marp-active");
        viewer.classList.remove("marp-mode");
        viewer.classList.remove("marp-slidemode");
        if (_viewerMarpExpand) { try { _viewerMarpExpand.remove(); } catch (_) {} _viewerMarpExpand = null; }
        _currentMarpDeck = null;
        _currentSlideMode = false;
        if (_immersive) exitImmersiveMode();
        viewer.classList.remove("show");
        viewer.classList.remove("show-controls");
        viewerCurrentRel = "";
        viewerMode = "";
        viewerImg.src = "";
        viewerVideo.pause();
        viewerVideo.src = "";
        viewerAudio.pause();
        viewerAudio.src = "";
        viewerIframe.src = "about:blank";
        resetViewerPanels();
        viewerSourceToggle.style.display = "none";
        viewerSourceToggle.onclick = null;
        viewerSourceToggle.innerHTML = ICON.code;
        viewerSourceToggle.title = "View source";
        viewerText.innerHTML = "";
        if (_viewerMdToggle) { try { _viewerMdToggle.remove(); } catch (_) {} _viewerMdToggle = null; }
        viewerPaths = [];
        viewerIndex = 0;
        resetViewerTransform();
        if (!_viewerClosingFromPopstate) history.back();
      }
      async function viewerNext(dir) {
        if (!viewerPaths.length) return;
        viewerIndex = (viewerIndex + dir + viewerPaths.length) % viewerPaths.length;
        await setViewerImage(viewerPaths[viewerIndex]);
      }

      function wrapWithLineNumbers(pre, content) {
        const lineCount = content.split("\n").length;
        const nums = document.createElement("div");
        nums.className = "viewer-line-nums";
        let s = "";
        for (let i = 1; i <= lineCount; i++) s += i + "\n";
        nums.textContent = s.trimEnd();
        const wrap = document.createElement("div");
        wrap.className = "viewer-lined";
        wrap.appendChild(nums);
        wrap.appendChild(pre);
        return wrap;
      }

      function openTextViewer(path, content, ext, page) {
        if (ext === "md" && isMarpMarkdown(content)) {
          openMarpViewer(path, content, page);
          return;
        }
        const rel = safeRelPath(path);
        if (!rel) return;
        viewerSourceToggle.style.display = "none";
        viewerSourceToggle.onclick = null;
        viewerCurrentRel = rel;
        viewerMode = "text";
        viewerTitle.textContent = rel;
        resetViewerPanels();
        viewerText.style.display = "block";
        viewerText.innerHTML = "";
        if (_viewerMdToggle) { try { _viewerMdToggle.remove(); } catch (_) {} _viewerMdToggle = null; }
        if (ext === "md") {
          const mdDiv = document.createElement("div");
          mdDiv.className = "attach-md";
          mdDiv.innerHTML = renderMarkdown(content);
          viewerText.appendChild(mdDiv);
          const srcPre = document.createElement("pre");
          const srcCode = document.createElement("code");
          srcCode.className = "language-markdown";
          srcCode.textContent = content;
          srcPre.appendChild(srcCode);
          const srcLined = wrapWithLineNumbers(srcPre, content);
          srcLined.style.display = "none";
          viewerText.appendChild(srcLined);
          let srcHighlighted = false;
          let showSource = false;
          const toggleBtn = document.createElement("button");
          toggleBtn.className = "icon-btn viewer-md-toggle";
          toggleBtn.title = "View source";
          toggleBtn.setAttribute("aria-label", "View source");
          toggleBtn.innerHTML = ICON.code;
          toggleBtn.addEventListener("click", () => {
            showSource = !showSource;
            if (showSource) {
              mdDiv.style.display = "none";
              srcLined.style.display = "";
              if (!srcHighlighted) { try { hljs.highlightElement(srcCode); } catch (_) {} srcHighlighted = true; }
              toggleBtn.innerHTML = ICON.doc;
              toggleBtn.title = "View rendered";
            } else {
              mdDiv.style.display = "";
              srcLined.style.display = "none";
              toggleBtn.innerHTML = ICON.code;
              toggleBtn.title = "View source";
            }
          });
          const viewerTop = $("viewerTop");
          viewerTop.insertBefore(toggleBtn, viewerShare);
          _viewerMdToggle = toggleBtn;
        } else {
          const pre = document.createElement("pre");
          const code = document.createElement("code");
          const langMap = { py:"python", js:"javascript", ts:"typescript", kt:"kotlin", sh:"bash", yml:"yaml", rs:"rust", rb:"ruby", pl:"perl", h:"c", cpp:"cpp" };
          code.className = "language-" + (langMap[ext] || ext);
          code.textContent = content;
          pre.appendChild(code);
          viewerText.appendChild(wrapWithLineNumbers(pre, content));
          try { hljs.highlightElement(code); } catch (_) {}
        }
        viewer.classList.add("show");
        history.pushState({ viewer: true }, "");
      }

      viewerClose.addEventListener("click", closeViewer);
      viewer.addEventListener("click", (ev) => {
        const t = ev.target;
        if (t && t.closest && t.closest(".viewer-top, .icon-btn, a, button, input, textarea, select, audio, video")) return;
        const inTextContent = !!(viewerMode === "text" && t && viewerText.contains(t));
        if (!(
          t === viewer ||
          t === viewerBody ||
          t === viewerImg ||
          t === viewerText ||
          t === viewerIframe ||
          inTextContent
        )) {
          return;
        }
        if (!_immersive) {
          enterImmersiveMode();
          return;
        }
        viewer.classList.toggle("show-controls");
      });
      viewerShare.addEventListener("click", async () => {
        const rel = safeRelPath(viewerCurrentRel || viewerTitle.textContent || "");
        if (!rel) return;
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.shareUserFile) {
            AndroidBridge.shareUserFile(rel, mimeForPath(rel));
          } else {
            showToast("Share not available", 1600);
          }
        } catch (_) {
          showToast("Share failed", 1800);
        }
      });

      function dist2(a, b) {
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy);
      }
      function viewerIsImageMode() {
        return viewerImg.style.display !== "none";
      }

      viewerBody.addEventListener("touchstart", (ev) => {
        if (!viewer.classList.contains("show")) return;
        if (!viewerIsImageMode()) return;
        if (!ev.touches || ev.touches.length === 0) return;
        if (ev.touches.length === 2) {
          vTouchMode = "pinch";
          vStartDist = dist2(ev.touches[0], ev.touches[1]);
          vStartScale = vScale;
          vStartTx = vTx;
          vStartTy = vTy;
          vPinchMidX = (ev.touches[0].clientX + ev.touches[1].clientX) / 2;
          vPinchMidY = (ev.touches[0].clientY + ev.touches[1].clientY) / 2;
          const rect = viewerImg.getBoundingClientRect();
          vOriginX = rect.left - vTx;
          vOriginY = rect.top - vTy;
        } else {
          vTouchMode = (vScale > 1.02) ? "pan" : "swipe";
          vStartX = ev.touches[0].clientX;
          vStartY = ev.touches[0].clientY;
          vStartTx = vTx;
          vStartTy = vTy;
          vSwipeStartX = vStartX;
          vSwipeStartY = vStartY;
          vSwipeAt = Date.now();
        }
      }, { passive: false });

      viewerBody.addEventListener("touchmove", (ev) => {
        if (!viewer.classList.contains("show")) return;
        if (!viewerIsImageMode()) return;
        if (!ev.touches || ev.touches.length === 0) return;
        ev.preventDefault();
        if (ev.touches.length === 2) {
          vTouchMode = "pinch";
          const d = dist2(ev.touches[0], ev.touches[1]);
          const ratio = vStartDist > 0 ? (d / vStartDist) : 1.0;
          vScale = clamp(vStartScale * ratio, 1.0, 6.0);
          const curMidX = (ev.touches[0].clientX + ev.touches[1].clientX) / 2;
          const curMidY = (ev.touches[0].clientY + ev.touches[1].clientY) / 2;
          const sr = vScale / vStartScale;
          vTx = curMidX - vOriginX - (vPinchMidX - vOriginX - vStartTx) * sr;
          vTy = curMidY - vOriginY - (vPinchMidY - vOriginY - vStartTy) * sr;
          applyViewerTransform();
          return;
        }
        const x = ev.touches[0].clientX;
        const y = ev.touches[0].clientY;
        const dx = x - vStartX;
        const dy = y - vStartY;
        if (vTouchMode === "pan") {
          vTx = vStartTx + dx;
          vTy = vStartTy + dy;
          applyViewerTransform();
        } else if (vTouchMode === "swipe") {
          // Small visual feedback: translate a bit.
          vTx = dx;
          vTy = 0;
          applyViewerTransform();
        }
      }, { passive: false });

      viewerBody.addEventListener("touchend", async (ev) => {
        if (!viewer.classList.contains("show")) return;
        if (!viewerIsImageMode()) return;
        const now = Date.now();
        if (vTouchMode === "swipe") {
          const dx = vTx;
          const dt = Math.max(1, now - vSwipeAt);
          const vx = dx / dt; // px/ms
          resetViewerTransform();
          if (Math.abs(dx) > 90 || Math.abs(vx) > 0.7) {
            await viewerNext(dx < 0 ? +1 : -1);
          }
        } else if (vTouchMode === "pinch") {
          if (vScale < 1.02) resetViewerTransform();
        }
        vTouchMode = "";
      }, { passive: false });

      viewerImg.addEventListener("dblclick", (ev) => {
        ev.preventDefault();
        resetViewerTransform();
      });
      document.addEventListener("keydown", (ev) => {
        if (!viewer.classList.contains("show")) return;
        if (ev.key !== "Escape") return;
        ev.preventDefault();
        closeViewer();
      });
      window.addEventListener("popstate", () => {
        if (viewer.classList.contains("show")) {
          _viewerClosingFromPopstate = true;
          closeViewer();
          _viewerClosingFromPopstate = false;
        }
      });

      // ==============================
      // Immersive mode
      // ==============================
      let _immersive = false;

      function enterImmersiveMode() {
        _immersive = true;
        viewer.classList.add("immersive");
        viewer.classList.remove("show-controls");
        try { if (typeof AndroidBridge !== "undefined" && AndroidBridge.enterImmersiveMode) AndroidBridge.enterImmersiveMode(); } catch (_) {}
      }
      function exitImmersiveMode() {
        _immersive = false;
        viewer.classList.remove("immersive");
        viewer.classList.remove("show-controls");
        try { if (typeof AndroidBridge !== "undefined" && AndroidBridge.exitImmersiveMode) AndroidBridge.exitImmersiveMode(); } catch (_) {}
      }
      // Callback from Android (e.g. when activity exits immersive mode).
      window.onExitImmersiveMode = function() {
        if (_immersive) exitImmersiveMode();
      };

      // ==============================
      // Viewer Control API (called from Android via evalJs)
      // ==============================
      window.uiViewerOpen = async function(path) {
        const { path: cleanPath, page: fragPage } = parsePageFragment(path);
        const rel = safeRelPath(cleanPath);
        if (!rel) return;
        // Close any existing viewer first (suppress history.back since we'll push new state)
        if (viewer.classList.contains("show")) {
          _viewerClosingFromPopstate = true;
          closeViewer();
          _viewerClosingFromPopstate = false;
        }
        const ext = extOf(rel);
        const kind = kindFor(rel);
        if (kind === "image") {
          viewerPaths = [rel];
          viewerIndex = 0;
          viewer.classList.add("show");
          history.pushState({ viewer: true }, "");
          await setViewerImage(rel);
        } else if (kind === "video" || kind === "audio") {
          openMediaViewer(rel, kind);
        } else if (ext === "html" || ext === "htm") {
          openHtmlViewer(path);
        } else if (kind === "text") {
          try {
            const res = await fetch(fileUrl(rel));
            const content = await res.text();
            openTextViewer(rel, content, ext, fragPage);
          } catch (_) {}
        } else {
          // Binary / unknown — attempt to show in iframe
          openHtmlViewer(path);
        }
      };

      window.uiViewerClose = function() {
        closeViewer();
      };

      window.uiViewerImmersive = function(enabled) {
        if (!viewer.classList.contains("show")) return;
        if (enabled) enterImmersiveMode(); else exitImmersiveMode();
      };

      window.uiViewerSlideshow = function(enabled) {
        if (!viewer.classList.contains("show")) return;
        if (!_currentMarpDeck) return;
        if (enabled && !_currentSlideMode) {
          viewer.classList.add("marp-slidemode");
          _currentMarpDeck._enterPresentation();
          _currentSlideMode = true;
          if (_currentMarpDeck._marpKeyHandler) { _marpKeyHandler = _currentMarpDeck._marpKeyHandler; document.addEventListener("keydown", _marpKeyHandler); }
        } else if (!enabled && _currentSlideMode) {
          viewer.classList.remove("marp-slidemode");
          _currentMarpDeck._exitPresentation();
          _currentSlideMode = false;
          if (_marpKeyHandler) { document.removeEventListener("keydown", _marpKeyHandler); _marpKeyHandler = null; }
        }
      };

      window.uiViewerGoto = function(page) {
        if (!viewer.classList.contains("show")) return;
        if (!_currentMarpDeck || !_currentMarpDeck._show) return;
        _currentMarpDeck._show(page, true);
      };

      // Deterministic back policy for Android back gesture/button:
      // viewer -> licenses -> settings -> chat -> host handles (exit app).
      window.uiHandleBackGesture = function() {
        try {
          if (viewer.classList.contains("show")) {
            _viewerClosingFromPopstate = true;
            closeViewer();
            _viewerClosingFromPopstate = false;
            return true;
          }
          const h = String(location.hash || "").replace(/^#/, "") || "chat";
          if (h === "licenses") {
            location.hash = "settings";
            return true;
          }
          if (h === "settings") {
            location.hash = "chat";
            return true;
          }
        } catch (_) {}
        return false;
      };

      attachVideoFullscreenFix(viewerVideo);

      // ==============================
      // Chat Search
      // ==============================
      const _chatSearchBar = $("chatSearchBar");
      const _chatSearchInput = $("chatSearchInput");
      const _chatSearchCount = $("chatSearchCount");
      let _searchHits = [];
      let _searchIndex = -1;
      let _searchDebounce = 0;

      const _chatSearchBtn = $("chatSearchBtn");
      const _chatSearchClear = $("chatSearchClear");
      const _chatSearchPrev = $("chatSearchPrev");
      const _chatSearchNext = $("chatSearchNext");

      function updateSearchButtons() {
        const hasText = _chatSearchInput.value.length > 0;
        const hasHits = _searchHits.length > 0;
        _chatSearchClear.disabled = !hasText;
        _chatSearchPrev.disabled = !hasHits;
        _chatSearchNext.disabled = !hasHits;
      }

      function openChatSearch() {
        try {
          _chatSearchBar.classList.add("show");
          _chatSearchBtn.classList.add("active");
          _chatSearchInput.focus();
        } catch (_) {}
      }

      function closeChatSearch() {
        try {
          _chatSearchBar.classList.remove("show");
          _chatSearchBtn.classList.remove("active");
          _chatSearchInput.value = "";
          _chatSearchCount.textContent = "";
          clearSearchHighlights();
          updateSearchButtons();
        } catch (_) {}
      }

      function clearSearchHighlights() {
        _searchHits = [];
        _searchIndex = -1;
        const marks = document.querySelectorAll("#chatMessages mark.search-hit");
        for (let i = marks.length - 1; i >= 0; i--) {
          const m = marks[i];
          const parent = m.parentNode;
          parent.replaceChild(document.createTextNode(m.textContent), m);
          parent.normalize();
        }
      }

      function performChatSearch(query) {
        clearSearchHighlights();
        if (!query) { _chatSearchCount.textContent = ""; updateSearchButtons(); return; }
        const norm = query.normalize("NFKC").toLowerCase();
        const container = $("chatMessages");
        const walker = document.createTreeWalker(container, NodeFilter.SHOW_ALL, {
          acceptNode(n) {
            if (n.nodeType === Node.ELEMENT_NODE) {
              if (getComputedStyle(n).display === "none") return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_SKIP;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        });
        const matches = [];
        let node;
        while ((node = walker.nextNode())) {
          const text = node.textContent.normalize("NFKC").toLowerCase();
          let idx = text.indexOf(norm);
          if (idx === -1) continue;
          // Collect all match positions in this text node
          const positions = [];
          while (idx !== -1) {
            positions.push(idx);
            idx = text.indexOf(norm, idx + norm.length);
          }
          matches.push({ node, positions });
        }
        // Process matches in reverse order to preserve node positions
        for (let mi = matches.length - 1; mi >= 0; mi--) {
          const { node: textNode, positions } = matches[mi];
          const original = textNode.textContent;
          const parent = textNode.parentNode;
          const frag = document.createDocumentFragment();
          let last = 0;
          for (const pos of positions) {
            if (pos > last) frag.appendChild(document.createTextNode(original.slice(last, pos)));
            const mark = document.createElement("mark");
            mark.className = "search-hit";
            mark.textContent = original.slice(pos, pos + norm.length);
            frag.appendChild(mark);
            last = pos + norm.length;
          }
          if (last < original.length) frag.appendChild(document.createTextNode(original.slice(last)));
          parent.replaceChild(frag, textNode);
        }
        _searchHits = Array.from(document.querySelectorAll("#chatMessages mark.search-hit"));
        if (_searchHits.length > 0) {
          _searchIndex = 0;
          _searchHits[0].classList.add("current");
          _searchHits[0].scrollIntoView({ block: "center", behavior: "smooth" });
          _chatSearchCount.textContent = "1 of " + _searchHits.length;
        } else {
          _searchIndex = -1;
          _chatSearchCount.textContent = "0 of 0";
        }
        updateSearchButtons();
      }

      function jumpToSearchHit(index) {
        if (_searchHits.length === 0) return;
        if (_searchIndex >= 0 && _searchIndex < _searchHits.length) {
          _searchHits[_searchIndex].classList.remove("current");
        }
        _searchIndex = ((index % _searchHits.length) + _searchHits.length) % _searchHits.length;
        _searchHits[_searchIndex].classList.add("current");
        _searchHits[_searchIndex].scrollIntoView({ block: "center", behavior: "smooth" });
        _chatSearchCount.textContent = (_searchIndex + 1) + " of " + _searchHits.length;
      }

      function searchNext() { if (_searchHits.length) jumpToSearchHit(_searchIndex + 1); }
      function searchPrev() { if (_searchHits.length) jumpToSearchHit(_searchIndex - 1); }

      function toggleChatSearch() {
        if (_chatSearchBar.classList.contains("show")) closeChatSearch();
        else openChatSearch();
      }
      function clearChatSearchInput() {
        _chatSearchInput.value = "";
        _chatSearchCount.textContent = "";
        clearSearchHighlights();
        updateSearchButtons();
        _chatSearchInput.focus();
      }
      try { $("chatSearchBtn").addEventListener("click", toggleChatSearch); } catch (_) {}
      try { $("chatSearchClear").addEventListener("click", clearChatSearchInput); } catch (_) {}
      try { $("chatSearchPrev").addEventListener("click", searchPrev); } catch (_) {}
      try { $("chatSearchNext").addEventListener("click", searchNext); } catch (_) {}
      try {
        _chatSearchInput.addEventListener("input", () => {
          clearTimeout(_searchDebounce);
          _searchDebounce = setTimeout(() => performChatSearch(_chatSearchInput.value), 200);
        });
      } catch (_) {}
      try {
        _chatSearchInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); searchNext(); }
          else if (e.key === "Enter" && e.shiftKey) { e.preventDefault(); searchPrev(); }
          else if (e.key === "Escape") { e.preventDefault(); closeChatSearch(); }
        });
      } catch (_) {}
      try {
        document.addEventListener("keydown", (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === "f") {
            e.preventDefault();
            openChatSearch();
          }
        });
      } catch (_) {}

      // ==============================
      // Chat
      // ==============================
      const chatMessages = $("chatMessages");
      const chatInput = $("chatInput");
      const chatSend = $("chatSend");
      const chatWelcome = $("chatWelcome");
      const CHAT_STORAGE_PREFIX = "methings.chat.conversation.v1.";
      const CHAT_SESSION_KEY = "methings.chat.session_id.v1";
      const CHAT_KNOWN_SESSIONS_KEY = "methings.chat.known_sessions.v1";
      let conversation = [];
      let streaming = false;
      let chatSessionId = "";
      let lastServerTs = 0;
      let stickToBottom = true;
      // Centralized thinking indicator state.
      // .el = the DOM element (a .msg.assistant with .thinking-wrap), or null.
      const _thinking = { el: null };
      // item_id -> exact text we sent to /brain/inbox/chat (for UI-side retry fallback).
      const _sentTextByItemId = new Map();

      // --- SSE connection for real-time brain events ---
      let _brainSSE = null;
      // item_id -> { resolve } for waitForAgentReply SSE path.
      const _sseWaiters = new Map();

      function connectBrainSSE() {
        closeBrainSSE();
        if (!chatSessionId) return;
        try {
          const url = API + "/brain/events?session_id=" + encodeURIComponent(chatSessionId);
          const es = new EventSource(url);
          _brainSSE = es;
          es.onopen = function() {
            // Catch up on any messages we missed while disconnected.
            pollServerMessages();
          };
          es.addEventListener("brain_message", function(e) {
            try {
              const data = JSON.parse(e.data);
              const role = data.role || "";
              const text = (typeof data.text === "string") ? data.text.trim() : "";
              const meta = (data.meta && typeof data.meta === "object") ? data.meta : {};
              const ts = Number(data.ts || 0);
              const itemId = meta.item_id || "";
              if (!text || (role !== "user" && role !== "assistant")) return;
              // Resolve SSE waiters.
              if (role === "assistant" && itemId && _sseWaiters.has(itemId)) {
                const w = _sseWaiters.get(itemId);
                _sseWaiters.delete(itemId);
                if (w && w.resolve) w.resolve(text);
              }
              // Update lastServerTs so the slow poll doesn't re-process.
              if (ts && ts > lastServerTs) lastServerTs = ts;
              // De-dupe: if already rendered, upgrade in place.
              if (itemId) {
                const existing = findRenderedByItem(role, itemId);
                if (existing) {
                  existing.dataset.ts = String(ts || "");
                  if (meta.debug) existing.classList.add("debug");
                  if (role === "assistant" && existing.querySelector(".thinking-dots")) {
                    if (_thinking.el === existing) _thinking.el = null;
                    existing.innerHTML = renderMarkdown(text);
                    if (streaming && !activeAgentItemId) {
                      streaming = false;
                      chatSend.disabled = false;
                      setInterruptUi(false, "");
                    }
                  }
                  try { renderInlineAttachments(existing, text); } catch (_) {}
                  try { renderInlineHtmlLinks(existing, text); } catch (_) {}
                  upsertConversationEntry(role, itemId, text, meta, ts);
                  if (role === "assistant") clearWorkingByItemId(itemId);
                  return;
                }
              }
              addMsg(role, text, Object.assign({}, meta, { _ts: ts }));
              conversation.push({ role: role, content: text, meta: meta, ts: ts || Date.now() });
              if (role === "assistant" && itemId) clearWorkingByItemId(itemId);
              conversation = conversation.slice(-220);
              saveConversation();
            } catch (_) {}
          });
          es.addEventListener("brain_item_started", function(e) {
            try {
              // Show thinking indicator (unless streaming owns it).
              if (streaming) return;
              if (_thinking.el && _thinking.el.isConnected) return;
              const allAssistant = chatMessages.querySelectorAll(".msg.assistant");
              const last = allAssistant.length ? allAssistant[allAssistant.length - 1] : null;
              let hasUserAfter = false;
              if (last) {
                let sib = last.nextElementSibling;
                while (sib) {
                  if (sib.classList.contains("msg") && sib.classList.contains("user")) { hasUserAfter = true; break; }
                  sib = sib.nextElementSibling;
                }
              }
              if (last && !hasUserAfter) {
                setMsgWorking(last, true);
              } else {
                addThinkingIndicator();
              }
            } catch (_) {}
          });
          es.addEventListener("brain_idle", function(e) {
            try {
              if (streaming) return;
              if (_thinking.el && _thinking.el.isConnected) _thinking.el.remove();
              _thinking.el = null;
              chatMessages.querySelectorAll(".msg-working").forEach(el => el.remove());
            } catch (_) {}
          });
          es.addEventListener("brain_item_failed", function(e) {
            try {
              if (streaming) return;
              if (_thinking.el && _thinking.el.isConnected) _thinking.el.remove();
              _thinking.el = null;
              chatMessages.querySelectorAll(".msg-working").forEach(el => el.remove());
            } catch (_) {}
          });
          es.addEventListener("brain_item_interrupted", function(e) {
            try {
              if (streaming) return;
              if (_thinking.el && _thinking.el.isConnected) _thinking.el.remove();
              _thinking.el = null;
              chatMessages.querySelectorAll(".msg-working").forEach(el => el.remove());
            } catch (_) {}
          });
          es.addEventListener("brain_status", function(e) {
            try {
              if (streaming) return;
              const data = JSON.parse(e.data);
              const label = data.label || "";
              if (!label) return;
              // If a thinking bubble or working indicator is visible, update its label.
              // If none exists yet, create one (the status event may arrive before brain_item_started).
              if (_thinking.el && _thinking.el.isConnected) {
                updateThinkingLabel(label);
              } else {
                var workingEls = chatMessages.querySelectorAll(".msg-working .thinking-label");
                if (workingEls.length) {
                  for (var i = 0; i < workingEls.length; i++) workingEls[i].textContent = label;
                } else {
                  addThinkingIndicator(label);
                }
              }
            } catch (_) {}
          });
          es.onerror = function() {
            // EventSource auto-reconnects; no extra logic needed.
          };
        } catch (_) {}
      }

      function closeBrainSSE() {
        if (_brainSSE) {
          try { _brainSSE.close(); } catch (_) {}
          _brainSSE = null;
        }
      }

      function genSessionId() {
        return "s_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 10);
      }

      function loadKnownSessions() {
        try {
          const raw = localStorage.getItem(CHAT_KNOWN_SESSIONS_KEY);
          if (raw) return JSON.parse(raw);
        } catch (_) {}
        return [];
      }
      function saveKnownSession(sid) {
        const list = loadKnownSessions();
        if (!list.includes(sid)) { list.push(sid); }
        try { localStorage.setItem(CHAT_KNOWN_SESSIONS_KEY, JSON.stringify(list)); } catch (_) {}
      }
      function removeKnownSession(sid) {
        const list = loadKnownSessions().filter(s => s !== sid);
        try { localStorage.setItem(CHAT_KNOWN_SESSIONS_KEY, JSON.stringify(list)); } catch (_) {}
      }
      function isSessionIdTaken(sid) {
        if (sid === "default" || sid === String(chatSessionId || "").trim()) return true;
        if (loadKnownSessions().includes(sid)) return true;
        return !!(sessionList && sessionList.querySelector("[data-sid='" + sid.replace(/'/g, "\\'") + "']"));
      }

      function loadSessionId() {
        try {
          const existing = localStorage.getItem(CHAT_SESSION_KEY);
          if (existing && typeof existing === "string" && existing.trim()) return existing.trim();
        } catch (_) {}
        const created = "default";
        try { localStorage.setItem(CHAT_SESSION_KEY, created); } catch (_) {}
        return created;
      }
      chatSessionId = loadSessionId();
      setSessionChipText();

      async function switchChatSession(newId) {
        const sid = String(newId || "").trim();
        if (!sid) return;
        if (streaming) { showToast("Wait for reply before switching", 1400); return; }
        if (sid === chatSessionId) return;
        chatSessionId = sid;
        try { localStorage.setItem(CHAT_SESSION_KEY, sid); } catch (_) {}
        setSessionChipText();
        conversation = [];
        lastServerTs = 0;
        try { chatMessages.textContent = ""; } catch (_) {}
        _permState.knownIds.clear(); _permState.cardEl = null; _permState.items = {};
        restoreConversation();
        connectBrainSSE();
        await syncConversationFromServer();
      }

      function convoStorageKey() {
        return CHAT_STORAGE_PREFIX + chatSessionId;
      }

      function saveConversation() {
        try {
          localStorage.setItem(convoStorageKey(), JSON.stringify(conversation));
        } catch (_) {}
      }

      function restoreConversation() {
        try {
          const raw = localStorage.getItem(convoStorageKey());
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return;
          // Keep meta/ts so we can de-dupe/upgrade by item_id after rotation.
          conversation = parsed.filter(m =>
            m && (m.role === "user" || m.role === "assistant") && typeof m.content === "string"
          ).map(m => ({
            role: m.role,
            content: m.content,
            meta: (m.meta && typeof m.meta === "object") ? m.meta : {},
            ts: Number(m.ts || 0) || 0,
          }));
          for (const msg of conversation) {
            addMsg(msg.role, msg.content, Object.assign({}, msg.meta || {}, { _ts: msg.ts || 0 }));
          }
        } catch (_) {}
      }

      window.uiClearChatCache = async function(opts) {
        const keepSid = String((opts && opts.preserve_session_id) || "").trim();
        const quiet = !!(opts && opts.quiet);
        const keepConvoKey = keepSid ? (CHAT_STORAGE_PREFIX + keepSid) : "";
        try {
          const toDelete = [];
          for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i) || "";
            if (!k.startsWith(CHAT_STORAGE_PREFIX)) continue;
            if (keepConvoKey && k === keepConvoKey) continue;
            toDelete.push(k);
          }
          for (const k of toDelete) {
            try { localStorage.removeItem(k); } catch (_) {}
          }
          if (keepSid) {
            try { localStorage.setItem(CHAT_KNOWN_SESSIONS_KEY, JSON.stringify([keepSid])); } catch (_) {}
            try { localStorage.setItem(CHAT_SESSION_KEY, keepSid); } catch (_) {}
          } else {
            try { localStorage.removeItem(CHAT_KNOWN_SESSIONS_KEY); } catch (_) {}
            try { localStorage.setItem(CHAT_SESSION_KEY, "default"); } catch (_) {}
          }
        } catch (_) {}
        const targetSid = keepSid || "default";
        if (quiet) {
          try {
            chatSessionId = targetSid;
            setSessionChipText();
          } catch (_) {}
          return;
        }
        try {
          if (String(chatSessionId || "").trim() === targetSid) {
            try { localStorage.setItem(CHAT_SESSION_KEY, targetSid); } catch (_) {}
            setSessionChipText();
            conversation = [];
            lastServerTs = 0;
            try { chatMessages.textContent = ""; } catch (_) {}
            _permState.knownIds.clear(); _permState.cardEl = null; _permState.items = {};
            restoreConversation();
            connectBrainSSE();
            await syncConversationFromServer();
          } else {
            await switchChatSession(targetSid);
          }
        } catch (_) {}
      };

      function isNearBottom(el, slackPx) {
        try {
          const slack = typeof slackPx === "number" ? slackPx : 120;
          return (el.scrollHeight - el.scrollTop - el.clientHeight) <= slack;
        } catch (_) {
          return true;
        }
      }

      function scrollToBottomSoon() {
        if (!chatMessages) return;
        requestAnimationFrame(() => {
          try { chatMessages.scrollTop = chatMessages.scrollHeight; } catch (_) {}
        });
      }

      chatMessages.addEventListener("scroll", () => {
        stickToBottom = isNearBottom(chatMessages, 140);
      }, { passive: true });

      function addMsg(role, content, meta) {
        if (chatWelcome.parentNode) chatWelcome.remove();
        // Remove stale Retry buttons from older error messages.
        if (role === "assistant" || role === "user") {
          chatMessages.querySelectorAll("[data-ui='retry-actions']").forEach(el => el.remove());
        }
        const shouldScroll = isNearBottom(chatMessages, 140);
        const div = document.createElement("div");
        const m = (meta && typeof meta === "object") ? meta : {};
        const isDebug = !!(m.debug);
        const actorRaw = (m.actor && typeof m.actor === "string") ? m.actor : "";
        const actor = actorRaw.trim().toLowerCase();
        const actorClass = actor ? (" actor-" + actor.replace(/[^a-z0-9_-]/g, "")) : "";
        div.className = "msg " + role + (isDebug ? " debug" : "") + actorClass;
        if (m.item_id) div.dataset.itemId = String(m.item_id);
        if (m.session_id) div.dataset.sessionId = String(m.session_id);
        if (m.debug) div.dataset.debug = "1";
        if (actor) div.dataset.actor = actor;
        if (meta && meta._ts) div.dataset.ts = String(meta._ts);
        if (role === "assistant" || role === "user") {
          div.innerHTML = renderMarkdown(content);
          // Attachments should render for both user and assistant messages.
          try { renderInlineAttachments(div, content); } catch (_) {}
          try { renderInlineHtmlLinks(div, content); } catch (_) {}
          // Retry affordance for agent failures.
          try {
            const err = m && m.error ? String(m.error) : "";
            const itemId = m && m.item_id ? String(m.item_id) : "";
            const isAgentFailure = role === "assistant" && !!itemId && (err === "brain_item_failed" || /^Error:/i.test(String(content || "").trim()));
            if (isAgentFailure) {
              const actions = document.createElement("div");
              actions.dataset.ui = "retry-actions";
              actions.style.display = "flex";
              actions.style.gap = "8px";
              actions.style.marginTop = "10px";
              const btn = document.createElement("button");
              btn.className = "btn";
              btn.textContent = "Retry";
              btn.addEventListener("click", () => retryAgentItem(itemId));
              actions.appendChild(btn);
              div.appendChild(actions);
            }
          } catch (_) {}
        } else {
          div.textContent = content;
        }
        chatAppend(div);
        if (shouldScroll || isDebug || stickToBottom) scrollToBottomSoon();
        return div;
      }

      function attachAgentFailureActions(div, itemId) {
        try {
          if (!div || !itemId) return;
          if (div.querySelector("[data-ui='retry-actions']")) return;
          const actions = document.createElement("div");
          actions.dataset.ui = "retry-actions";
          actions.style.display = "flex";
          actions.style.gap = "8px";
          actions.style.marginTop = "10px";
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = "Retry";
          btn.addEventListener("click", () => retryAgentItem(String(itemId)));
          actions.appendChild(btn);
          div.appendChild(actions);
        } catch (_) {}
      }

      function setMsgWorking(div, working, label) {
        if (!div) return;
        const existing = div.querySelector(".msg-working");
        if (!working) {
          if (existing) existing.remove();
          return;
        }
        // If this bubble is already the dedicated thinking placeholder (has dots),
        // don't add a second set of dots — but update label if provided.
        if (div.querySelector(".thinking-dots")) {
          if (label) updateThinkingLabel(label);
          return;
        }
        if (existing) {
          if (label) {
            var lbl = existing.querySelector(".thinking-label");
            if (lbl) lbl.textContent = label;
          }
          return;
        }
        const shouldScroll = isNearBottom(chatMessages, 140) || stickToBottom;
        const w = document.createElement("div");
        w.className = "msg-working";
        w.innerHTML = '<div class="thinking-dots mini"><span></span><span></span><span></span></div><span class="thinking-label">' + (label ? escapeHtml(label) : '') + '</span>';
        div.appendChild(w);
        if (shouldScroll) scrollToBottomSoon();
      }

      function markWorkingByItemId(itemId) {
        if (!itemId) return;
        const div = findRenderedByItem("assistant", itemId);
        if (div) setMsgWorking(div, true);
      }

      function clearWorkingByItemId(itemId) {
        if (!itemId) return;
        const div = findRenderedByItem("assistant", itemId);
        if (div) setMsgWorking(div, false);
      }

      function upsertConversationEntry(role, itemId, text, meta, ts) {
        if (!itemId) return;
        const rid = String(itemId);
        for (let i = conversation.length - 1; i >= 0; i--) {
          const m = conversation[i];
          const mi = m && m.meta ? (m.meta.item_id || m.meta.itemId || "") : "";
          if (m && m.role === role && String(mi) === rid) {
            m.content = text;
            m.meta = Object.assign({}, m.meta || {}, meta || {});
            if (ts) m.ts = ts;
            return;
          }
        }
        conversation.push({ role, content: text, meta: meta || {}, ts: ts || Date.now() });
      }

      function addThinkingIndicator(label) {
        // If a valid thinking bubble already exists, reuse it.
        if (_thinking.el && _thinking.el.isConnected &&
            _thinking.el.querySelector(".thinking-wrap .thinking-dots:not(.mini)")) {
          if (label) updateThinkingLabel(label);
          return _thinking.el;
        }
        if (chatWelcome.parentNode) chatWelcome.remove();
        const shouldScroll = isNearBottom(chatMessages, 140);
        const div = document.createElement("div");
        div.className = "msg assistant";
        div.innerHTML = '<div class="thinking-wrap"><div class="thinking-dots"><span></span><span></span><span></span></div><span class="thinking-label">' + (label ? escapeHtml(label) : '') + '</span></div>';
        chatAppend(div);
        if (shouldScroll || stickToBottom) scrollToBottomSoon();
        _thinking.el = div;
        return div;
      }

      function updateThinkingLabel(text) {
        // Update the status label on any visible thinking/working indicator.
        var labels = chatMessages.querySelectorAll(".thinking-label");
        for (var i = 0; i < labels.length; i++) labels[i].textContent = text || "";
        // Also update the dedicated thinking bubble if it exists.
        if (_thinking.el && _thinking.el.isConnected) {
          var lbl = _thinking.el.querySelector(".thinking-label");
          if (lbl) lbl.textContent = text || "";
        }
      }

      async function syncConversationFromServer() {
        try {
          const res = await fetch(API + "/brain/messages?limit=300&session_id=" + encodeURIComponent(chatSessionId));
          if (!res.ok) return;
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          const rebuilt = [];
          let maxTs = 0;
          // Track tool activity to restore working indicators after rotation.
          const lastToolTsByItem = new Map();
          const lastAssistantTsByItem = new Map();
          for (const msg of list) {
            if (!msg) continue;
            const role = msg.role;
            if (typeof msg.text !== "string" || !msg.text.trim()) continue;
            maxTs = Math.max(maxTs, Number(msg.ts || 0));
            const meta = (msg.meta && typeof msg.meta === "object") ? msg.meta : {};
            const itemId = meta.item_id || meta.itemId || "";
            const ts = Number(msg.ts || 0) || 0;
            if (role === "tool" && itemId) {
              const cur = Number(lastToolTsByItem.get(itemId) || 0);
              if (ts > cur) lastToolTsByItem.set(itemId, ts);
              continue;
            }
            if (role === "assistant" && itemId) {
              const cur = Number(lastAssistantTsByItem.get(itemId) || 0);
              if (ts > cur) lastAssistantTsByItem.set(itemId, ts);
            }
            if (role !== "user" && role !== "assistant") continue;
            rebuilt.push({ role: role, content: msg.text, meta: meta, ts: ts });
          }
          if (!rebuilt.length) return;
          lastServerTs = Math.max(lastServerTs, maxTs);
          conversation = rebuilt.slice(-200).map(m => ({ role: m.role, content: m.content, meta: m.meta || {}, ts: m.ts || 0 }));
          chatMessages.textContent = "";
          // Reset perm-card and thinking state so they re-create after rebuild.
          _permState.cardEl = null; _permState.items = {}; _permState.knownIds.clear();
          _thinking.el = null;
          for (const msg of conversation) addMsg(msg.role, msg.content, Object.assign({}, msg.meta || {}, { _ts: msg.ts || 0 }));
          // Restore working indicators for items that have tool activity after the last assistant bubble.
          for (const [itemId, tTs] of lastToolTsByItem.entries()) {
            const aTs = Number(lastAssistantTsByItem.get(itemId) || 0);
            if (tTs > aTs) markWorkingByItemId(itemId);
          }
          saveConversation();
          // Immediately re-render any pending permission cards.
          pollPendingPermissions();
        } catch (_) {}
      }

      function findRenderedByItem(role, itemId) {
        if (!itemId) return null;
        try {
          const esc = (typeof CSS !== "undefined" && CSS.escape) ? CSS.escape : (s) => String(s).replace(/"/g, '\\"');
          // There can be multiple bubbles with the same item_id (e.g., permission required + approved).
          // Always target the most recent one so "working" dots attach to the right bubble.
          const nodes = chatMessages.querySelectorAll('.msg.' + role + '[data-item-id="' + esc(String(itemId)) + '"]');
          return (nodes && nodes.length) ? nodes[nodes.length - 1] : null;
        } catch (_) {
          return null;
        }
      }

      function isSessionBusy(st, sid) {
        if (!st || !st.busy) return false;
        const cur = String(st.current_session_id || "").trim();
        if (cur) return cur === String(sid || "").trim();
        const queued = Array.isArray(st.queued_session_ids)
          ? st.queued_session_ids.map(x => String(x || "").trim()).filter(Boolean)
          : [];
        if (queued.length) return queued.includes(String(sid || "").trim());
        return false;
      }

      async function pollServerMessages() {
        // Keep chat UI updated even when messages are injected by the system (e.g., debug comments).
        if (!chatSessionId) return;
        try {
          const res = await fetch(API + "/brain/messages?limit=200&session_id=" + encodeURIComponent(chatSessionId));
          if (!res.ok) return;
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          let maxTs = lastServerTs;
          for (const msg of list) {
            if (!msg) continue;
            const text = (typeof msg.text === "string") ? msg.text.trim() : "";
            if (!text) continue;
            const ts = Number(msg.ts || 0);
            const meta = (msg && msg.meta && typeof msg.meta === "object") ? msg.meta : {};
            maxTs = Math.max(maxTs, ts);
            if (ts && ts <= lastServerTs) continue;

            // De-dupe: if we already rendered this item_id bubble locally, upgrade it instead of appending.
            const itemId = meta.item_id || "";
            if (msg.role === "tool") {
              // Tool messages are not rendered, but they indicate the agent is actively working.
              if (itemId) markWorkingByItemId(itemId);
              continue;
            }
            if (msg.role !== "user" && msg.role !== "assistant") continue;
            if (itemId) {
              const existing = findRenderedByItem(msg.role, itemId);
              if (existing) {
                existing.dataset.ts = String(ts || "");
                if (meta.debug) existing.classList.add("debug");
                if (msg.role === "assistant" && existing.querySelector(".thinking-dots")) {
                  if (_thinking.el === existing) _thinking.el = null;
                  existing.innerHTML = renderMarkdown(text);
                  // Clean up recovered-streaming state if applicable.
                  if (streaming && !activeAgentItemId) {
                    streaming = false;
                    chatSend.disabled = false;
                    setInterruptUi(false, "");
                  }
                }
                // Always refresh attachments and persist upgraded content for rotation recovery.
                try { renderInlineAttachments(existing, text); } catch (_) {}
                try { renderInlineHtmlLinks(existing, text); } catch (_) {}
                upsertConversationEntry(msg.role, itemId, text, meta, ts);
                if (msg.role === "assistant") clearWorkingByItemId(itemId);
                // Permission resume events: show working indicator for the resumed item id.
                try {
                  const rid = (meta && (meta.resume_item_id || meta.resumeItemId)) ? String(meta.resume_item_id || meta.resumeItemId) : "";
                  if (rid) markWorkingByItemId(rid);
                } catch (_) {}
                continue;
              }
            }

            addMsg(msg.role, text, Object.assign({}, meta, { _ts: ts }));
            conversation.push({ role: msg.role, content: text, meta: meta, ts: ts });
            if (msg.role === "assistant" && itemId) clearWorkingByItemId(itemId);
            try {
              const rid = (meta && (meta.resume_item_id || meta.resumeItemId)) ? String(meta.resume_item_id || meta.resumeItemId) : "";
              if (rid) markWorkingByItemId(rid);
            } catch (_) {}
          }
          if (maxTs > lastServerTs) {
            lastServerTs = maxTs;
            conversation = conversation.slice(-220);
            saveConversation();
          }
        } catch (_) {}
        // Check brain busy status to show/hide working indicator.
        try {
          const sr = await fetch(API + "/brain/status");
          if (sr.ok) {
            const st = await sr.json();
            if (isSessionBusy(st, chatSessionId)) {
              // Agent is still working — ensure there's a visible indicator.
              // Self-heal: if tracked element was detached, clear reference.
              if (_thinking.el && !_thinking.el.isConnected) _thinking.el = null;
              const thinkingMsg = _thinking.el;
              const hasWorking = chatMessages.querySelector(".msg.assistant .msg-working");
              // If thinking dots got displaced (messages appended after them), move to bottom.
              if (thinkingMsg) {
                let sib = thinkingMsg.nextElementSibling;
                while (sib) {
                  if (sib.classList.contains("msg")) { chatAppend(thinkingMsg); scrollToBottomSoon(); break; }
                  sib = sib.nextElementSibling;
                }
              }
              if (!thinkingMsg && !hasWorking && !streaming) {
                // Find the last assistant bubble and check if a user message follows it.
                const allAssistant = chatMessages.querySelectorAll(".msg.assistant");
                const last = allAssistant.length ? allAssistant[allAssistant.length - 1] : null;
                let hasUserAfter = false;
                if (last) {
                  let sib = last.nextElementSibling;
                  while (sib) {
                    if (sib.classList.contains("msg") && sib.classList.contains("user")) { hasUserAfter = true; break; }
                    sib = sib.nextElementSibling;
                  }
                }
                if (last && !hasUserAfter) {
                  setMsgWorking(last, true);
                } else {
                  // User sent a message after the last reply — add a new thinking bubble.
                  addThinkingIndicator();
                }
              }
            } else {
              // Agent is idle — clean up any lingering indicators.
              // But if sendAgentChat owns the lifecycle (streaming), don't touch it.
              if (streaming && !activeAgentItemId) {
                streaming = false;
                chatSend.disabled = false;
                setInterruptUi(false, "");
              }
              if (!streaming) {
                // Remove leftover thinking bubble if present.
                if (_thinking.el && _thinking.el.isConnected) _thinking.el.remove();
                _thinking.el = null;
                // Remove lingering mini-dots.
                chatMessages.querySelectorAll(".msg-working").forEach(el => el.remove());
              }
            }
          }
        } catch (_) {}
      }

      function autoResize() {
        chatInput.style.height = "auto";
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + "px";
      }
      chatInput.addEventListener("input", autoResize);
      chatInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
      });
      chatSend.addEventListener("click", sendChat);
      restoreConversation();
      syncConversationFromServer().then(() => { checkAgentBusy(); connectBrainSSE(); });
      setInterval(pollServerMessages, 20000);

      // Scope "Select All" to the message balloon where the selection started.
      (function initMsgSelectAll() {
        let originMsg = null;
        document.addEventListener("selectstart", () => {
          const sel = window.getSelection();
          const node = sel && sel.anchorNode;
          originMsg = node ? node.nodeType === 1 ? node.closest(".msg") : node.parentElement && node.parentElement.closest(".msg") : null;
        });
        let cooldown = 0;
        document.addEventListener("selectionchange", () => {
          if (Date.now() < cooldown) return;
          if (!originMsg || !originMsg.isConnected) { originMsg = null; return; }
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0 || sel.isCollapsed) { originMsg = null; return; }
          const range = sel.getRangeAt(0);
          // Still within the same balloon — no action needed.
          if (originMsg.contains(range.startContainer) && originMsg.contains(range.endContainer)) return;
          // Re-scope selection to the origin balloon (one-shot).
          const target = originMsg;
          originMsg = null;
          cooldown = Date.now() + 300;
          try {
            const r = document.createRange();
            r.selectNodeContents(target);
            sel.removeAllRanges();
            sel.addRange(r);
          } catch (_) {}
        });
      })();

      // Tap outside a balloon to dismiss selection.
      chatMessages.addEventListener("click", (e) => {
        const sel = window.getSelection();
        if (!sel || sel.isCollapsed) return;
        if (e.target.closest(".msg")) return;
        sel.removeAllRanges();
      });

      async function checkAgentBusy() {
        try {
          const res = await fetch(API + "/brain/status");
          if (!res.ok) return;
          const st = await res.json();
          if (!isSessionBusy(st, chatSessionId)) return;
          // Agent is still processing — show thinking indicator with stop button.
          if (_thinking.el && _thinking.el.isConnected) return;
          streaming = true;
          chatSend.disabled = true;
          addThinkingIndicator();
          setInterruptUi(true, "");
        } catch (_) {}
      }

      // ==============================
      // Permission cards (inline in chat)
      // ==============================
      const BIOMETRIC_TOOLS = new Set(["credentials", "ssh_keys", "ssh_pin"]);
      const _permState = { knownIds: new Set(), cardEl: null, items: {} };

      /** Append el to chatMessages, but keep active perm-card pinned at the bottom. */
      function chatAppend(el) {
        const card = _permState.cardEl;
        if (card && card.isConnected && !card.classList.contains("resolved")) {
          chatMessages.insertBefore(el, card);
        } else {
          chatMessages.appendChild(el);
        }
      }

      function renderPermCard(pending) {
        const shouldScroll = isNearBottom(chatMessages, 140);
        if (chatWelcome.parentNode) chatWelcome.remove();
        // If the current card is fully resolved, seal it and start a fresh one.
        if (_permState.cardEl && _permState.cardEl.classList.contains("resolved")) {
          _permState.cardEl = null;
          _permState.items = {};
        }
        if (!_permState.cardEl) {
          const card = document.createElement("div");
          card.className = "perm-card";
          card.innerHTML =
            "<div class='perm-card-title'>Permission required</div>" +
            "<div class='perm-card-list' id='permCardList'></div>" +
            "<div class='perm-card-footer' id='permCardFooter'></div>";
          chatMessages.appendChild(card);
          _permState.cardEl = card;
        }
        _permState.cardEl.classList.remove("resolved");
        const list = _permState.cardEl.querySelector("#permCardList");
        const footer = _permState.cardEl.querySelector("#permCardFooter");
        for (const p of pending) {
          if (_permState.items[p.id]) continue;
          const isBio = BIOMETRIC_TOOLS.has(p.tool);
          const row = document.createElement("div");
          row.className = "perm-item";
          row.dataset.pid = p.id;
          row.innerHTML =
            "<div class='perm-item-info'>" +
              "<div class='perm-item-tool'>" + (p.tool || "").replace(/</g, "&lt;") + "</div>" +
              "<div class='perm-item-detail'>" + (p.detail || "").replace(/</g, "&lt;") + "</div>" +
            "</div>" +
            (isBio
              ? "<div style='font-size:11px; color:var(--ink-muted); white-space:nowrap;'>device auth</div>"
              : "<div class='perm-item-actions'>" +
                  "<button class='btn' data-action='deny' data-pid='" + p.id + "'>Deny</button>" +
                  "<button class='btn primary' data-action='approve' data-pid='" + p.id + "'>Allow</button>" +
                "</div>");
          list.appendChild(row);
          _permState.items[p.id] = { el: row, status: "pending" };
          _permState.knownIds.add(p.id);
        }
        // Wire individual buttons.
        for (const btn of list.querySelectorAll("button[data-pid]")) {
          if (btn._wired) continue;
          btn._wired = true;
          btn.addEventListener("click", () => postPermAction(btn.dataset.pid, btn.dataset.action));
        }
        // Approve All footer.
        const pendingCount = pending.filter(p => !BIOMETRIC_TOOLS.has(p.tool)).length;
        if (pendingCount > 1) {
          footer.innerHTML = "<button class='btn primary' id='permApproveAll'>Approve All</button>";
          const allBtn = $("permApproveAll");
          if (allBtn) allBtn.addEventListener("click", () => {
            for (const p of pending) {
              if (!BIOMETRIC_TOOLS.has(p.tool) && _permState.items[p.id] && _permState.items[p.id].status === "pending") {
                postPermAction(p.id, "approve");
              }
            }
          });
        } else {
          footer.innerHTML = "";
        }
        if (shouldScroll || stickToBottom) scrollToBottomSoon();
      }

      function updatePermItemStatus(pid, status) {
        const entry = _permState.items[pid];
        if (!entry || entry.status !== "pending") return;
        entry.status = status;
        entry.el.className = "perm-item " + status;
        const actions = entry.el.querySelector(".perm-item-actions");
        if (actions) actions.innerHTML = "<span style='font-size:11px; font-weight:600; color:var(" + (status === "approved" ? "--green" : "--red") + ");'>" + (status === "approved" ? "Allowed" : "Denied") + "</span>";
        // Check if all resolved.
        const allResolved = Object.values(_permState.items).every(e => e.status !== "pending");
        if (allResolved && _permState.cardEl) {
          _permState.cardEl.classList.add("resolved");
          const footer = _permState.cardEl.querySelector("#permCardFooter");
          if (footer) footer.innerHTML = "";
        }
        syncPermOverlay();
      }

      async function postPermAction(pid, action) {
        try {
          await fetch(API + "/permissions/" + pid + "/" + action, {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: "{}",
          });
          updatePermItemStatus(pid, action === "approve" ? "approved" : "denied");
        } catch (_) {
          showToast("Failed to " + action, 1500);
        }
      }

      async function pollPendingPermissions() {
        try {
          const res = await fetch(API + "/permissions/pending");
          if (!res.ok) return;
          const data = await res.json();
          const pending = Array.isArray(data) ? data : Array.isArray(data.items) ? data.items : [];
          // Check for resolved permissions we're tracking.
          for (const [pid, entry] of Object.entries(_permState.items)) {
            if (entry.status === "pending" && !pending.find(p => p.id === pid)) {
              // Was pending, now gone — resolved externally (notification, etc.)
              updatePermItemStatus(pid, "approved");
            }
          }
          // If card was detached from DOM (e.g., chat re-render), reset state so it re-creates.
          if (_permState.cardEl && !_permState.cardEl.isConnected) {
            _permState.cardEl = null;
            _permState.items = {};
            _permState.knownIds.clear();
          }
          // Keep active perm-card pinned at the bottom (messages may have been appended after it).
          if (_permState.cardEl && _permState.cardEl.isConnected &&
              !_permState.cardEl.classList.contains("resolved") &&
              _permState.cardEl !== chatMessages.lastElementChild) {
            chatMessages.appendChild(_permState.cardEl);
          }
          // Filter to truly new pending items.
          const newPending = pending.filter(p => !_permState.knownIds.has(p.id));
          if (newPending.length > 0) renderPermCard(newPending);
          syncPermOverlay();
        } catch (_) {}
      }

      function syncPermOverlay() {
        const overlay = $("permOverlay");
        if (!overlay) return;
        const viewerOpen = viewer.classList.contains("show");
        const pendingItems = Object.entries(_permState.items).filter(([, e]) => e.status === "pending");
        if (!viewerOpen || pendingItems.length === 0) {
          overlay.classList.remove("show");
          overlay.innerHTML = "";
          return;
        }
        // Rebuild overlay content from pending items.
        let html = "<div class='perm-card-title'>Permission required</div><div class='perm-card-list'>";
        for (const [pid, entry] of pendingItems) {
          const toolEl = entry.el.querySelector(".perm-item-tool");
          const detailEl = entry.el.querySelector(".perm-item-detail");
          const tool = toolEl ? toolEl.textContent : "";
          const detail = detailEl ? detailEl.textContent : "";
          const isBio = entry.el.querySelector("[data-action]") === null;
          html += "<div class='perm-item' data-pid='" + pid + "'>" +
            "<div class='perm-item-info'>" +
              "<div class='perm-item-tool'>" + tool.replace(/</g, "&lt;") + "</div>" +
              "<div class='perm-item-detail'>" + detail.replace(/</g, "&lt;") + "</div>" +
            "</div>" +
            (isBio
              ? "<div style='font-size:11px; color:var(--ink-muted); white-space:nowrap;'>device auth</div>"
              : "<div class='perm-item-actions'>" +
                  "<button class='btn' data-action='deny' data-pid='" + pid + "'>Deny</button>" +
                  "<button class='btn primary' data-action='approve' data-pid='" + pid + "'>Allow</button>" +
                "</div>") +
            "</div>";
        }
        html += "</div>";
        const nonBioCount = pendingItems.filter(([, e]) => e.el.querySelector("[data-action]") !== null).length;
        if (nonBioCount > 1) {
          html += "<div class='perm-card-footer'><button class='btn primary' id='permOverlayApproveAll'>Approve All</button></div>";
        }
        overlay.innerHTML = html;
        overlay.classList.add("show");
        // Wire overlay buttons.
        for (const btn of overlay.querySelectorAll("button[data-pid]")) {
          btn.addEventListener("click", () => postPermAction(btn.dataset.pid, btn.dataset.action));
        }
        const allBtn = $("permOverlayApproveAll");
        if (allBtn) allBtn.addEventListener("click", () => {
          for (const [pid, entry] of pendingItems) {
            if (entry.el.querySelector("[data-action]") !== null && entry.status === "pending") {
              postPermAction(pid, "approve");
            }
          }
        });
      }

      setInterval(pollPendingPermissions, 1200);

      // Session menu handlers.
      try { sessionChip.addEventListener("click", openSessionModal); } catch (_) {}
      try { $("sessionClose").addEventListener("click", closeSessionModal); } catch (_) {}
      try {
        sessionModal.addEventListener("click", (e) => {
          if (e && e.target === sessionModal) closeSessionModal();
        });
      } catch (_) {}
      try { $("sessionRefresh").addEventListener("click", refreshSessionMenu); } catch (_) {}
      try {
        $("sessionNew").addEventListener("click", async () => {
          let prev = "";
          while (true) {
            const name = String(await appPrompt("New session", "Session name (optional)", prev) || "").trim();
            if (!name && !prev) { /* first attempt, user left blank → auto-generate */ }
            else if (!name) return; /* cancelled after retry */
            const sid = name || genSessionId();
            if (name && isSessionIdTaken(sid)) {
              await appConfirm("Name taken", "Session '" + sid + "' already exists. Please choose a different name.", { cancel: "Cancel", ok: "Retry", okClass: "primary" })
                ? (prev = name, undefined) : undefined;
              if (!prev) return;
              continue;
            }
            saveKnownSession(sid);
            await switchChatSession(sid);
            await refreshSessionMenu();
            showToast("Session created", 900);
            break;
          }
        });
      } catch (_) {}
      // Session delete is now handled per-item inside refreshSessionMenu().
      // Interrupt current agent work (best-effort).
      // Stop button is injected directly into the thinking bubble.
      let activeAgentItemId = "";
      let activeThinkingDiv = null;

      function setInterruptUi(show, itemId) {
        activeAgentItemId = String(itemId || "");
        if (!show) {
          // Remove any existing stop button.
          if (activeThinkingDiv) {
            const btn = activeThinkingDiv.querySelector(".thinking-stop");
            if (btn) btn.remove();
          }
          activeThinkingDiv = null;
          return;
        }
        // Find the current thinking bubble via tracked state, fallback to DOM query.
        const wrap = (_thinking.el && _thinking.el.isConnected)
          ? _thinking.el.querySelector(".thinking-wrap")
          : (function() { const all = chatMessages.querySelectorAll(".msg.assistant .thinking-wrap"); return all.length ? all[all.length - 1] : null; })();
        if (!wrap) return;
        activeThinkingDiv = wrap.closest(".msg");
        // Don't add duplicate.
        if (wrap.querySelector(".thinking-stop")) return;
        const btn = document.createElement("button");
        btn.className = "thinking-stop";
        btn.title = "Stop";
        btn.setAttribute("aria-label", "Stop");
        btn.innerHTML = ICON.close;
        btn.addEventListener("click", async () => {
          if (!activeAgentItemId) return;
          btn.disabled = true;
          btn.style.opacity = "0.4";
          try {
            await fetch(API + "/brain/interrupt", {
              method: "POST",
              headers: { "Content-Type": "application/json; charset=utf-8" },
              body: JSON.stringify({ item_id: activeAgentItemId, session_id: chatSessionId }),
            });
            showToast("Interrupt sent", 900);
          } catch (_) {
            showToast("Interrupt failed", 1200);
            btn.disabled = false;
            btn.style.opacity = "";
          }
        });
        wrap.appendChild(btn);
      }

      async function sendChat() {
        if (streaming) return;
        const text = chatInput.value.trim();
        const hasAtt = pendingAttachments.length > 0;
        if (!text && !hasAtt) return;
        const settingsPrefix = (!hasAtt && /^\s*settings\s*:/i.test(text))
          ? normalizeSettingsSectionToken(text.replace(/^\s*settings\s*:/i, ""))
          : "";
        if (settingsPrefix) {
          chatInput.value = "";
          autoResize();
          if (openSettingsSection(settingsPrefix)) {
            showToast("Opened settings: " + settingsPrefix, 1300);
          } else {
            showToast("Unknown settings section: " + settingsPrefix, 2200);
          }
          return;
        }
        stickToBottom = true;

        // Render a local echo immediately with file chips info; actual upload happens before agent call.
        chatInput.value = "";
        autoResize();

        const previewLines = [];
        if (text) previewLines.push(text);
        for (const a of pendingAttachments) {
          previewLines.push("`" + a.name + "`");
        }
        const previewText = previewLines.join("\n");

        conversation.push({ role: "user", content: previewText, meta: { local_echo: true }, ts: Date.now() });
        saveConversation();
        const uDiv = addMsg("user", previewText, { local_echo: true, uploading: hasAtt });

        // Upload attachments (if any) then send a final message with rel_path lines.
        const finalText = await finalizeAndUploadAttachments(text, uDiv);
        await sendAgentChat(finalText, uDiv);
      }

      async function sendAgentChat(text, uDiv) {
        streaming = true;
        chatSend.disabled = true;
        setInterruptUi(true, "");
        const aDiv = addThinkingIndicator();
        try {
          async function readError(res, fallbackPrefix) {
            const raw = await res.text().catch(() => "");
            try {
              const obj = raw ? JSON.parse(raw) : {};
              const msg = (obj && (obj.error || obj.detail || obj.message)) ? (obj.error || obj.detail || obj.message) : "";
              if (msg) return msg;
            } catch (_) {}
            if (raw && raw.trim()) return raw.trim().slice(0, 200);
            return fallbackPrefix + " (" + res.status + ")";
          }

          const boot = await fetch(API + "/brain/agent/bootstrap", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: "{}",
          });
          if (!boot.ok) {
            throw new Error(await readError(boot, "Agent bootstrap failed"));
          }

          const res = await fetch(API + "/brain/inbox/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ text, meta: { source: "chat_ui", session_id: chatSessionId } }),
          });
          if (!res.ok) {
            throw new Error(await readError(res, "Agent queue failed"));
          }
          const queued = await res.json();
          const itemId = queued.id || "";
          if (!itemId) {
            throw new Error("Agent item id missing");
          }
          try { _sentTextByItemId.set(String(itemId), String(text || "")); } catch (_) {}
          setInterruptUi(true, itemId);
          try {
            if (uDiv) uDiv.dataset.itemId = String(itemId);
            aDiv.dataset.itemId = String(itemId);
          } catch (_) {}
          // Persist item_id on the local-echo user message so it survives rotation and can be upgraded.
          try {
            for (let i = conversation.length - 1; i >= 0; i--) {
              const m = conversation[i];
              if (m && m.role === "user" && m.meta && m.meta.local_echo && !m.meta.item_id) {
                m.meta.item_id = String(itemId);
                break;
              }
            }
            saveConversation();
          } catch (_) {}

          const answer = await waitForAgentReply(itemId);
          if (!answer) {
            throw new Error("Agent timed out");
          }
          const memRe = /<<MEMORY_UPDATE>>([\s\S]*?)<<END_MEMORY>>/g;
          const cleaned = (answer || "").replace(memRe, "").trim();

          if (cleaned) {
            if (_thinking.el === aDiv) _thinking.el = null;
            aDiv.innerHTML = renderMarkdown(cleaned);
            try { renderInlineAttachments(aDiv, cleaned); } catch (_) {}
            try { renderInlineHtmlLinks(aDiv, cleaned); } catch (_) {}
            setMsgWorking(aDiv, false);
            if (/^Error:/i.test(String(cleaned || "").trim())) {
              attachAgentFailureActions(aDiv, itemId);
            }
            conversation.push({ role: "assistant", content: cleaned, meta: { item_id: itemId }, ts: Date.now() });
            saveConversation();
          } else {
            aDiv.remove();
            if (_thinking.el === aDiv) _thinking.el = null;
          }
        } catch (err) {
          if (aDiv.parentNode) aDiv.remove();
          if (_thinking.el === aDiv) _thinking.el = null;
          const msg = err.message || "Agent request failed";
          const friendly = {
            "brain_not_configured": "Configure Brain in Settings first.",
            "agent_vendor_not_supported": "Agent mode currently supports OpenAI-compatible providers only.",
          };
          addMsg("error", friendly[msg] || msg);
        } finally {
          streaming = false;
          chatSend.disabled = false;
          setInterruptUi(false, "");
        }
      }

      async function retryAgentItem(itemId) {
        if (!itemId || streaming) return;
        const fallbackText = (function() {
          try { return String(_sentTextByItemId.get(String(itemId)) || ""); } catch (_) { return ""; }
        })();
        streaming = true;
        chatSend.disabled = true;
        setInterruptUi(true, "");
        const aDiv = addThinkingIndicator();
        try {
          const boot = await fetch(API + "/brain/agent/bootstrap", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: "{}",
          });
          if (!boot.ok) throw new Error("Agent bootstrap failed (" + boot.status + ")");

          // Prefer backend retry (it can recover after rotation), but fall back to UI resend.
          let newId = "";
          let res = await fetch(API + "/brain/retry", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ item_id: String(itemId), session_id: chatSessionId }),
          });
          let body = await res.json().catch(() => ({}));
          if (res.ok && body && body.id) {
            newId = String(body.id);
          } else if (fallbackText) {
            res = await fetch(API + "/brain/inbox/chat", {
              method: "POST",
              headers: { "Content-Type": "application/json; charset=utf-8" },
              body: JSON.stringify({ text: fallbackText, meta: { source: "chat_ui_retry", session_id: chatSessionId, retry_of: String(itemId) } }),
            });
            body = await res.json().catch(() => ({}));
            if (!res.ok) {
              throw new Error("Retry failed (" + res.status + ")");
            }
            newId = body && body.id ? String(body.id) : "";
          } else {
            throw new Error("Retry unavailable (missing original text)");
          }
          if (!newId) throw new Error("Retry: missing item id");
          setInterruptUi(true, newId);
          try { aDiv.dataset.itemId = String(newId); } catch (_) {}
          try { if (fallbackText) _sentTextByItemId.set(String(newId), fallbackText); } catch (_) {}

          const answer = await waitForAgentReply(newId);
          if (!answer) throw new Error("Agent timed out");
          const cleaned = String(answer || "").trim();
          if (cleaned) {
            if (_thinking.el === aDiv) _thinking.el = null;
            aDiv.innerHTML = renderMarkdown(cleaned);
            try { renderInlineAttachments(aDiv, cleaned); } catch (_) {}
            try { renderInlineHtmlLinks(aDiv, cleaned); } catch (_) {}
            setMsgWorking(aDiv, false);
            if (/^Error:/i.test(String(cleaned || "").trim())) {
              attachAgentFailureActions(aDiv, newId);
            }
            conversation.push({ role: "assistant", content: cleaned, meta: { item_id: newId }, ts: Date.now() });
            saveConversation();
          } else {
            aDiv.remove();
            if (_thinking.el === aDiv) _thinking.el = null;
          }
        } catch (e) {
          try { if (aDiv.parentNode) aDiv.remove(); } catch (_) {}
          if (_thinking.el === aDiv) _thinking.el = null;
          showToast("Retry failed", 1400);
          try { addMsg("error", String(e && e.message ? e.message : e)); } catch (_) {}
        } finally {
          streaming = false;
          chatSend.disabled = false;
          setInterruptUi(false, "");
        }
      }

      // ==============================
      // Pending attachments (Slack-like)
      // ==============================
      const composerAttachments = $("composerAttachments");
      let pendingAttachments = [];
      let uploadBusy = false;
      let recordingBusy = false;

      function fmtBytes(n) {
        const v = Number(n || 0);
        if (!isFinite(v) || v <= 0) return "0 B";
        const units = ["B","KB","MB","GB"];
        let x = v, u = 0;
        while (x >= 1024 && u < units.length - 1) { x /= 1024; u++; }
        return (u === 0 ? String(Math.round(x)) : x.toFixed(1)) + " " + units[u];
      }

      function renderComposerAttachments() {
        if (!composerAttachments) return;
        composerAttachments.innerHTML = "";
        if (!pendingAttachments.length) {
          composerAttachments.classList.remove("show");
          return;
        }
        composerAttachments.classList.add("show");
        pendingAttachments.forEach((a, idx) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          const name = document.createElement("div");
          name.className = "chip-name";
          name.textContent = a.name;
          const sub = document.createElement("div");
          sub.className = "chip-sub";
          sub.textContent = a.size ? fmtBytes(a.size) : (a.kind === "recording" ? "recording" : "");
          const x = document.createElement("button");
          x.className = "chip-x";
          x.title = "Remove";
          x.setAttribute("aria-label", "Remove");
          x.textContent = "x";
          x.addEventListener("click", () => {
            // Revoke object URLs if we created any.
            if (a._localUrl) { try { URL.revokeObjectURL(a._localUrl); } catch (_) {} }
            pendingAttachments.splice(idx, 1);
            renderComposerAttachments();
          });
          chip.appendChild(name);
          chip.appendChild(sub);
          chip.appendChild(x);
          composerAttachments.appendChild(chip);
        });
      }

      function addPendingFile(f) {
        if (!f) return;
        pendingAttachments.push({
          kind: "file",
          name: String(f.name || "file"),
          size: Number(f.size || 0),
          file: f,
        });
        renderComposerAttachments();
      }

      function addPendingRecording(blob, name) {
        if (!blob) return;
        pendingAttachments.push({
          kind: "recording",
          name: String(name || ("recording_" + Date.now() + ".webm")),
          size: Number(blob.size || 0),
          blob: blob,
        });
        renderComposerAttachments();
      }

      async function finalizeAndUploadAttachments(comment, uDiv) {
        const text = String(comment || "").trim();
        if (!pendingAttachments.length) return text || "(no text)";
        if (uploadBusy) return text || "(upload in progress)";
        uploadBusy = true;
        chatSend.disabled = true;

        // Copy and clear composer immediately (so user can continue composing next message).
        const items = pendingAttachments.slice();
        pendingAttachments = [];
        renderComposerAttachments();

        const rels = [];
        for (const a of items) {
          try {
            const fd = new FormData();
            if (a.kind === "file") {
              fd.append("file", a.file, a.name);
              fd.append("dir", "uploads/chat");
            } else {
              fd.append("file", a.blob, a.name);
              fd.append("dir", "uploads/recordings");
            }
            const res = await fetch(API + "/user/upload", { method: "POST", body: fd });
            const data = await res.json().catch(() => ({}));
            if (res.ok && data && data.path) {
              rels.push(String(data.path));
            } else {
              rels.push("");
              addMsg("assistant", "Attachment upload failed: " + a.name + " -> " + JSON.stringify(data), { debug: true });
            }
          } catch (e) {
            rels.push("");
            addMsg("assistant", "Attachment upload error: " + a.name + " -> " + String(e), { debug: true });
          }
        }

        const lines = [];
        if (text) lines.push(text);
        for (const p of rels.filter(Boolean)) {
          lines.push("rel_path: " + p);
        }
        const finalText = lines.join("\n");

        // Update local echo bubble with final message so inline media renders.
        try {
          uDiv.innerHTML = renderMarkdown(finalText);
          try { renderInlineAttachments(uDiv, finalText); } catch (_) {}
          try { renderInlineHtmlLinks(uDiv, finalText); } catch (_) {}
        } catch (_) {}

        uploadBusy = false;
        chatSend.disabled = false;
        saveConversation();
        return finalText || "(sent)";
      }

      // Chat-left media buttons (attach + record)
      (function initChatAttachAndRecord() {
        const uploadBtn = $("chatUploadBtn");
        const uploadInput = $("chatUploadInput");
        const recBtn = $("chatRecordBtn");
        const recStatus = $("recordingStatus");
        let rStream = null;
        let rRec = null;
        let rChunks = [];
        let recStartedAtMs = 0;
        let recTimer = null;
        let recStartCountdownTimer = null;
        let recStartCountdownActive = false;
        let recMaxDurationS = 0;
        if (uploadBtn && uploadInput) {
          uploadBtn.addEventListener("click", () => uploadInput.click());
          uploadInput.addEventListener("change", () => {
            const list = uploadInput.files ? Array.from(uploadInput.files) : [];
            list.forEach(addPendingFile);
            uploadInput.value = "";
          });
        }

        function setRecordUi(recording) {
          if (!recBtn) return;
          try {
            if (recStatus) {
              recStatus.style.display = recording ? "block" : "none";
              if (!recording) recStatus.textContent = "";
            }
          } catch (_) {}
          if (recording) {
            recBtn.classList.add("danger");
            recBtn.title = "Stop recording";
            recBtn.setAttribute("aria-label", "Stop recording");
            recBtn.innerHTML = ICON.stop;
          } else {
            recBtn.classList.remove("danger");
            recBtn.title = "Record audio";
            recBtn.setAttribute("aria-label", "Record audio");
            recBtn.innerHTML = ICON.mic;
          }
        }

        if (recBtn) {
          setRecordUi(false);
          function stopRecTimer() {
            try { if (recTimer) clearInterval(recTimer); } catch (_) {}
            recTimer = null;
          }
          function stopStartCountdown() {
            try { if (recStartCountdownTimer) clearInterval(recStartCountdownTimer); } catch (_) {}
            recStartCountdownTimer = null;
            recStartCountdownActive = false;
          }
          function startCountdown(seconds) {
            stopStartCountdown();
            const total = Math.max(1, Number(seconds) || 3);
            let remain = total;
            recStartCountdownActive = true;
            try {
              if (recStatus) {
                recStatus.style.display = "block";
                recStatus.textContent = "Recording starts in " + remain + "…";
              }
            } catch (_) {}
            recStartCountdownTimer = setInterval(() => {
              remain -= 1;
              if (remain <= 0) {
                stopStartCountdown();
                return;
              }
              try {
                if (recStatus) recStatus.textContent = "Recording starts in " + remain + "…";
              } catch (_) {}
            }, 1000);
          }
          function startRecTimer() {
            stopRecTimer();
            recStartedAtMs = Date.now();
            recTimer = setInterval(() => {
              try {
                if (!recStatus) return;
                const sec = Math.max(0, Math.floor((Date.now() - recStartedAtMs) / 1000));
                const mm = String(Math.floor(sec / 60)).padStart(2, "0");
                const ss = String(sec % 60).padStart(2, "0");
                if (recMaxDurationS > 0) {
                  const rem = Math.max(0, recMaxDurationS - sec);
                  const rmm = String(Math.floor(rem / 60)).padStart(2, "0");
                  const rss = String(rem % 60).padStart(2, "0");
                  recStatus.textContent = "Recording " + mm + ":" + ss + " (left " + rmm + ":" + rss + ")";
                  if (rem <= 0 && rRec && rRec.state !== "inactive") {
                    try { rRec.stop(); } catch (_) {}
                  }
                } else {
                  recStatus.textContent = "Recording " + mm + ":" + ss + " (tap stop to finish)";
                }
              } catch (_) {}
            }, 250);
          }

          async function getMicStreamWithFallback() {
            // Some Android builds/WebView versions intermittently throw NotReadableError
            // ("Could not start audio source") on the first attempt depending on routing.
            try {
              return await navigator.mediaDevices.getUserMedia({ audio: true });
            } catch (e) {
              const name = (e && e.name) ? String(e.name) : "";
              const msg = (e && e.message) ? String(e.message) : "";
              const isNotReadable = name === "NotReadableError" || /start audio source/i.test(msg);
              if (!isNotReadable) throw e;
              await new Promise(r => setTimeout(r, 250));
              // Fallback: disable processing constraints (can help on some devices).
              return await navigator.mediaDevices.getUserMedia({
                audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
              });
            }
          }
          recBtn.addEventListener("click", async () => {
            if (recStartCountdownActive) {
              stopStartCountdown();
              recordingBusy = false;
              setRecordUi(false);
              return;
            }
            // Toggle stop if active.
            if (rRec && rRec.state !== "inactive") {
              try { rRec.stop(); } catch (_) {
                // Ensure we don't get stuck in "recording" UI if stop fails.
                try { if (rStream) rStream.getTracks().forEach(t => t.stop()); } catch (_) {}
                rStream = null;
                rRec = null;
                rChunks = [];
                stopRecTimer();
                stopStartCountdown();
                setRecordUi(false);
              }
              return;
            }
            // Only block if we're in the middle of starting recording.
            if (recordingBusy || recStartCountdownActive) return;
            try {
              recordingBusy = true;
              startCountdown(3);
              await new Promise(r => setTimeout(r, 3000));
              stopStartCountdown();
              // Recording is a user-initiated UI action; rely on WebView/OS microphone permission prompts.
              // Do not route through the agent permission broker, which would break the user-gesture chain.
              if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error("mediaDevices.getUserMedia unavailable");
              }
              if (typeof MediaRecorder === "undefined") {
                throw new Error("MediaRecorder unavailable");
              }
              rChunks = [];
              try {
                if (typeof AndroidBridge !== "undefined" && AndroidBridge.getAudioRecordMaxDurationS) {
                  recMaxDurationS = Number(AndroidBridge.getAudioRecordMaxDurationS() || 0);
                } else {
                  recMaxDurationS = 0;
                }
              } catch (_) {
                recMaxDurationS = 0;
              }
              rStream = await getMicStreamWithFallback();
              rRec = new MediaRecorder(rStream);
              rRec.ondataavailable = (e) => { if (e.data && e.data.size) rChunks.push(e.data); };
              rRec.onstop = () => {
                const blob = new Blob(rChunks, { type: rRec.mimeType || "audio/webm" });
                try { if (rStream) rStream.getTracks().forEach(t => t.stop()); } catch (_) {}
                rStream = null;
                rRec = null;
                rChunks = [];
                recordingBusy = false;
                stopRecTimer();
                stopStartCountdown();
                setRecordUi(false);
                try {
                  const ts = new Date().toISOString().replace(/[:.]/g, "-");
                  addPendingRecording(blob, "audio_recording_" + ts + ".webm");
                } catch (_) {}
              };
              rRec.start();
              // Starting has finished; allow stop-tap immediately.
              recordingBusy = false;
              setRecordUi(true);
              startRecTimer();
              showToast("Recording... tap again to stop", 1400);
            } catch (e) {
              setRecordUi(false);
              recordingBusy = false;
              stopRecTimer();
              stopStartCountdown();
              let msg = "Record failed";
              try {
                const n = (e && e.name) ? String(e.name) : "";
                const m = (e && e.message) ? String(e.message) : String(e);
                const s = (n ? (n + ": ") : "") + (m || "");
                if (s.trim() && s.trim() !== "undefined") {
                  msg = "Record failed: " + s.trim();
                } else {
                  msg = "Record failed: (no detail) Try closing other apps using the mic and retry.";
                }
              } catch (_) {}
              try { console.log("record error", e); } catch (_) {}
              showToast(msg, 2400);
              try { addMsg("assistant", msg, { debug: true }); } catch (_) {}
            }
          });
        }
      })();

      async function waitForAgentReply(itemId) {
        // SSE-primary: register a waiter resolved by the brain_message handler.
        const ssePromise = new Promise(resolve => {
          _sseWaiters.set(itemId, { resolve });
        });

        // Slow polling fallback (15s intervals) as safety net.
        const pollPromise = (async () => {
          const deadline = Date.now() + 15 * 60 * 1000;
          let lastToolError = "";
          while (Date.now() < deadline) {
            await new Promise(r => setTimeout(r, 15000));
            try {
              const res = await fetch(
                API + "/brain/messages?limit=200&session_id=" + encodeURIComponent(chatSessionId)
              );
              if (!res.ok) continue;
              const data = await res.json().catch(() => ({}));
              const list = Array.isArray(data.messages) ? data.messages : [];
              for (const msg of list) {
                const meta = msg && msg.meta ? msg.meta : {};
                if (meta.item_id !== itemId) continue;
                if (msg.role === "assistant" && typeof msg.text === "string" && msg.text.trim()) {
                  return msg.text.trim();
                }
                if (msg.role === "tool" && typeof msg.text === "string") {
                  try {
                    const parsed = JSON.parse(msg.text);
                    const result = parsed && parsed.result ? parsed.result : {};
                    if (result.error) lastToolError = result.error;
                  } catch (_) {}
                }
              }
            } catch (_) {}
          }
          if (lastToolError) throw new Error(lastToolError);
          return "";
        })();

        const result = await Promise.race([ssePromise, pollPromise]);
        // Clean up waiter if poll won.
        _sseWaiters.delete(itemId);
        return result;
      }

      // ==============================
      // Brain Config
      // ==============================
      const brainSelect = $("brainVendorModel");
      const brainCustom = $("brainCustomFields");

      function getSelectedPreset() {
        const opt = brainSelect.selectedOptions[0];
        if (!opt || !opt.dataset.vendor) return null;
        if (opt.dataset.vendor === "custom") return { vendor: "custom" };
        return {
          vendor: opt.dataset.vendor,
          base_url: opt.dataset.url,
          model: opt.value,
        };
      }

      brainSelect.addEventListener("change", () => {
        const p = getSelectedPreset();
        brainCustom.style.display = (p && p.vendor === "custom") ? "block" : "none";
        // Switching providers changes which API key slot will be used. Keep the key field locked
        // until the user taps it and authenticates.
        try { lockSecretField($("brainApiKey")); } catch (_) {}
        try { updateBrainSaveEnabled(); } catch (_) {}
      });

      let brainInitial = { vendor: "", base_url: "", model: "" };
      function readBrainUiState() {
        const preset = getSelectedPreset();
        if (!preset) return { vendor: "", base_url: "", model: "" };
        if (preset.vendor === "custom") {
          return {
            vendor: "custom",
            base_url: $("brainBaseUrl").value.trim(),
            model: $("brainModelId").value.trim(),
          };
        }
        return { vendor: preset.vendor || "", base_url: preset.base_url || "", model: preset.model || "" };
      }
      function updateBrainSaveEnabled() {
        try {
          const cur = readBrainUiState();
          const configDirty =
            String(cur.vendor || "") !== String(brainInitial.vendor || "") ||
            String(cur.base_url || "") !== String(brainInitial.base_url || "") ||
            String(cur.model || "") !== String(brainInitial.model || "");
          const keyDirty = isSecretDirty($("brainApiKey"));
          $("brainSave").disabled = !(configDirty || keyDirty);
        } catch (_) {
          try { $("brainSave").disabled = false; } catch (_) {}
        }
      }

      async function loadBrainConfig() {
        try {
          const res = await fetch(API + "/brain/config");
          if (!res.ok) return;
          const data = await res.json();
          $("brainKeyStatus").textContent = data.has_api_key ? "API key is set." : "No API key configured.";

          const vendor = data.vendor || "";
          const model = data.model || "";
          let matched = false;
          for (const opt of brainSelect.options) {
            if (opt.dataset.vendor && opt.dataset.vendor !== "custom"
                && opt.dataset.vendor === vendor && opt.value === model) {
              opt.selected = true;
              matched = true;
              break;
            }
          }
          if (!matched && model) {
            for (const opt of brainSelect.options) {
              if (opt.value === "custom") { opt.selected = true; break; }
            }
            brainCustom.style.display = "block";
            $("brainBaseUrl").value = data.base_url || "";
            $("brainModelId").value = model;
          } else {
            brainCustom.style.display = "none";
          }
          brainInitial = { vendor: data.vendor || "", base_url: data.base_url || "", model: data.model || "" };
          try { lockSecretField($("brainApiKey")); } catch (_) {}
          updateBrainSaveEnabled();
        } catch (_) {}
      }

      $("brainSave").addEventListener("click", async () => {
        const preset = getSelectedPreset();
        if (!preset) { showToast("Choose a model first"); return; }

        const payload = {};
        if (preset.vendor === "custom") {
          const baseUrl = $("brainBaseUrl").value.trim();
          const modelId = $("brainModelId").value.trim();
          if (!baseUrl || !modelId) { showToast("Fill in Base URL and Model"); return; }
          payload.vendor = "custom";
          payload.base_url = baseUrl;
          payload.model = modelId;
        } else {
          payload.vendor = preset.vendor;
          payload.base_url = preset.base_url;
          payload.model = preset.model;
        }

        const keyEl = $("brainApiKey");
        const keyUnlocked = String((keyEl && keyEl.dataset ? keyEl.dataset.secretLocked : "1") || "1") === "0";
        const apiKey = keyUnlocked ? String(keyEl.value || "").trim() : "";
        const keyDirty = keyUnlocked && isSecretDirty(keyEl);
        if (keyDirty) {
          if (!(await ensureSensitiveUnlocked())) return;
          payload.api_key = apiKey;
        }

        try {
          try {
            // Only write secrets to the bridge when the user actually changed the value.
            if (keyDirty) {
              if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBrainApiKeyFor) {
                AndroidBridge.setBrainApiKeyFor(String(payload.vendor || ""), String(payload.base_url || ""), apiKey);
              } else if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBrainApiKeyPlain) {
                AndroidBridge.setBrainApiKeyPlain(apiKey);
              }
            }
          } catch (_) {}

          const res = await fetch(API + "/brain/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) { showToast("Failed to save config"); return; }
          await loadBrainConfig();
          showToast("Brain config saved");
        } catch (_) {
          showToast("Connection error");
        }
      });

      loadBrainConfig();

      // Secret field unlock triggers (tap-to-unlock).
      try {
        $("brainApiKey").addEventListener("focus", async (e) => {
          if (String($("brainApiKey").dataset.secretLocked || "1") !== "0") {
            try { e && e.preventDefault && e.preventDefault(); } catch (_) {}
            await unlockBrainKeyField();
            updateBrainSaveEnabled();
          }
        });
        $("brainApiKey").addEventListener("click", async () => {
          if (String($("brainApiKey").dataset.secretLocked || "1") !== "0") {
            await unlockBrainKeyField();
            updateBrainSaveEnabled();
          }
        });
        $("brainApiKey").addEventListener("input", () => {
          updateBrainSaveEnabled();
        });
        $("brainBaseUrl").addEventListener("input", updateBrainSaveEnabled);
        $("brainModelId").addEventListener("input", updateBrainSaveEnabled);
      } catch (_) {}

      try {
        $("braveSearchApiKey").addEventListener("focus", async (e) => {
          if (String($("braveSearchApiKey").dataset.secretLocked || "1") !== "0") {
            try { e && e.preventDefault && e.preventDefault(); } catch (_) {}
            await unlockBraveKeyField();
            refreshBraveSearchKeyStatus();
            updateBraveButtons();
          }
        });
        $("braveSearchApiKey").addEventListener("click", async () => {
          if (String($("braveSearchApiKey").dataset.secretLocked || "1") !== "0") {
            await unlockBraveKeyField();
            refreshBraveSearchKeyStatus();
            updateBraveButtons();
          }
        });
        $("braveSearchApiKey").addEventListener("input", () => {
          refreshBraveSearchKeyStatus();
          updateBraveButtons();
        });
      } catch (_) {}

      // ==============================
      // Memory Editor
      // ==============================
      const memoryEditor = $("memoryEditor");

      async function loadMemory() {
        try {
          const res = await fetch(API + "/brain/memory");
          if (!res.ok) return;
          const data = await res.json();
          memoryEditor.value = data.content || "";
        } catch (_) {}
      }

      $("memorySave").addEventListener("click", async () => {
        try {
          const res = await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: memoryEditor.value }),
          });
          if (res.ok) showToast("Memory saved");
          else showToast("Failed to save memory");
        } catch (_) { showToast("Connection error"); }
      });

      $("memoryClear").addEventListener("click", async () => {
        if (!await appConfirm("Clear memory", "Clear all memory? This cannot be undone.")) return;
        memoryEditor.value = "";
        try {
          await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: "" }),
          });
          showToast("Memory cleared");
        } catch (_) { showToast("Connection error"); }
      });

      loadMemory();

      // ==============================
      // Web Search Keys
      // ==============================
      function refreshBraveSearchKeyStatus() {
        try {
          const locked = String($("braveSearchApiKey").dataset.secretLocked || "1") !== "0";
          if (locked) {
            // Don't try to infer from UI value while locked.
            $("braveSearchKeyStatus").textContent = "Tap to unlock to view status.";
            return;
          }
          const k = String($("braveSearchApiKey").value || "").trim();
          $("braveSearchKeyStatus").textContent = k ? "API key is set." : "No API key configured.";
        } catch (_) {
          try { $("braveSearchKeyStatus").textContent = ""; } catch (_) {}
        }
      }

      function updateBraveButtons() {
        try {
          const el = $("braveSearchApiKey");
          const unlocked = String(el.dataset.secretLocked || "1") === "0";
          const dirty = isSecretDirty(el);
          $("braveSearchSave").disabled = !(unlocked && dirty);
          $("braveSearchClear").disabled = !(unlocked && String(el.value || "").trim());
        } catch (_) {}
      }

      $("braveSearchSave").addEventListener("click", async () => {
        if (!(await ensureSensitiveUnlocked())) return;
        const key = $("braveSearchApiKey").value.trim();
        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain(key);
              showToast("Brave key saved");
              refreshBraveSearchKeyStatus();
              markSecretOriginal($("braveSearchApiKey"));
              updateBraveButtons();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Set Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: key, permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key saved");
          refreshBraveSearchKeyStatus();
          markSecretOriginal($("braveSearchApiKey"));
          updateBraveButtons();
        } catch (_) {
          showToast("Failed to save key");
        }
      });

      $("braveSearchClear").addEventListener("click", async () => {
        if (!(await ensureSensitiveUnlocked())) return;
        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain("");
              $("braveSearchApiKey").value = "";
              showToast("Brave key cleared");
              refreshBraveSearchKeyStatus();
              markSecretOriginal($("braveSearchApiKey"));
              updateBraveButtons();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Clear Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: "", permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key cleared");
          refreshBraveSearchKeyStatus();
          markSecretOriginal($("braveSearchApiKey"));
          updateBraveButtons();
        } catch (_) {
          showToast("Failed to clear key");
        }
      });

      // ==============================
      // Settings: SSHD, Python, etc.
      // ==============================
      const pythonStatus = $("pythonStatus");
      const pythonDetail = $("pythonDetail");
      const appUpdateStatus = $("appUpdateStatus");
      const appUpdateDetail = $("appUpdateDetail");
      const appUpdateDownloadIndicator = $("appUpdateDownloadIndicator");
      const checkAppUpdate = $("checkAppUpdate");
      const installAppUpdate = $("installAppUpdate");
      const openInstallUnknownSources = $("openInstallUnknownSources");
      const meSyncStatus = $("meSyncStatus");
      const meSyncPrepareExport = $("meSyncPrepareExport");
      const meSyncImport = $("meSyncImport");
      const meSyncModal = $("meSyncModal");
      const meSyncModalClose = $("meSyncModalClose");
      const meSyncModalStatus = $("meSyncModalStatus");
      const meSyncPrepareWrap = $("meSyncPrepareWrap");
      const meSyncPrepareText = $("meSyncPrepareText");
      const meSyncQrWrap = $("meSyncQrWrap");
      const meSyncQrImage = $("meSyncQrImage");
      const meSyncExpireText = $("meSyncExpireText");
      const meSyncExportCancel = $("meSyncExportCancel");
      const meSyncCopyUri = $("meSyncCopyUri");
      const meSyncImportModal = $("meSyncImportModal");
      const meSyncImportModalClose = $("meSyncImportModalClose");
      const meSyncImportModalStatus = $("meSyncImportModalStatus");
      const meSyncImportProgressWrap = $("meSyncImportProgressWrap");
      const meSyncImportProgressText = $("meSyncImportProgressText");
      const appVersionText = $("appVersionText");
      const appCommitLink = $("appCommitLink");
      const appRepoLink = $("appRepoLink");
      const openLicensesPage = $("openLicensesPage");
      const shareAppBtn = $("shareAppBtn");
      const sshStatus = $("sshStatus");
      const sshEnabled = $("sshEnabled");
      const authNotification = $("authNotification");
      const authPin = $("authPin");
      const sshDetail = $("sshDetail");
      const clientKeyRow = $("clientKeyRow");
      const clientKeyFp = $("clientKeyFp");
      const copyClientKey = $("copyClientKey");
      const sshKeysList = $("sshKeysList");
      const sshKeysAdd = $("sshKeysAdd");
      const sshKeysRefresh = $("sshKeysRefresh");
      let currentClientKeyPublic = "";
      const pinModal = $("pinModal");
      const pinCode = $("pinCode");
      const pinCountdown = $("pinCountdown");
      const pinClose = $("pinClose");
      const pinBarFill = $("pinBarFill");
      const pinDurationMs = 20000;
      let pinExpiresAt = null;
      let lastPin = null;

      function esc(s) {
        return String(s || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escAttr(s) {
        return esc(s).replace(/\"/g, "&quot;").replace(/'/g, "&#39;");
      }

      function setStatus(el, value) {
        el.textContent = value;
        el.classList.remove("ok", "offline", "starting", "stopping");
        if (value === "ok") el.classList.add("ok");
        else if (value === "offline") el.classList.add("offline");
        else if (value === "stopping") el.classList.add("stopping");
        else el.classList.add("starting");
      }

      let appUpdateInfo = null;
      let appUpdatePrompted = false;
      let meSyncActiveExport = null;
      let meSyncExportReq = null;
      let meSyncExpireTimer = null;
      let meSyncPrepareTimer = null;
      let meSyncPrepareStartedAt = 0;
      let meSyncImportTimer = null;
      let meSyncImportStartedAt = 0;
      let meSyncImportInFlight = false;

      function formatDurationMMSS(ms) {
        const totalSec = Math.max(0, Math.floor((Number(ms) || 0) / 1000));
        const mm = Math.floor(totalSec / 60);
        const ss = totalSec % 60;
        return String(mm).padStart(2, "0") + ":" + String(ss).padStart(2, "0");
      }

      function updateAppUpdateButtons() {
        const updateEnabled = !(appUpdateInfo && appUpdateInfo.update_enabled === false);
        checkAppUpdate.disabled = !updateEnabled;
        installAppUpdate.disabled = !updateEnabled || !(appUpdateInfo && appUpdateInfo.has_update);
      }

      function setAppUpdateDownloading(active) {
        try {
          if (!appUpdateDownloadIndicator) return;
          appUpdateDownloadIndicator.style.display = active ? "inline-flex" : "none";
        } catch (_) {}
      }

      function setInstallPermissionButtonVisible(show) {
        try {
          if (!openInstallUnknownSources) return;
          openInstallUnknownSources.style.display = show ? "" : "none";
        } catch (_) {}
      }

      async function getInstallPermissionState() {
        try {
          const res = await fetch(API + "/app/update/install_permission");
          if (!res.ok) throw 0;
          return await res.json();
        } catch (_) {
          return null;
        }
      }

      async function openInstallPermissionSettings() {
        try {
          const res = await fetch(API + "/app/update/install_permission/open_settings", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({}),
          });
          return res.ok;
        } catch (_) {
          return false;
        }
      }

      async function waitForInstallPermissionReturn(timeoutMs) {
        const deadline = Date.now() + Math.max(2000, Number(timeoutMs) || 45000);
        let hiddenAt = 0;
        while (Date.now() < deadline) {
          await new Promise(r => setTimeout(r, 400));
          try {
            if (document.visibilityState !== "visible") {
              if (!hiddenAt) hiddenAt = Date.now();
              continue;
            }
          } catch (_) {}
          const st = await getInstallPermissionState();
          if (st && st.granted) return true;
          if (hiddenAt) return false;
        }
        return false;
      }

      async function ensureInstallPermissionBeforeInstall() {
        while (true) {
          const st = await getInstallPermissionState();
          if (st && st.granted) {
            setInstallPermissionButtonVisible(false);
            return true;
          }
          setInstallPermissionButtonVisible(true);
          const ok = await appConfirm(
            "Install permission required",
            "To install updates, allow \"Install unknown apps\" for methings in Android settings.",
            { cancel: "Cancel", ok: "Open Settings", okClass: "primary" }
          );
          if (!ok) return false;
          const opened = await openInstallPermissionSettings();
          if (!opened) {
            showToast("Failed to open settings", 1800);
            continue;
          }
          const granted = await waitForInstallPermissionReturn(120000);
          if (granted) {
            setInstallPermissionButtonVisible(false);
            return true;
          }
          // Not granted after returning from settings; loop and re-show the same blocking dialog.
        }
      }

      async function refreshAppUpdate(autoPrompt) {
        setStatus(appUpdateStatus, "starting");
        appUpdateDetail.textContent = "Checking latest release...";
        setAppUpdateDownloading(false);
        try {
          const res = await fetch(API + "/app/update/check");
          if (!res.ok) throw 0;
          const data = await res.json();
          appUpdateInfo = data || null;
          if (data && data.update_enabled === false) {
            setInstallPermissionButtonVisible(false);
            setStatus(appUpdateStatus, "ok");
            appUpdateStatus.textContent = "disabled";
            appUpdateDetail.textContent = String(data.message || "Auto update is disabled for this build.");
            updateAppUpdateButtons();
            return;
          }
          const canInstall = !!(data && data.can_request_installs);
          setInstallPermissionButtonVisible(!canInstall);
          const cur = String(data.current_version || "").trim();
          const latest = String(data.latest_tag || "").trim();
          const hasUpdate = !!data.has_update;
          if (hasUpdate) {
            setStatus(appUpdateStatus, "starting");
            appUpdateStatus.textContent = "update";
            appUpdateDetail.textContent = "New version: " + latest + " (current: " + cur + ")";
            if (autoPrompt && !appUpdatePrompted) {
              appUpdatePrompted = true;
              const ok = await appConfirm("Update available", latest + " is available. Download and install now?", { cancel: "Later", ok: "Install Now", okClass: "primary" });
              if (ok) {
                const permitted = await ensureInstallPermissionBeforeInstall();
                if (!permitted) return;
                await installLatestUpdate();
              }
            }
          } else {
            setStatus(appUpdateStatus, "ok");
            appUpdateDetail.textContent = "Up to date (" + cur + ")";
          }
          updateAppUpdateButtons();
        } catch (_) {
          setStatus(appUpdateStatus, "offline");
          appUpdateDetail.textContent = "Failed to check updates";
          updateAppUpdateButtons();
        }
      }

      async function installLatestUpdate() {
        setStatus(appUpdateStatus, "starting");
        appUpdateDetail.textContent = "Downloading update APK...";
        setAppUpdateDownloading(true);
        try {
          const res = await fetch(API + "/app/update/install", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({}),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw 0;
          if (data.status === "install_permission_required") {
            setInstallPermissionButtonVisible(true);
            setStatus(appUpdateStatus, "starting");
            appUpdateDetail.textContent = "Install permission required. Tap \"Allow Install Permission\".";
            showToast("Installer permission required", 2200);
            updateAppUpdateButtons();
            setAppUpdateDownloading(false);
            return;
          }
          setInstallPermissionButtonVisible(false);
          setStatus(appUpdateStatus, "starting");
          appUpdateStatus.textContent = "installing";
          appUpdateDetail.textContent = "Installer opened for " + String(data.latest_tag || "latest");
          showToast("Installer opened", 1800);
          updateAppUpdateButtons();
          setAppUpdateDownloading(false);
        } catch (_) {
          setStatus(appUpdateStatus, "offline");
          appUpdateDetail.textContent = "Update install failed";
          showToast("Failed to install update", 1800);
          updateAppUpdateButtons();
          setAppUpdateDownloading(false);
        }
      }

      function updateMeSyncSectionCountdown() {
        const a = meSyncActiveExport;
        const exp = Number((a && a.expires_at) || 0);
        if (!a || exp <= 0) return;
        const remMs = Math.max(0, exp - Date.now());
        if (remMs <= 0) {
          meSyncActiveExport = null;
          meSyncStatus.textContent = "No active export.";
          return;
        }
        meSyncStatus.textContent = "Active export: " + String(a.id || "") + " (expires in " + formatDurationMMSS(remMs) + ")";
      }

      async function refreshMeSyncStatus() {
        try {
          const res = await fetch(API + "/me/sync/status");
          if (!res.ok) throw 0;
          const data = await res.json().catch(() => ({}));
          const items = Array.isArray(data.items) ? data.items : [];
          if (!items.length) {
            meSyncActiveExport = null;
            meSyncStatus.textContent = "No active export.";
            return;
          }
          const top = items[0] || {};
          const prev = meSyncActiveExport || {};
          if (!top.qr_data_url && String(top.id || "") && String(prev.id || "") === String(top.id || "")) {
            if (String(prev.qr_data_url || "").trim()) top.qr_data_url = prev.qr_data_url;
            if (!String(top.me_sync_uri || "").trim() && String(prev.me_sync_uri || "").trim()) top.me_sync_uri = prev.me_sync_uri;
          }
          meSyncActiveExport = top;
          updateMeSyncSectionCountdown();
        } catch (_) {
          meSyncStatus.textContent = "Sync status unavailable.";
        }
      }

      function stopMeSyncPrepareTimer() {
        try { if (meSyncPrepareTimer) clearInterval(meSyncPrepareTimer); } catch (_) {}
        meSyncPrepareTimer = null;
      }

      function startMeSyncPrepareTimer() {
        stopMeSyncPrepareTimer();
        meSyncPrepareStartedAt = Date.now();
        meSyncPrepareText.textContent = "Preparing export (" + formatDurationMMSS(0) + ")";
        meSyncPrepareTimer = setInterval(() => {
          const elapsed = Date.now() - meSyncPrepareStartedAt;
          meSyncPrepareText.textContent = "Preparing export (" + formatDurationMMSS(elapsed) + ")";
        }, 500);
      }

      function closeMeSyncModal() {
        try { if (meSyncExpireTimer) clearInterval(meSyncExpireTimer); } catch (_) {}
        meSyncExpireTimer = null;
        stopMeSyncPrepareTimer();
        meSyncModal.classList.remove("show");
      }

      function stopMeSyncImportTimer() {
        try { if (meSyncImportTimer) clearInterval(meSyncImportTimer); } catch (_) {}
        meSyncImportTimer = null;
      }

      function closeMeSyncImportModal(force) {
        if (!force && meSyncImportInFlight) {
          showToast("Import is still running", 1400);
          return;
        }
        stopMeSyncImportTimer();
        try { meSyncImportModal.classList.remove("show"); } catch (_) {}
      }

      function showMeSyncImportModal(initialStatus) {
        meSyncImportModalStatus.textContent = String(initialStatus || "Importing...");
        meSyncImportProgressWrap.style.display = "block";
        meSyncImportProgressText.textContent = "Elapsed " + formatDurationMMSS(0);
        meSyncImportInFlight = true;
        meSyncImportModalClose.disabled = true;
        meSyncImportStartedAt = Date.now();
        stopMeSyncImportTimer();
        meSyncImportTimer = setInterval(() => {
          const elapsed = Date.now() - meSyncImportStartedAt;
          meSyncImportProgressText.textContent = "Elapsed " + formatDurationMMSS(elapsed);
        }, 500);
        meSyncImportModal.classList.add("show");
      }

      function updateMeSyncImportPhase(label) {
        if (!meSyncImportInFlight) return;
        meSyncImportModalStatus.textContent = String(label || "Importing...");
      }

      function finishMeSyncImportModal(ok, msg) {
        meSyncImportInFlight = false;
        stopMeSyncImportTimer();
        meSyncImportModalStatus.textContent = String(msg || (ok ? "Import completed." : "Import failed."));
        meSyncImportProgressWrap.style.display = "none";
        meSyncImportModalClose.disabled = false;
      }

      function startMeSyncExpireTimer() {
        try { if (meSyncExpireTimer) clearInterval(meSyncExpireTimer); } catch (_) {}
        meSyncExpireTimer = setInterval(() => {
          if (!meSyncActiveExport) return;
          const exp = Number(meSyncActiveExport.expires_at || 0);
          const rem = exp > 0 ? Math.max(0, exp - Date.now()) : 0;
          meSyncExpireText.textContent = "Expires in " + formatDurationMMSS(rem);
          if (rem <= 0) {
            meSyncModalStatus.textContent = "Export expired.";
            meSyncQrWrap.style.display = "none";
          }
        }, 1000);
      }

      function showMeSyncExportModal(preparing) {
        meSyncModal.classList.add("show");
        if (preparing) {
          meSyncModalStatus.textContent = "Preparing export...";
          meSyncPrepareWrap.style.display = "block";
          meSyncQrWrap.style.display = "none";
          startMeSyncPrepareTimer();
          meSyncExportCancel.disabled = false;
          meSyncCopyUri.disabled = true;
          return;
        }
        stopMeSyncPrepareTimer();
        meSyncPrepareWrap.style.display = "none";
        const a = meSyncActiveExport || {};
        const qr = String(a.qr_data_url || "").trim();
        const uri = String(a.me_sync_uri || "").trim();
        meSyncModalStatus.textContent = "Export ready. Scan this QR on target device.";
        meSyncQrWrap.style.display = qr ? "block" : "none";
        meSyncQrImage.src = qr || "";
        meSyncCopyUri.disabled = !uri;
        meSyncExportCancel.disabled = false;
        startMeSyncExpireTimer();
      }

      async function importMeSyncByText(text) {
        const payloadText = String(text || "").trim();
        if (!payloadText) {
          showToast("Invalid me.sync payload", 1600);
          return;
        }
        let hasExisting = false;
        try {
          const sr = await fetch(API + "/me/sync/local_state");
          if (sr.ok) {
            const sd = await sr.json().catch(() => ({}));
            hasExisting = !!(sd && sd.has_existing_data);
          }
        } catch (_) {}
        const intro = "Import data from source device?";
        if (!await appConfirm("Import me.sync", intro)) return;
        if (hasExisting) {
          const wipeOk = await appConfirm(
            "Wipe existing data",
            "This import will wipe current local data first, then restore imported data. Continue?",
            { cancel: "Cancel", ok: "Wipe and Import", okClass: "danger" }
          );
          if (!wipeOk) return;
        }
        meSyncImport.disabled = true;
        showMeSyncImportModal("Starting import...");
        setTimeout(() => updateMeSyncImportPhase("Downloading package..."), 600);
        setTimeout(() => updateMeSyncImportPhase("Wiping existing data..."), 3000);
        setTimeout(() => updateMeSyncImportPhase("Restoring imported data..."), 6500);
        setTimeout(() => updateMeSyncImportPhase("Restarting local runtime..."), 10000);
        let timeoutId = 0;
        try {
          const maybeUrl = (/^https?:\/\//i.test(payloadText)) ? payloadText : "";
          const controller = new AbortController();
          timeoutId = setTimeout(() => {
            try { controller.abort(); } catch (_) {}
          }, 180000);
          const res = await fetch(API + "/me/sync/import", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ url: maybeUrl, payload: payloadText, wipe_existing: true }),
            signal: controller.signal,
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error(String(data.error || "import_failed"));
          meSyncStatus.textContent = "Import completed.";
          finishMeSyncImportModal(true, "Import completed.");
          showToast("me.sync import complete", 1800);
        } catch (e) {
          meSyncStatus.textContent = "Import failed.";
          const timedOut = String((e && e.name) || "") === "AbortError";
          finishMeSyncImportModal(false, timedOut ? "Import timed out. Check source and retry." : "Import failed. Please retry.");
          showToast("me.sync import failed", 2000);
        } finally {
          try { if (timeoutId) clearTimeout(timeoutId); } catch (_) {}
          meSyncImport.disabled = false;
        }
      }

      window.onMeSyncQrScanResult = async function(res) {
        try {
          const ok = !!(res && res.ok);
          const txt = ok ? String(res.text || "").trim() : "";
          if (!ok || !txt) return;
          await importMeSyncByText(txt);
        } catch (_) {}
      };

      window.uiHandleMeSyncDeepLink = async function(uriText) {
        const txt = String(uriText || "").trim();
        if (!txt) return;
        try { uiOpenSettingsSection("me_sync"); } catch (_) {}
        try { await importMeSyncByText(txt); } catch (_) {}
      };

      async function refreshAppInfo() {
        try {
          const res = await fetch(API + "/app/info");
          if (!res.ok) throw 0;
          const data = await res.json();
          const versionName = String(data.version_name || "").trim();
          const versionCode = String(data.version_code || "").trim();
          const gitSha = String(data.git_sha || "").trim();
          const commitUrl = String(data.commit_url || "").trim();
          const repoUrl = String(data.repo_url || "https://github.com/espresso3389/methings").trim();
          appVersionText.textContent = "Version: " + (versionName || "unknown") + (versionCode ? (" (code " + versionCode + ")") : "");
          appCommitLink.textContent = gitSha || "unknown";
          appCommitLink.href = commitUrl || repoUrl;
          appRepoLink.href = repoUrl;
          appRepoLink.textContent = repoUrl;
        } catch (_) {
          appVersionText.textContent = "Version: unavailable";
          appCommitLink.textContent = "unavailable";
          appCommitLink.href = "https://github.com/espresso3389/methings";
          appRepoLink.href = "https://github.com/espresso3389/methings";
          appRepoLink.textContent = "https://github.com/espresso3389/methings";
        }
      }

      async function refreshPython() {
        try {
          const res = await fetch(API + "/python/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(pythonStatus, data.status || "offline");
        } catch (_) {
          setStatus(pythonStatus, "offline");
        }
      }

      async function refreshSsh() {
        try {
          const res = await fetch(API + "/sshd/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(sshStatus, data.running ? "ok" : "offline");
          sshEnabled.checked = !!data.enabled;
          sshDetail.textContent = "ssh " + (data.host || "aaa.bbb.ccc.ddd") + " -p " + (data.port || 2222);
          if (data.client_key_fingerprint) {
            clientKeyFp.textContent = data.client_key_fingerprint;
            clientKeyRow.style.display = "block";
          } else {
            clientKeyRow.style.display = "none";
          }
          currentClientKeyPublic = data.client_key_public || "";
        } catch (_) {
          setStatus(sshStatus, "offline");
          sshDetail.textContent = "SSHD status unavailable";
          clientKeyRow.style.display = "none";
        }
      }

      function shortFp(fp) {
        const s = String(fp || "");
        if (s.length <= 16) return s;
        return s.slice(0, 8) + "…" + s.slice(-8);
      }

      function renderSshKeys(items) {
        if (!Array.isArray(items) || items.length === 0) {
          sshKeysList.innerHTML = "<div class='muted'>(no keys)</div>";
          return;
        }
        const rows = [];
        for (const it of items) {
          const fp = String(it.fingerprint || "");
          const label = String(it.label || "").trim();
          const unmanaged = !!it.unmanaged;
          const created = Number(it.created_at || 0);
          const exp = it.expires_at === null || typeof it.expires_at === "undefined" ? null : Number(it.expires_at);
          const createdStr = created ? (new Date(created)).toLocaleString() : "";
          const expStr = exp ? (new Date(exp)).toLocaleString() : "";
          const meta = [
            unmanaged ? "external (file-only)" : "",
            createdStr ? ("created " + createdStr) : "",
            expStr ? ("expires " + expStr) : ""
          ].filter(Boolean).join(" · ");
          rows.push(
            "<div style='display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid rgba(0,0,0,0.08);border-radius:10px;margin-top:8px;background:rgba(0,0,0,0.02);'>" +
              "<div style='flex:1;min-width:0;'>" +
                "<div style='display:flex;gap:8px;align-items:baseline;'>" +
                  "<span style='font-family:monospace;font-size:12px;opacity:0.85;'>" + esc(shortFp(fp)) + "</span>" +
                  (label ? ("<span class='muted' style='font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;'>" + esc(label) + "</span>") : "") +
                "</div>" +
                (meta ? ("<div class='muted' style='margin-top:2px;font-size:11px;'>" + esc(meta) + "</div>") : "") +
              "</div>" +
              (unmanaged
                ? "<button class='btn' disabled style='padding:5px 10px;font-size:12px;'>Unmanaged</button>"
                : "<button class='btn' data-fp=\"" + escAttr(fp) + "\" style='padding:5px 10px;font-size:12px;'>Remove</button>") +
            "</div>"
          );
        }
        sshKeysList.innerHTML = rows.join("");
        for (const btn of sshKeysList.querySelectorAll("button[data-fp]")) {
          btn.addEventListener("click", async () => {
            const fp = String(btn.getAttribute("data-fp") || "");
            if (!fp) return;
            if (!await appConfirm("Remove SSH key", "Remove this authorized key?")) return;
            try {
              const permission_id = await requestPermission("ssh_keys", "Remove SSH authorized key " + shortFp(fp));
              const res = await fetch(API + "/sshd/keys/delete", {
                method: "POST",
                headers: { "Content-Type": "application/json; charset=utf-8" },
                body: JSON.stringify({ permission_id, fingerprint: fp }),
              });
              if (!res.ok) throw 0;
              showToast("Key removed", 1400);
              await refreshSshKeys();
            } catch (_) {
              showToast("Remove failed", 1600);
            }
          });
        }
      }

      async function refreshSshKeys() {
        try {
          const res = await fetch(API + "/sshd/keys");
          if (!res.ok) throw 0;
          const data = await res.json();
          const items = Array.isArray(data.items) ? data.items : [];
          if (items.length) {
            renderSshKeys(items);
            return;
          }
          // Fallback: show file-only keys if the DB is empty (e.g., keys were edited via SSH).
          try {
            const fres = await fetch(API + "/user/file?path=" + encodeURIComponent(".ssh/authorized_keys"));
            if (!fres.ok) { renderSshKeys([]); return; }
            const txt = await fres.text().catch(() => "");
            const lines = String(txt || "").split("\n").map(s => s.trim()).filter(Boolean).filter(s => !s.startsWith("#"));
            const allowed = new Set([
              "ssh-ed25519",
              "ssh-rsa",
              "ecdsa-sha2-nistp256",
              "ecdsa-sha2-nistp384",
              "ecdsa-sha2-nistp521",
              "sk-ssh-ed25519@openssh.com",
              "sk-ecdsa-sha2-nistp256@openssh.com"
            ]);
            const parsed = [];
            for (const ln of lines) {
              const toks = ln.split(/\s+/);
              let idx = -1;
              for (let i = 0; i < toks.length - 1; i++) {
                if (allowed.has(String(toks[i] || "").toLowerCase())) { idx = i; break; }
              }
              if (idx < 0) continue;
              const type = toks[idx];
              const b64 = toks[idx + 1];
              const comment = (idx + 2 < toks.length) ? toks.slice(idx + 2).join(" ").trim() : "";
              const fp = "file:" + type + ":" + (b64 || "").slice(0, 16);
              parsed.push({ fingerprint: fp, label: comment, unmanaged: true });
            }
            renderSshKeys(parsed);
          } catch (_) {
            renderSshKeys([]);
          }
        } catch (_) {
          sshKeysList.innerHTML = "<div class='muted'>(keys unavailable)</div>";
        }
      }

      async function refreshPin() {
        try {
          const res = await fetch(API + "/sshd/pin/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.active) {
            pinExpiresAt = data.expires_at || null;
            if (!pinModal.classList.contains("show")) pinModal.classList.add("show");
            if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
            else if (lastPin && pinCode.textContent === "------") pinCode.textContent = lastPin;
            updatePinCountdown();
          } else {
            pinExpiresAt = null;
            pinBarFill.style.width = "0%";
            pinCountdown.textContent = "PIN inactive.";
            pinCode.textContent = "------";
            lastPin = null;
            if (pinModal.classList.contains("show")) {
              pinModal.classList.remove("show");
              await refreshSsh();
            }
          }
        } catch (_) {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN unavailable.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
        }
      }

      function updatePinCountdown() {
        if (!pinExpiresAt) {
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          return;
        }
        const rem = pinExpiresAt - Date.now();
        if (rem <= 0) {
          pinBarFill.style.width = "0%";
          pinExpiresAt = null;
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
          return;
        }
        pinCountdown.textContent = "Active (" + Math.ceil(rem / 1000) + "s)";
        pinBarFill.style.width = Math.round(Math.max(0, Math.min(1, rem / pinDurationMs)) * 100) + "%";
      }

      // ==============================
      // Permissions prefs
      // ==============================
      let permissionsRemember = true;
      let permissionsDangerSkip = false;
      async function loadPermissionPrefs() {
        try {
          const res = await fetch(API + "/permissions/prefs");
          if (!res.ok) throw 0;
          const data = await res.json();
          permissionsRemember = !!data.remember_approvals;
          permissionsDangerSkip = !!data.dangerously_skip_permissions;
          $("permRemember").checked = permissionsRemember;
          $("permDangerSkip").checked = permissionsDangerSkip;
        } catch (_) {
          permissionsRemember = true;
          permissionsDangerSkip = false;
          $("permRemember").checked = true;
          $("permDangerSkip").checked = false;
        }
      }

      async function requestPermission(tool, detail) {
        const res = await fetch(API + "/permissions/request", {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify({ tool, detail, scope: (permissionsRemember ? "persistent" : "once") }),
        });
        if (!res.ok) throw new Error("permission request failed");
        const data = await res.json();
        if (data.status === "approved") return data.id;
        const deadline = Date.now() + 30000;
        while (Date.now() < deadline) {
          await new Promise(r => setTimeout(r, 500));
          try {
            const sr = await fetch(API + "/permissions/" + data.id);
            if (!sr.ok) continue;
            const sd = await sr.json();
            if (sd.status === "approved") return data.id;
            if (sd.status === "denied") throw new Error("permission denied");
          } catch (_) {}
        }
        throw new Error("permission timeout");
      }

      // Python Packages UI removed.

      $("permRemember").addEventListener("change", async () => {
        const enabled = !!$("permRemember").checked;
        const prevRemember = permissionsRemember;
        permissionsRemember = enabled;
        try {
          const res = await fetch(API + "/permissions/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({
              remember_approvals: enabled,
              dangerously_skip_permissions: permissionsDangerSkip,
            }),
          });
          if (!res.ok) throw 0;
          const data = await res.json().catch(() => ({}));
          permissionsRemember = !!data.remember_approvals;
          permissionsDangerSkip = !!data.dangerously_skip_permissions;
          $("permRemember").checked = permissionsRemember;
          $("permDangerSkip").checked = permissionsDangerSkip;
          showToast("Permission preference saved", 1500);
        } catch (_) {
          permissionsRemember = prevRemember;
          $("permRemember").checked = prevRemember;
          showToast("Failed to save preference", 2000);
        }
      });
      $("permDangerSkip").addEventListener("change", async () => {
        const enabled = !!$("permDangerSkip").checked;
        const prevDanger = permissionsDangerSkip;
        if (enabled) {
          const ok = await appConfirm(
            "Enable dangerous mode",
            "This will auto-approve every permission request without prompting. Continue?"
          );
          if (!ok) {
            $("permDangerSkip").checked = false;
            return;
          }
        }
        permissionsDangerSkip = enabled;
        try {
          const res = await fetch(API + "/permissions/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({
              remember_approvals: permissionsRemember,
              dangerously_skip_permissions: enabled,
            }),
          });
          if (!res.ok) throw 0;
          const data = await res.json().catch(() => ({}));
          permissionsRemember = !!data.remember_approvals;
          permissionsDangerSkip = !!data.dangerously_skip_permissions;
          $("permRemember").checked = permissionsRemember;
          $("permDangerSkip").checked = permissionsDangerSkip;
          showToast("Dangerous permission mode " + (permissionsDangerSkip ? "enabled" : "disabled"), 1800);
        } catch (_) {
          permissionsDangerSkip = prevDanger;
          $("permDangerSkip").checked = prevDanger;
          showToast("Failed to save preference", 2000);
        }
      });
      $("permClear").addEventListener("click", async () => {
        if (!await appConfirm("Clear approvals", "Clear all saved tool approvals?")) return;
        try {
          const res = await fetch(API + "/permissions/clear", { method: "POST" });
          if (!res.ok) throw 0;
          showToast("Saved approvals cleared", 1800);
        } catch (_) {
          showToast("Failed to clear approvals", 2000);
        }
      });

      async function loadCloudPrefs() {
        try {
          const res = await fetch(API + "/cloud/prefs");
          if (!res.ok) throw 0;
          const data = await res.json().catch(() => ({}));
          const v = Number(data.auto_upload_no_confirm_mb);
          $("cloudAutoUploadMb").value = (isFinite(v) ? String(v) : "1.0");
          const k = Number(data.min_transfer_kbps);
          $("cloudMinKbps").value = (isFinite(k) ? String(k) : "0");
          $("cloudImgResizeEnabled").checked = !!data.image_resize_enabled;
          const md = Number(data.image_resize_max_dim_px);
          $("cloudImgMaxDim").value = (isFinite(md) ? String(md) : "512");
          const q = Number(data.image_resize_jpeg_quality);
          $("cloudImgJpegQ").value = (isFinite(q) ? String(q) : "70");
        } catch (_) {
          $("cloudAutoUploadMb").value = "1.0";
          $("cloudMinKbps").value = "0";
          $("cloudImgResizeEnabled").checked = true;
          $("cloudImgMaxDim").value = "512";
          $("cloudImgJpegQ").value = "70";
        }
      }

      $("cloudPrefsSave").addEventListener("click", async () => {
        const raw = String($("cloudAutoUploadMb").value || "").trim();
        const v = parseFloat(raw);
        if (!isFinite(v) || v < 0) { showToast("Enter a valid number", 1600); return; }
        const rawK = String($("cloudMinKbps").value || "").trim();
        const k = parseFloat(rawK);
        if (!isFinite(k) || k < 0) { showToast("Enter a valid number", 1600); return; }
        const enabled = !!$("cloudImgResizeEnabled").checked;
        const md = parseInt(String($("cloudImgMaxDim").value || "").trim() || "512", 10);
        if (!Number.isFinite(md) || md < 64) { showToast("Enter a valid max dim", 1600); return; }
        const q = parseInt(String($("cloudImgJpegQ").value || "").trim() || "70", 10);
        if (!Number.isFinite(q) || q < 30) { showToast("Enter a valid JPEG quality", 1600); return; }
        try {
          const res = await fetch(API + "/cloud/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({
              auto_upload_no_confirm_mb: v,
              min_transfer_kbps: k,
              image_resize_enabled: enabled,
              image_resize_max_dim_px: md,
              image_resize_jpeg_quality: q,
            }),
          });
          if (!res.ok) throw 0;
          showToast("Cloud prefs saved", 1600);
        } catch (_) {
          showToast("Failed to save cloud prefs", 1800);
        }
      });

      // Task completion notification prefs
      function loadNotifyPrefs() {
        try {
          if (typeof AndroidBridge === "undefined") return;
          $("notifyAndroid").checked = !!AndroidBridge.getTaskCompleteNotifyAndroid();
          $("notifySound").checked = !!AndroidBridge.getTaskCompleteNotifySound();
          $("notifyWebhookUrl").value = AndroidBridge.getTaskCompleteWebhookUrl() || "";
        } catch (_) {}
      }
      $("notifySave").addEventListener("click", () => {
        try {
          if (typeof AndroidBridge === "undefined") { showToast("Not available", 1600); return; }
          AndroidBridge.setTaskCompleteNotifyAndroid(!!$("notifyAndroid").checked);
          AndroidBridge.setTaskCompleteNotifySound(!!$("notifySound").checked);
          AndroidBridge.setTaskCompleteWebhookUrl($("notifyWebhookUrl").value || "");
          showToast("Notification prefs saved", 1600);
        } catch (_) {
          showToast("Failed to save notification prefs", 1800);
        }
      });

      // Audio recording config prefs
      function loadAudioRecSettings() {
        try {
          if (typeof AndroidBridge === "undefined") return;
          $("audioRecSampleRate").value = String(AndroidBridge.getAudioRecordSampleRate() || 44100);
          $("audioRecChannels").value = String(AndroidBridge.getAudioRecordChannels() || 1);
          $("audioRecBitrate").value = String(AndroidBridge.getAudioRecordBitrate() || 128000);
          $("audioRecMaxDuration").value = AndroidBridge.getAudioRecordMaxDurationS() || 300;
        } catch (_) {}
      }
      $("audioRecSave").addEventListener("click", () => {
        try {
          if (typeof AndroidBridge === "undefined") { showToast("Not available", 1600); return; }
          AndroidBridge.setAudioRecordSampleRate(parseInt($("audioRecSampleRate").value) || 44100);
          AndroidBridge.setAudioRecordChannels(parseInt($("audioRecChannels").value) || 1);
          AndroidBridge.setAudioRecordBitrate(parseInt($("audioRecBitrate").value) || 128000);
          AndroidBridge.setAudioRecordMaxDurationS(parseInt($("audioRecMaxDuration").value) || 300);
          showToast("Audio recording settings saved", 1600);
        } catch (_) {
          showToast("Failed to save audio recording settings", 1800);
        }
      });

      // Video recording config prefs
      function loadVideoRecSettings() {
        try {
          if (typeof AndroidBridge === "undefined") return;
          $("videoRecResolution").value = AndroidBridge.getVideoRecordResolution() || "720p";
          $("videoRecCodec").value = AndroidBridge.getVideoRecordCodec() || "h265";
          $("videoRecMaxDuration").value = AndroidBridge.getVideoRecordMaxDurationS() || 300;
        } catch (_) {}
      }
      $("videoRecSave").addEventListener("click", () => {
        try {
          if (typeof AndroidBridge === "undefined") { showToast("Not available", 1600); return; }
          AndroidBridge.setVideoRecordResolution($("videoRecResolution").value || "720p");
          AndroidBridge.setVideoRecordCodec($("videoRecCodec").value || "h265");
          AndroidBridge.setVideoRecordMaxDurationS(parseInt($("videoRecMaxDuration").value) || 300);
          showToast("Video recording settings saved", 1600);
        } catch (_) {
          showToast("Failed to save video recording settings", 1800);
        }
      });

      $("restartPython").addEventListener("click", async () => {
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.restartPythonWorker) {
          AndroidBridge.restartPythonWorker();
        } else {
          await fetch(API + "/python/restart", { method: "POST" });
        }
        pythonDetail.textContent = "Restart requested";
        setStatus(pythonStatus, "starting");
      });

      $("openAppSettings").addEventListener("click", () => {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.openAppDetailsSettings) {
            AndroidBridge.openAppDetailsSettings();
            return;
          }
        } catch (_) {}
        showToast("Not available on this build", 1600);
      });

      $("openOpenByDefault").addEventListener("click", () => {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.openAppOpenByDefaultSettings) {
            AndroidBridge.openAppOpenByDefaultSettings();
            return;
          }
        } catch (_) {}
        showToast("Not available on this build", 1600);
      });

      // Browser link prefs
      function loadBrowserPrefs() {
        try {
          if (typeof AndroidBridge === "undefined") return;
          $("openLinksExternal").checked = !!AndroidBridge.getOpenLinksExternal();
        } catch (_) {}
      }
      $("openLinksExternal").addEventListener("change", () => {
        try {
          if (typeof AndroidBridge === "undefined") { showToast("Not available", 1600); return; }
          AndroidBridge.setOpenLinksExternal(!!$("openLinksExternal").checked);
        } catch (_) {
          showToast("Failed to save browser pref", 1800);
        }
      });

      $("resetUi").addEventListener("click", async () => {
        if (!await appConfirm("Reset UI", "Reset UI to defaults? This will overwrite any local changes.")) return;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUiToDefaults) {
          AndroidBridge.resetUiToDefaults();
        }
      });

      $("resetAgentDocs").addEventListener("click", async () => {
        if (!await appConfirm("Reset agent docs", "Reset AGENTS.md / TOOLS.md / docs/ to defaults? This will overwrite those files.")) return;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUserDefaultsToDefaults) {
          AndroidBridge.resetUserDefaultsToDefaults();
        } else {
          showToast("Reset not available", 1600);
        }
      });

      checkAppUpdate.addEventListener("click", async () => {
        await refreshAppUpdate(false);
      });

      openInstallUnknownSources.addEventListener("click", async () => {
        const permitted = await ensureInstallPermissionBeforeInstall();
        if (permitted) {
          showToast("Install permission granted", 1600);
          await refreshAppUpdate(false);
        }
      });

      installAppUpdate.addEventListener("click", async () => {
        if (appUpdateInfo && appUpdateInfo.update_enabled === false) {
          showToast("Auto update is disabled for this build", 1800);
          return;
        }
        if (!appUpdateInfo || !appUpdateInfo.has_update) {
          await refreshAppUpdate(false);
          if (appUpdateInfo && appUpdateInfo.update_enabled === false) {
            showToast("Auto update is disabled for this build", 1800);
            return;
          }
          if (!appUpdateInfo || !appUpdateInfo.has_update) {
            showToast("Already up to date", 1400);
            return;
          }
        }
        if (!await appConfirm("Install update", "Download and install " + String(appUpdateInfo.latest_tag || "latest") + "?", { cancel: "Later", ok: "Install Now", okClass: "primary" })) return;
        const permitted = await ensureInstallPermissionBeforeInstall();
        if (!permitted) return;
        await installLatestUpdate();
      });

      async function runMeSyncExportFlow() {
        meSyncPrepareExport.disabled = true;
        const exp = Number((meSyncActiveExport && meSyncActiveExport.expires_at) || 0);
        if (
          meSyncActiveExport &&
          exp > Date.now() &&
          String(meSyncActiveExport.me_sync_uri || "").trim() &&
          String(meSyncActiveExport.qr_data_url || "").trim()
        ) {
          showMeSyncExportModal(false);
          meSyncPrepareExport.disabled = false;
          return;
        }
        const controller = new AbortController();
        meSyncExportReq = controller;
        showMeSyncExportModal(true);
        try {
          let permission_id = "";
          try {
            const ssr = await fetch(API + "/sshd/status", { signal: controller.signal });
            const ssd = await ssr.json().catch(() => ({}));
            const needTempSshd = !!ssr.ok && !ssd.enabled && !ssd.running;
            if (needTempSshd) {
              permission_id = await requestPermission("device.me_sync", "Temporarily enable SSHD for me.sync export");
            }
          } catch (_) {}
          const res = await fetch(API + "/me/sync/prepare_export", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({
              include_user: true,
              include_protected_db: true,
              include_identity: false,
              mode: "export",
              permission_id,
            }),
            signal: controller.signal,
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error(String(data.error || "prepare_failed"));
          meSyncActiveExport = data || null;
          meSyncStatus.textContent = "Export prepared.";
          showMeSyncExportModal(false);
        } catch (e) {
          if (String((e && e.name) || "") === "AbortError") {
            meSyncStatus.textContent = "Export cancelled.";
            closeMeSyncModal();
          } else {
            meSyncStatus.textContent = "Export failed.";
            meSyncModalStatus.textContent = "Export failed.";
            stopMeSyncPrepareTimer();
            meSyncPrepareWrap.style.display = "none";
            meSyncQrWrap.style.display = "none";
            showToast("me.sync export failed", 1800);
          }
        } finally {
          meSyncExportReq = null;
          meSyncPrepareExport.disabled = false;
          await refreshMeSyncStatus();
        }
      }

      window.uiShowMeSyncExport = async function() {
        try {
          await runMeSyncExportFlow();
        } catch (_) {
          showToast("me.sync export failed", 1800);
        }
      };

      meSyncPrepareExport.addEventListener("click", async () => {
        await runMeSyncExportFlow();
      });

      meSyncImport.addEventListener("click", async () => {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.scanMeSyncQr) {
            AndroidBridge.scanMeSyncQr();
          } else {
            const txt = await appPrompt("Import me.sync", "Paste me.sync URI (me.things:me.sync:...)");
            if (!txt) return;
            await importMeSyncByText(txt);
          }
        } catch (_) {
          showToast("QR scan unavailable", 1600);
        }
      });

      meSyncModalClose.addEventListener("click", () => {
        closeMeSyncModal();
      });

      meSyncImportModalClose.addEventListener("click", () => {
        closeMeSyncImportModal(false);
      });

      meSyncExportCancel.addEventListener("click", () => {
        try {
          if (meSyncExportReq) {
            meSyncExportReq.abort();
            meSyncExportReq = null;
          } else {
            closeMeSyncModal();
          }
        } finally {
          meSyncPrepareExport.disabled = false;
        }
      });

      meSyncCopyUri.addEventListener("click", async () => {
        const text = String((meSyncActiveExport && meSyncActiveExport.me_sync_uri) || "").trim();
        if (!text) return;
        try {
          await navigator.clipboard.writeText(text);
          showToast("URI copied", 1400);
        } catch (_) {
          showToast("Copy failed", 1600);
        }
      });

      openLicensesPage.addEventListener("click", () => {
        location.hash = "licenses";
      });

      shareAppBtn.addEventListener("click", () => {
        if (window.AndroidBridge && AndroidBridge.shareApp) {
          AndroidBridge.shareApp();
        }
      });

      async function updateSshConfig() {
        const enabled = sshEnabled.checked;
        try {
          const res = await fetch(API + "/sshd/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ enabled }),
          });
          if (!res.ok) throw 0;
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to apply SSHD settings";
        }
      }

      sshEnabled.addEventListener("change", updateSshConfig);
      sshKeysRefresh.addEventListener("click", refreshSshKeys);
      sshKeysAdd.addEventListener("click", async () => {
        const key = String(await appPrompt("Add SSH key", "Paste the public key (one line)", "") || "").trim();
        if (!key) return;
        const label = String(await appPrompt("Key label", "Label (optional)", "") || "").trim();
        try {
          const permission_id = await requestPermission("ssh_keys", "Add SSH authorized key" + (label ? (" (" + label + ")") : ""));
          const res = await fetch(API + "/sshd/keys/add", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, key, label }),
          });
          if (!res.ok) {
            const t = await res.text().catch(() => "");
            throw new Error(t || "failed");
          }
          showToast("Key added", 1400);
          await refreshSshKeys();
        } catch (_) {
          showToast("Add failed", 1600);
        }
      });
      authNotification.addEventListener("click", async () => {
        sshDetail.textContent = "Enabling notification auth...";
        try {
          // Always require biometric for enabling auth modes.
          const u = await requestSettingsUnlock();
          if (!u || !u.ok) { showToast("Unlock failed", 1400); return; }
          const permission_id = await requestPermission("ssh_noauth", "Enable SSH notification auth");
          const res = await fetch(API + "/sshd/noauth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 30 }),
          });
          if (!res.ok) throw 0;
          sshDetail.textContent = "Notification auth enabled";
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to enable notification auth";
        }
      });
      authPin.addEventListener("click", async () => {
        try {
          pinCode.textContent = "\u2022\u2022\u2022\u2022\u2022\u2022";
          pinCountdown.textContent = "Generating PIN...";
          pinBarFill.style.width = "0%";
          pinModal.classList.add("show");
          // Always require biometric for enabling auth modes.
          const u = await requestSettingsUnlock();
          if (!u || !u.ok) { showToast("Unlock failed", 1400); pinModal.classList.remove("show"); return; }
          const permission_id = await requestPermission("ssh_pin", "Enable SSH PIN auth");
          const res = await fetch(API + "/sshd/pin/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 20 }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
          else if (lastPin) pinCode.textContent = lastPin;
          else pinCode.textContent = "PIN unavailable";
          pinModal.classList.add("show");
          pinExpiresAt = data.expires_at || (Date.now() + pinDurationMs);
          updatePinCountdown();
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to start PIN auth";
        }
      });

      copyClientKey.addEventListener("click", async () => {
        if (!currentClientKeyPublic) return;
        try {
          await navigator.clipboard.writeText(currentClientKeyPublic);
          copyClientKey.textContent = "Copied!";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        } catch (_) {
          copyClientKey.textContent = "Failed";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        }
      });

      pinClose.addEventListener("click", async () => {
        try {
          await fetch(API + "/sshd/pin/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({}),
          });
          await refreshPin();
          await refreshSsh();
        } catch (_) {
        } finally {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          lastPin = null;
          pinModal.classList.remove("show");
        }
      });

      // Agent console initial load (stubs removed; kept as no-ops for safety).
      refreshSshKeys();

      window.onPythonStatus = function(status) {
        setStatus(pythonStatus, status);
      };

      // When viewed in a normal browser (not Android WebView), open external
      // links in a new tab so the UI page is not navigated away.
      if (typeof AndroidBridge === "undefined") {
        document.addEventListener("click", function(e) {
          var a = e.target.closest("a[href]");
          if (!a) return;
          var href = a.getAttribute("href") || "";
          if (/^https?:\/\//i.test(href)) {
            e.preventDefault();
            window.open(href, "_blank", "noopener,noreferrer");
          }
        });
      }

      loadPermissionPrefs();
      loadCloudPrefs();
      loadNotifyPrefs();
      loadAudioRecSettings();
      loadVideoRecSettings();
      loadBrowserPrefs();
      refreshPython();
      updateAppUpdateButtons();
      refreshAppUpdate(true);
      refreshMeSyncStatus();
      refreshAppInfo();
      refreshSsh();
      refreshPin();
      setInterval(refreshPython, 5000);
      setInterval(refreshSsh, 5000);
      setInterval(refreshMeSyncStatus, 5000);
      setInterval(updateMeSyncSectionCountdown, 1000);
      setInterval(refreshPin, 1000);
      setInterval(updatePinCountdown, 1000);
    </script>
  </body>
</html>
