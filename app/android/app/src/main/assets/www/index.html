<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Kugutz</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f5f2ea;
        --ink: #2a2a2a;
        --muted: #6b6b6b;
        --card: #fff7e8;
        --accent: #2e7d32;
        --danger: #c62828;
        --warn: #8d6e63;
        --border: #e0d8cb;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Georgia", "Times New Roman", serif;
        background: var(--bg);
        color: var(--ink);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* --- Pages --- */
      .page { display: none; flex: 1; flex-direction: column; overflow: hidden; }
      .page.active { display: flex; }

      /* --- Top bar --- */
      .topbar {
        flex-shrink: 0;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px 0 14px;
        border-bottom: 1px solid var(--border);
        background: var(--card);
      }
      .topbar .title {
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .icon-btn {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255,255,255,0.65);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 18px;
      }
      .icon-btn:active { transform: scale(0.98); }
      .icon-btn.secondary {
        background: transparent;
      }

      /* --- Chat page --- */
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px 16px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        -webkit-overflow-scrolling: touch;
      }
      .chat-welcome {
        text-align: center;
        color: var(--muted);
        margin-top: 30vh;
        font-size: 15px;
        line-height: 1.5;
      }
      .chat-welcome strong { color: var(--ink); }
      .msg {
        max-width: 88%;
        padding: 10px 14px;
        border-radius: 16px;
        line-height: 1.55;
        word-wrap: break-word;
        overflow-wrap: anywhere;
        font-size: 15px;
      }
      .msg.user {
        align-self: flex-end;
        background: var(--accent);
        color: white;
        border-bottom-right-radius: 4px;
      }
      .msg.assistant {
        align-self: flex-start;
        background: var(--card);
        box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        border-bottom-left-radius: 4px;
      }
      .msg.error {
        align-self: center;
        background: #fce4ec;
        color: var(--danger);
        font-size: 13px;
        border-radius: 10px;
      }

      /* Markdown in messages */
      .msg pre {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 10px 12px;
        border-radius: 8px;
        overflow-x: auto;
        white-space: pre;
        font-family: "Menlo", "Consolas", monospace;
        font-size: 13px;
        margin: 6px 0;
        line-height: 1.4;
      }
      .msg.user pre { background: rgba(0,0,0,0.2); color: #fff; }
      .msg code:not(pre code) {
        background: rgba(0,0,0,0.07);
        padding: 1px 5px;
        border-radius: 4px;
        font-family: "Menlo", "Consolas", monospace;
        font-size: 0.88em;
      }
      .msg.user code:not(pre code) { background: rgba(255,255,255,0.2); }
      .msg p { margin: 4px 0; }
      .msg ul, .msg ol { margin: 4px 0; padding-left: 20px; }
      .msg li { margin: 2px 0; }
      .msg blockquote {
        border-left: 3px solid var(--border);
        margin: 6px 0;
        padding: 2px 0 2px 12px;
        color: var(--muted);
      }

      /* Chat input */
      .chat-input-area {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        padding: 10px 16px 12px;
        border-top: 1px solid var(--border);
        background: var(--bg);
        flex-shrink: 0;
      }
      .chat-input-area textarea {
        flex: 1;
        border: 1px solid #d4c9b5;
        border-radius: 14px;
        padding: 10px 14px;
        font-family: inherit;
        font-size: 15px;
        resize: none;
        background: var(--card);
        min-height: 42px;
        max-height: 120px;
        line-height: 1.4;
        outline: none;
      }
      .chat-input-area textarea:focus { border-color: var(--accent); }
      .chat-input-area button {
        border: none;
        border-radius: 50%;
        width: 42px;
        height: 42px;
        background: var(--accent);
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .chat-input-area button:disabled { opacity: 0.5; cursor: default; }
      .chat-mode {
        display: flex;
        align-items: center;
      }
      .chat-mode select {
        border: 1px solid #d4c9b5;
        border-radius: 10px;
        background: var(--card);
        color: var(--ink);
        font-family: inherit;
        font-size: 13px;
        padding: 8px 10px;
        outline: none;
      }

      /* --- Settings page --- */
      .settings-header {
        padding: 16px 20px 8px;
        font-size: 22px;
        font-weight: 700;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
        padding: 10px 20px 28px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      .card {
        background: var(--card);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 4px 14px rgba(0,0,0,0.05);
      }
      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }
      .label { font-weight: 700; }
      .status { font-weight: 700; }
      .status.ok { color: var(--accent); }
      .status.offline { color: var(--danger); }
      .status.starting { color: #616161; }
      .status.stopping { color: var(--warn); }
      button.btn {
        border: none;
        border-radius: 999px;
        padding: 10px 14px;
        font-weight: 700;
        cursor: pointer;
        background: #ece3d4;
        color: var(--ink);
        font-family: inherit;
        font-size: 14px;
      }
      button.btn.primary { background: var(--accent); color: white; }
      button.btn.danger { background: var(--danger); color: white; }
      .muted { color: var(--muted); font-size: 14px; word-break: break-word; overflow-wrap: anywhere; }
      .field { margin-top: 10px; }
      .field label { display: block; color: var(--muted); font-size: 13px; margin-bottom: 4px; }
      .field select {
        width: 100%;
        padding: 9px 12px;
        border: 1px solid #d4c9b5;
        border-radius: 10px;
        font-family: inherit;
        font-size: 14px;
        background: var(--bg);
        outline: none;
        appearance: auto;
      }
      .field select:focus { border-color: var(--accent); }
      .field input[type="text"],
      .field input[type="url"],
      .field input[type="password"] {
        width: 100%;
        padding: 9px 12px;
        border: 1px solid #d4c9b5;
        border-radius: 10px;
        font-family: inherit;
        font-size: 14px;
        background: var(--bg);
        outline: none;
      }
      .field input:focus { border-color: var(--accent); }

      /* PIN modal */
      .pin-bar { width: 100%; height: 8px; background: #e6dccb; border-radius: 999px; overflow: hidden; }
      .pin-bar-fill { height: 100%; width: 0%; background: var(--accent); transition: width 0.2s ease; }
      .modal {
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.45);
        display: none; align-items: center; justify-content: center;
        padding: 20px; z-index: 999;
      }
      .modal.show { display: flex; }
      .modal-card {
        width: 100%; max-width: 360px;
        background: var(--card);
        border-radius: 16px; padding: 18px;
        box-shadow: 0 12px 28px rgba(0,0,0,0.2);
      }
      .pin-code { font-size: 28px; font-weight: 700; letter-spacing: 2px; margin: 8px 0; }

      /* Toast */
      .toast {
        position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
        background: var(--ink); color: white; padding: 10px 20px;
        border-radius: 10px; font-size: 14px;
        opacity: 0; transition: opacity 0.3s;
        pointer-events: none; z-index: 1000;
      }
      .toast.show { opacity: 1; }

      @media (max-width: 640px) {
        .grid { padding: 8px 16px 24px; }
        .card { padding: 14px; }
        .row { justify-content: flex-start; }
        .row button.btn { width: 100%; }
      }
      @media (min-width: 720px) {
        .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      }
    </style>
  </head>
  <body>
    <!-- ===== Chat Page ===== -->
    <div id="chatPage" class="page active">
      <div class="topbar">
        <div class="title">Kugutz</div>
        <button class="icon-btn" id="openSettingsBtn" title="Settings" aria-label="Settings">&#9881;</button>
      </div>
      <div class="chat-messages" id="chatMessages">
        <div class="chat-welcome" id="chatWelcome">
          <strong>Kugutz Brain</strong><br>
          Configure your AI provider in Settings,<br>then start chatting.
        </div>
      </div>
      <div class="chat-input-area">
        <div class="chat-mode">Agent</div>
        <textarea id="chatInput" placeholder="Message..." rows="1"></textarea>
        <button id="chatSend" title="Send">&#9654;</button>
      </div>
    </div>

    <!-- ===== Settings Page ===== -->
    <div id="settingsPage" class="page">
      <div class="topbar">
        <button class="icon-btn secondary" id="backToChatBtn" title="Back" aria-label="Back">&#8592;</button>
        <div class="title">Settings</div>
        <div style="width:36px;"></div>
      </div>
      <div class="grid">
        <!-- Brain Config -->
        <section class="card">
          <div class="label">Brain</div>
          <div class="field">
            <label>Model</label>
            <select id="brainVendorModel">
              <option value="" disabled>Choose a model...</option>
              <optgroup label="OpenAI">
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2-codex">GPT-5.2 Codex</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2">GPT-5.2</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.1-codex-mini">GPT-5.1 Codex Mini</option>
              </optgroup>
              <optgroup label="Anthropic">
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-opus-4-6">Claude Opus 4.6</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-sonnet-4-5">Claude Sonnet 4.5</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-haiku-4-5">Claude Haiku 4.5</option>
              </optgroup>
              <option data-vendor="custom" value="custom">Custom...</option>
            </select>
          </div>
          <div id="brainCustomFields" style="display:none;">
            <div class="field">
              <label>Base URL</label>
              <input type="url" id="brainBaseUrl" placeholder="https://api.openai.com/v1" />
            </div>
            <div class="field">
              <label>Model ID</label>
              <input type="text" id="brainModelId" placeholder="gpt-5.2" />
            </div>
          </div>
          <div class="field">
            <label>API Key (plaintext)</label>
            <input type="text" id="brainApiKey" placeholder="(locked)" />
            <div class="muted" id="brainKeyStatus" style="margin-top:4px;"></div>
          </div>
          <div style="margin-top:12px;">
            <button class="btn primary" id="brainSave">Save</button>
          </div>
        </section>

        <!-- Web Search -->
        <section class="card">
          <div class="label">Web Search</div>
          <div class="muted" style="margin:4px 0 10px;">
            Default provider is DuckDuckGo. Brave Search is used only when an API key is configured here.
          </div>
          <div class="field">
            <label>Brave Search API Key (plaintext)</label>
            <input type="text" id="braveSearchApiKey" placeholder="(locked)" />
            <div class="muted" id="braveSearchKeyStatus" style="margin-top:4px;">Status unknown.</div>
          </div>
          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn primary" id="braveSearchSave">Save</button>
            <button class="btn" id="braveSearchClear">Clear</button>
            <button class="btn" id="braveSearchCheck">Check</button>
          </div>
        </section>

        <!-- Memory -->
        <section class="card">
          <div class="label">Memory</div>
          <div class="muted" style="margin:4px 0 8px;">Persistent notes the AI remembers across conversations.</div>
          <textarea id="memoryEditor"
            style="width:100%;min-height:120px;max-height:300px;border:1px solid #d4c9b5;
                   border-radius:10px;padding:10px 12px;font-family:'Menlo','Consolas',monospace;
                   font-size:13px;background:var(--bg);resize:vertical;outline:none;box-sizing:border-box;"
            placeholder="(empty -- the AI or you can add notes here)"></textarea>
          <div style="margin-top:10px;display:flex;gap:8px;">
            <button class="btn primary" id="memorySave">Save</button>
            <button class="btn" id="memoryClear">Clear</button>
          </div>
        </section>

        <!-- SSHD -->
        <section class="card">
          <div class="row">
            <div>
              <div class="label">SSHD</div>
              <div id="sshStatus" class="status starting">checking</div>
            </div>
          </div>
          <div class="row" style="margin-top:12px;">
            <label><input type="checkbox" id="sshEnabled" /> Enable SSHD</label>
          </div>
          <div class="row" style="margin-top:8px;">
            <button class="btn" id="authNotification">Notification</button>
            <button class="btn" id="authPin">PIN</button>
          </div>
          <p class="muted" id="sshDetail">Waiting for status...</p>
          <div id="clientKeyRow" style="display:none;margin-top:8px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="muted" style="font-family:monospace;font-size:12px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" id="clientKeyFp"></span>
              <button class="btn" id="copyClientKey" style="padding:6px 10px;font-size:12px;min-width:auto;width:auto;">Copy</button>
            </div>
          </div>
        </section>

        <!-- Python Worker -->
        <section class="card">
          <div class="row">
            <div>
              <div class="label">Python Worker</div>
              <div id="pythonStatus" class="status offline">offline</div>
            </div>
          </div>
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="restartPython">Restart</button>
          </div>
          <p class="muted" id="pythonDetail">Emergency restart only.</p>
        </section>

        <!-- Python Packages -->
        <section class="card">
          <div class="label">Python Packages</div>
          <div class="muted" style="margin:4px 0 10px;">
            Download wheels into an on-device cache, then install offline. Source builds are typically not supported on Android.
          </div>
          <div class="field">
            <label>Package spec</label>
            <input type="text" id="pipSpec" placeholder="e.g. pyusb requests==2.32.3" />
          </div>
          <div class="row" style="margin-top:8px;gap:14px;flex-wrap:wrap;">
            <label><input type="checkbox" id="pipWithDeps" checked /> Include dependencies</label>
            <label><input type="checkbox" id="pipOnlyBinary" checked /> Wheels only</label>
          </div>
          <div class="field" style="margin-top:10px;">
            <label>Index URL (optional)</label>
            <input type="url" id="pipIndexUrl" placeholder="https://pypi.org/simple" />
          </div>
          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn" id="pipDownload">Download wheels</button>
            <button class="btn primary" id="pipInstallOffline">Install (offline)</button>
            <button class="btn" id="pipInstallNet">Install (network)</button>
          </div>
          <pre id="pipStatus" class="muted" style="margin-top:10px;white-space:pre-wrap;"></pre>
          <pre id="pipOutput"
               style="margin-top:10px;white-space:pre-wrap;font-family:'Menlo','Consolas',monospace;
                      font-size:12px;background:var(--bg);border:1px solid #d4c9b5;border-radius:10px;
                      padding:10px 12px;max-height:220px;overflow:auto;"></pre>
        </section>

        <!-- UI Maintenance -->
        <section class="card">
          <div class="row">
            <div>
              <div class="label">UI Maintenance</div>
              <div class="muted">Reset the UI files to defaults.</div>
            </div>
            <button class="btn" id="resetUi">Reset UI</button>
          </div>
        </section>

        <!-- Permissions -->
        <section class="card">
          <div class="label">Permissions</div>
          <div class="muted" style="margin:4px 0 10px;">
            If enabled, tool approvals are remembered (until you clear them), similar to Android runtime permissions.
          </div>
          <div class="row" style="margin-top:8px;">
            <label><input type="checkbox" id="permRemember" /> Remember approvals</label>
          </div>
          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn" id="permClear">Clear saved approvals</button>
          </div>
        </section>
      </div>
    </div>

    <!-- PIN Modal -->
    <div class="modal" id="pinModal" role="dialog" aria-modal="true" aria-labelledby="pinTitle">
      <div class="modal-card">
        <div class="label" id="pinTitle">PIN auth</div>
        <div class="pin-code" id="pinCode">------</div>
        <div class="muted" id="pinCountdown">PIN inactive.</div>
        <div class="pin-bar" aria-hidden="true" style="margin:10px 0 16px;">
          <div id="pinBarFill" class="pin-bar-fill"></div>
        </div>
        <button class="btn danger" id="pinClose">End PIN</button>
      </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
      // ==============================
      // Helpers
      // ==============================
      const API = "http://127.0.0.1:8765";
      function $(id) { return document.getElementById(id); }

      function showToast(msg, ms) {
        const t = $("toast");
        t.textContent = msg;
        t.classList.add("show");
        setTimeout(() => t.classList.remove("show"), ms || 2000);
      }

      // ==============================
      // Router
      // ==============================
      function navigateTo(pageId) {
        document.querySelectorAll(".page").forEach(p => p.classList.remove("active"));
        $(pageId).classList.add("active");
      }
      function handleHash() {
        const h = location.hash.replace("#", "") || "chat";
        if (h === "settings") {
          guardedOpenSettings();
        } else {
          navigateTo("chatPage");
        }
      }
      window.addEventListener("hashchange", handleHash);
      handleHash();

      $("openSettingsBtn").addEventListener("click", () => {
        location.hash = "settings";
      });
      $("backToChatBtn").addEventListener("click", () => {
        location.hash = "chat";
      });

      let pendingSettingsUnlock = null;
      function getSettingsUnlockRemainingMs() {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getSettingsUnlockRemainingMs) {
            const v = Number(AndroidBridge.getSettingsUnlockRemainingMs());
            return isFinite(v) ? Math.max(0, v) : 0;
          }
        } catch (_) {}
        return 0;
      }

      function setSettingsUiLocked(locked) {
        try {
          $("brainApiKey").disabled = locked;
          $("braveSearchApiKey").disabled = locked;
          // Keep action buttons enabled so a tap can trigger biometric unlock on-demand.
        } catch (_) {}
      }

      function requestSettingsUnlock() {
        if (pendingSettingsUnlock) return pendingSettingsUnlock;
        pendingSettingsUnlock = new Promise((resolve) => {
          window.__resolveSettingsUnlock = resolve;
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.requestSettingsUnlock) {
              AndroidBridge.requestSettingsUnlock();
            } else {
              resolve({ ok: true, remaining_ms: 30000, fallback: true });
            }
          } catch (_) {
            resolve({ ok: false });
          }
        }).finally(() => { pendingSettingsUnlock = null; });
        return pendingSettingsUnlock;
      }

      // Called by Kotlin after biometric completes.
      window.onSettingsUnlockResult = function(payload) {
        try {
          if (window.__resolveSettingsUnlock) {
            window.__resolveSettingsUnlock(payload || { ok: false });
            window.__resolveSettingsUnlock = null;
          }
        } catch (_) {}
      };

      function refreshSecretsFromBridge() {
        const locked = getSettingsUnlockRemainingMs() <= 0;
        setSettingsUiLocked(locked);
        if (locked) {
          $("brainApiKey").value = "";
          $("brainApiKey").placeholder = "(locked)";
          $("braveSearchApiKey").value = "";
          $("braveSearchApiKey").placeholder = "(locked)";
          return;
        }
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBrainApiKeyPlain) {
            $("brainApiKey").value = AndroidBridge.getBrainApiKeyPlain() || "";
            $("brainApiKey").placeholder = "";
          }
        } catch (_) {}
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBraveSearchApiKeyPlain) {
            $("braveSearchApiKey").value = AndroidBridge.getBraveSearchApiKeyPlain() || "";
            $("braveSearchApiKey").placeholder = "";
          }
        } catch (_) {}
      }

      async function guardedOpenSettings() {
        // Enforce biometric gate for Settings. Cache is handled on Android side (30s).
        if (getSettingsUnlockRemainingMs() <= 0) {
          const r = await requestSettingsUnlock();
          if (!r || !r.ok) {
            showToast("Settings locked", 1600);
            location.hash = "chat";
            return;
          }
        }
        navigateTo("settingsPage");
        refreshSecretsFromBridge();
        if (typeof loadMemory === "function") loadMemory();
        if (typeof checkBraveSearchKey === "function") checkBraveSearchKey();
        if (typeof loadBrainConfig === "function") loadBrainConfig();
      }

      async function ensureSettingsUnlocked() {
        if (getSettingsUnlockRemainingMs() > 0) return true;
        const r = await requestSettingsUnlock();
        if (!r || !r.ok) {
          showToast("Settings locked", 1600);
          return false;
        }
        refreshSecretsFromBridge();
        return true;
      }

      // ==============================
      // Markdown renderer (minimal)
      // ==============================
      function renderMarkdown(text) {
        // Escape HTML
        let h = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Fenced code blocks
        h = h.replace(/```(\w*)\n([\s\S]*?)```/g, function(_, lang, code) {
          return "<pre><code>" + code.replace(/<br\s*\/?>/g, "\n") + "</code></pre>";
        });

        // Inline code
        h = h.replace(/`([^`\n]+)`/g, "<code>$1</code>");

        // Bold
        h = h.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");

        // Italic
        h = h.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "<em>$1</em>");

        // Blockquote lines
        h = h.replace(/(^|\n)&gt; (.+)/g, "$1<blockquote>$2</blockquote>");

        // Paragraphs: double newlines
        h = h.replace(/\n\n+/g, "</p><p>");
        h = "<p>" + h + "</p>";
        h = h.replace(/<p><\/p>/g, "");

        // Single newlines -> <br> (but not inside <pre>)
        const parts = h.split(/(<pre[\s\S]*?<\/pre>)/g);
        for (let i = 0; i < parts.length; i++) {
          if (!parts[i].startsWith("<pre")) {
            parts[i] = parts[i].replace(/\n/g, "<br>");
          }
        }
        h = parts.join("");

        return h;
      }

      // ==============================
      // Chat
      // ==============================
      const chatMessages = $("chatMessages");
      const chatInput = $("chatInput");
      const chatSend = $("chatSend");
      const chatWelcome = $("chatWelcome");
      const CHAT_STORAGE_PREFIX = "kugutz.chat.conversation.v1.";
      const CHAT_SESSION_KEY = "kugutz.chat.session_id.v1";
      let conversation = [];
      let streaming = false;
      let chatSessionId = "";

      function genSessionId() {
        // Not cryptographic; just a stable per-conversation identifier for server-side context.
        return "s_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 10);
      }

      function loadSessionId() {
        try {
          const existing = localStorage.getItem(CHAT_SESSION_KEY);
          if (existing && typeof existing === "string" && existing.trim()) return existing.trim();
        } catch (_) {}
        const created = genSessionId();
        try { localStorage.setItem(CHAT_SESSION_KEY, created); } catch (_) {}
        return created;
      }
      chatSessionId = loadSessionId();

      function convoStorageKey() {
        return CHAT_STORAGE_PREFIX + chatSessionId;
      }

      function saveConversation() {
        try {
          localStorage.setItem(convoStorageKey(), JSON.stringify(conversation));
        } catch (_) {}
      }

      function restoreConversation() {
        try {
          const raw = localStorage.getItem(convoStorageKey());
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return;
          conversation = parsed.filter(m =>
            m && (m.role === "user" || m.role === "assistant") && typeof m.content === "string"
          );
          for (const msg of conversation) {
            addMsg(msg.role, msg.content);
          }
        } catch (_) {}
      }

      function addMsg(role, content) {
        if (chatWelcome.parentNode) chatWelcome.remove();
        const div = document.createElement("div");
        div.className = "msg " + role;
        if (role === "assistant" || role === "user") {
          div.innerHTML = renderMarkdown(content);
        } else {
          div.textContent = content;
        }
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return div;
      }

      async function syncConversationFromServer() {
        try {
          const res = await fetch(API + "/brain/messages?limit=300&session_id=" + encodeURIComponent(chatSessionId));
          if (!res.ok) return;
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          const rebuilt = [];
          for (const msg of list) {
            if (!msg || (msg.role !== "user" && msg.role !== "assistant")) continue;
            if (typeof msg.text !== "string" || !msg.text.trim()) continue;
            rebuilt.push({ role: msg.role, content: msg.text });
          }
          if (!rebuilt.length) return;
          conversation = rebuilt.slice(-200);
          chatMessages.textContent = "";
          for (const msg of conversation) addMsg(msg.role, msg.content);
          saveConversation();
        } catch (_) {}
      }

      function autoResize() {
        chatInput.style.height = "auto";
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + "px";
      }
      chatInput.addEventListener("input", autoResize);
      chatInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
      });
      chatSend.addEventListener("click", sendChat);
      // Chat UI always uses Agent mode (tool-calling brain loop).
      restoreConversation();
      // Best-effort rebuild from server-side session history (survives rotation/worker restart).
      syncConversationFromServer();

      async function sendChat() {
        if (streaming) return;
        const text = chatInput.value.trim();
        if (!text) return;
        chatInput.value = "";
        autoResize();

        conversation.push({ role: "user", content: text });
        saveConversation();
        addMsg("user", text);

        await sendAgentChat(text);
      }

      async function sendAgentChat(text) {
        streaming = true;
        chatSend.disabled = true;
        const aDiv = addMsg("assistant", "_thinking..._");
        try {
          async function readError(res, fallbackPrefix) {
            const raw = await res.text().catch(() => "");
            try {
              const obj = raw ? JSON.parse(raw) : {};
              const msg = (obj && (obj.error || obj.detail || obj.message)) ? (obj.error || obj.detail || obj.message) : "";
              if (msg) return msg;
            } catch (_) {}
            if (raw && raw.trim()) return raw.trim().slice(0, 200);
            return fallbackPrefix + " (" + res.status + ")";
          }

          const boot = await fetch(API + "/brain/agent/bootstrap", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: "{}",
          });
          if (!boot.ok) {
            throw new Error(await readError(boot, "Agent bootstrap failed"));
          }

          const res = await fetch(API + "/brain/inbox/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ text, meta: { source: "chat_ui", session_id: chatSessionId } }),
          });
          if (!res.ok) {
            throw new Error(await readError(res, "Agent queue failed"));
          }
          const queued = await res.json();
          const itemId = queued.id || "";
          if (!itemId) {
            throw new Error("Agent item id missing");
          }

          const answer = await waitForAgentReply(itemId);
          if (!answer) {
            throw new Error("Agent timed out");
          }
          // Strip any legacy memory update tags, but do not auto-persist them.
          // Persistent memory writes must be explicit and permission-gated.
          const memRe = /<<MEMORY_UPDATE>>([\s\S]*?)<<END_MEMORY>>/g;
          const cleaned = (answer || "").replace(memRe, "").trim();

          if (cleaned) {
            aDiv.innerHTML = renderMarkdown(cleaned);
            conversation.push({ role: "assistant", content: cleaned });
            saveConversation();
          } else {
            aDiv.remove();
          }
        } catch (err) {
          if (aDiv.parentNode) aDiv.remove();
          const msg = err.message || "Agent request failed";
          const friendly = {
            "brain_not_configured": "Configure Brain in Settings first.",
            "agent_vendor_not_supported": "Agent mode currently supports OpenAI-compatible providers only.",
          };
          addMsg("error", friendly[msg] || msg);
        } finally {
          streaming = false;
          chatSend.disabled = false;
        }
      }

      async function waitForAgentReply(itemId) {
        // Some tool calls (pip installs, large downloads) can legitimately take minutes.
        // Keep the UI polling longer to avoid premature "Agent timed out".
        const deadline = Date.now() + 15 * 60 * 1000;
        let lastToolError = "";
        while (Date.now() < deadline) {
          const res = await fetch(
            API + "/brain/messages?limit=200&session_id=" + encodeURIComponent(chatSessionId)
          );
          if (!res.ok) {
            await new Promise(r => setTimeout(r, 700));
            continue;
          }
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          for (const msg of list) {
            const meta = msg && msg.meta ? msg.meta : {};
            if (meta.item_id !== itemId) continue;
            if (msg.role === "assistant" && typeof msg.text === "string" && msg.text.trim()) {
              return msg.text.trim();
            }
            if (msg.role === "tool" && typeof msg.text === "string") {
              try {
                const parsed = JSON.parse(msg.text);
                const result = parsed && parsed.result ? parsed.result : {};
                if (result.error) {
                  lastToolError = result.error;
                }
              } catch (_) {}
            }
          }
          await new Promise(r => setTimeout(r, 700));
        }
        if (lastToolError) {
          throw new Error(lastToolError);
        }
        return "";
      }

      // ==============================
      // Brain Config
      // ==============================
      const brainSelect = $("brainVendorModel");
      const brainCustom = $("brainCustomFields");

      // Map vendor+model from select to base_url
      function getSelectedPreset() {
        const opt = brainSelect.selectedOptions[0];
        if (!opt || !opt.dataset.vendor) return null;
        if (opt.dataset.vendor === "custom") return { vendor: "custom" };
        return {
          vendor: opt.dataset.vendor,
          base_url: opt.dataset.url,
          model: opt.value,
        };
      }

      brainSelect.addEventListener("change", () => {
        const p = getSelectedPreset();
        brainCustom.style.display = (p && p.vendor === "custom") ? "block" : "none";
      });

      async function loadBrainConfig() {
        try {
          const res = await fetch(API + "/brain/config");
          if (!res.ok) return;
          const data = await res.json();
          $("brainKeyStatus").textContent = data.has_api_key ? "API key is set." : "No API key configured.";

          // Try to match saved config to a preset
          const vendor = data.vendor || "";
          const model = data.model || "";
          let matched = false;
          for (const opt of brainSelect.options) {
            if (opt.dataset.vendor && opt.dataset.vendor !== "custom"
                && opt.dataset.vendor === vendor && opt.value === model) {
              opt.selected = true;
              matched = true;
              break;
            }
          }
          if (!matched && model) {
            // Select "Custom" and populate fields
            for (const opt of brainSelect.options) {
              if (opt.value === "custom") { opt.selected = true; break; }
            }
            brainCustom.style.display = "block";
            $("brainBaseUrl").value = data.base_url || "";
            $("brainModelId").value = model;
          } else {
            brainCustom.style.display = "none";
          }
        } catch (_) {}
      }

      $("brainSave").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        const preset = getSelectedPreset();
        if (!preset) { showToast("Choose a model first"); return; }

        const payload = {};
        if (preset.vendor === "custom") {
          const baseUrl = $("brainBaseUrl").value.trim();
          const modelId = $("brainModelId").value.trim();
          if (!baseUrl || !modelId) { showToast("Fill in Base URL and Model"); return; }
          payload.vendor = "custom";
          payload.base_url = baseUrl;
          payload.model = modelId;
        } else {
          payload.vendor = preset.vendor;
          payload.base_url = preset.base_url;
          payload.model = preset.model;
        }

        const apiKey = $("brainApiKey").value.trim();
        payload.api_key = apiKey;

        try {
          // Prefer AndroidBridge to avoid extra consent prompts; Settings is already biometric-unlocked.
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBrainApiKeyPlain) {
              AndroidBridge.setBrainApiKeyPlain(apiKey);
            }
          } catch (_) {}

          const res = await fetch(API + "/brain/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) { showToast("Failed to save config"); return; }
          await loadBrainConfig();
          refreshSecretsFromBridge();
          showToast("Brain config saved");
        } catch (_) {
          showToast("Connection error");
        }
      });

      loadBrainConfig();

      // ==============================
      // Memory Editor
      // ==============================
      const memoryEditor = $("memoryEditor");

      async function loadMemory() {
        try {
          const res = await fetch(API + "/brain/memory");
          if (!res.ok) return;
          const data = await res.json();
          memoryEditor.value = data.content || "";
        } catch (_) {}
      }

      $("memorySave").addEventListener("click", async () => {
        try {
          const res = await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: memoryEditor.value }),
          });
          if (res.ok) showToast("Memory saved");
          else showToast("Failed to save memory");
        } catch (_) { showToast("Connection error"); }
      });

      $("memoryClear").addEventListener("click", async () => {
        if (!confirm("Clear all memory? This cannot be undone.")) return;
        memoryEditor.value = "";
        try {
          await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: "" }),
          });
          showToast("Memory cleared");
        } catch (_) { showToast("Connection error"); }
      });

      loadMemory();

      // ==============================
      // Web Search Keys
      // ==============================
      async function checkBraveSearchKey() {
        try {
          $("braveSearchKeyStatus").textContent = "Checking...";
          // Prefer biometric-unlocked plaintext status to avoid extra permission prompts.
          try {
            if (getSettingsUnlockRemainingMs() > 0
                && typeof AndroidBridge !== "undefined"
                && AndroidBridge.getBraveSearchApiKeyPlain) {
              const k = (AndroidBridge.getBraveSearchApiKeyPlain() || "").trim();
              $("braveSearchKeyStatus").textContent = k ? "API key is set." : "No API key configured.";
              return;
            }
          } catch (_) {}
          const permission_id = await requestPermission("credentials", "Check Brave Search API key status");
          const res = await fetch(API + "/vault/credentials/has", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", permission_id }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          $("braveSearchKeyStatus").textContent = data.present ? "API key is set." : "No API key configured.";
        } catch (_) {
          $("braveSearchKeyStatus").textContent = "Failed to check status.";
        }
      }

      $("braveSearchCheck").addEventListener("click", checkBraveSearchKey);
      $("braveSearchSave").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        const key = $("braveSearchApiKey").value.trim();
        try {
          // Prefer AndroidBridge to avoid extra consent prompts; Settings is already biometric-unlocked.
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain(key);
              refreshSecretsFromBridge();
              showToast("Brave key saved");
              await checkBraveSearchKey();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Set Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: key, permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key saved");
          await checkBraveSearchKey();
        } catch (_) {
          showToast("Failed to save key");
        }
      });

      $("braveSearchClear").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        try {
          // Prefer AndroidBridge to avoid extra consent prompts; Settings is already biometric-unlocked.
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain("");
              refreshSecretsFromBridge();
              showToast("Brave key cleared");
              await checkBraveSearchKey();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Clear Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: "", permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key cleared");
          await checkBraveSearchKey();
        } catch (_) {
          showToast("Failed to clear key");
        }
      });

      // ==============================
      // Settings: SSHD, Python, etc.
      // ==============================
      const pythonStatus = $("pythonStatus");
      const pythonDetail = $("pythonDetail");
      const sshStatus = $("sshStatus");
      const sshEnabled = $("sshEnabled");
      const authNotification = $("authNotification");
      const authPin = $("authPin");
      const sshDetail = $("sshDetail");
      const clientKeyRow = $("clientKeyRow");
      const clientKeyFp = $("clientKeyFp");
      const copyClientKey = $("copyClientKey");
      let currentClientKeyPublic = "";
      const pinModal = $("pinModal");
      const pinCode = $("pinCode");
      const pinCountdown = $("pinCountdown");
      const pinClose = $("pinClose");
      const pinBarFill = $("pinBarFill");
      const pinDurationMs = 20000;
      let pinExpiresAt = null;
      let lastPin = null;

      function setStatus(el, value) {
        el.textContent = value;
        el.classList.remove("ok", "offline", "starting", "stopping");
        if (value === "ok") el.classList.add("ok");
        else if (value === "offline") el.classList.add("offline");
        else if (value === "stopping") el.classList.add("stopping");
        else el.classList.add("starting");
      }

      async function refreshPython() {
        try {
          const res = await fetch(API + "/python/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(pythonStatus, data.status || "offline");
        } catch (_) {
          setStatus(pythonStatus, "offline");
        }
      }

      async function refreshSsh() {
        try {
          const res = await fetch(API + "/ssh/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(sshStatus, data.running ? "ok" : "offline");
          sshEnabled.checked = !!data.enabled;
          sshDetail.textContent = "ssh " + (data.host || "aaa.bbb.ccc.ddd") + " -p " + (data.port || 2222);
          if (data.client_key_fingerprint) {
            clientKeyFp.textContent = data.client_key_fingerprint;
            clientKeyRow.style.display = "block";
          } else {
            clientKeyRow.style.display = "none";
          }
          currentClientKeyPublic = data.client_key_public || "";
        } catch (_) {
          setStatus(sshStatus, "offline");
          sshDetail.textContent = "SSHD status unavailable";
          clientKeyRow.style.display = "none";
        }
      }

      async function refreshPin() {
        try {
          const res = await fetch(API + "/ssh/pin/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.active) {
            pinExpiresAt = data.expires_at || null;
            if (!pinModal.classList.contains("show")) pinModal.classList.add("show");
            if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
            else if (lastPin && pinCode.textContent === "------") pinCode.textContent = lastPin;
            updatePinCountdown();
          } else {
            pinExpiresAt = null;
            pinBarFill.style.width = "0%";
            pinCountdown.textContent = "PIN inactive.";
            pinCode.textContent = "------";
            lastPin = null;
            if (pinModal.classList.contains("show")) {
              pinModal.classList.remove("show");
              await refreshSsh();
            }
          }
        } catch (_) {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN unavailable.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
        }
      }

      function updatePinCountdown() {
        if (!pinExpiresAt) {
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          return;
        }
        const rem = pinExpiresAt - Date.now();
        if (rem <= 0) {
          pinBarFill.style.width = "0%";
          pinExpiresAt = null;
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
          return;
        }
        pinCountdown.textContent = "Active (" + Math.ceil(rem / 1000) + "s)";
        pinBarFill.style.width = Math.round(Math.max(0, Math.min(1, rem / pinDurationMs)) * 100) + "%";
      }

      // ==============================
      // Permissions prefs
      // ==============================
      let permissionsRemember = true;
      async function loadPermissionPrefs() {
        try {
          const res = await fetch(API + "/permissions/prefs");
          if (!res.ok) throw 0;
          const data = await res.json();
          permissionsRemember = !!data.remember_approvals;
          $("permRemember").checked = permissionsRemember;
        } catch (_) {
          permissionsRemember = true;
          $("permRemember").checked = true;
        }
      }

      async function requestPermission(tool, detail) {
        const res = await fetch(API + "/permissions/request", {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify({ tool, detail, scope: (permissionsRemember ? "persistent" : "once") }),
        });
        if (!res.ok) throw new Error("permission request failed");
        const data = await res.json();
        if (data.status === "approved") return data.id;
        const deadline = Date.now() + 30000;
        while (Date.now() < deadline) {
          await new Promise(r => setTimeout(r, 500));
          try {
            const sr = await fetch(API + "/permissions/" + data.id);
            if (!sr.ok) continue;
            const sd = await sr.json();
            if (sd.status === "approved") return data.id;
            if (sd.status === "denied") throw new Error("permission denied");
          } catch (_) {}
        }
        throw new Error("permission timeout");
      }

      // ==============================
      // Pip helpers
      // ==============================
      async function refreshPipStatus() {
        try {
          const res = await fetch(API + "/pip/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          const lines = [];
          if (data.abi) lines.push("ABI: " + data.abi);
          if (data.wheelhouse_bundled) lines.push("Bundled wheels: " + data.wheelhouse_bundled);
          if (data.wheelhouse_user) lines.push("User wheel cache: " + data.wheelhouse_user);
          if (data.pip_find_links) lines.push("PIP_FIND_LINKS: " + data.pip_find_links);
          $("pipStatus").textContent = lines.join("\n");
        } catch (_) {
          $("pipStatus").textContent = "pip status unavailable.";
        }
      }

      function getPipSpec() {
        return String($("pipSpec").value || "").trim();
      }

      function setPipOutput(text) {
        $("pipOutput").textContent = text || "";
      }

      async function runPip(endpoint, payload, detail) {
        const permission_id = await requestPermission("pip", detail);
        payload = Object.assign({}, payload, { permission_id });
        const res = await fetch(API + endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        const code = data.code;
        const out = data.output || (data.error ? ("error: " + data.error) : "");
        setPipOutput((typeof code === "number" ? ("exit=" + code + "\n\n") : "") + out);
        if (!res.ok) throw new Error("pip failed");
        return data;
      }

      $("pipDownload").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Downloading wheels...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          const index_url = String($("pipIndexUrl").value || "").trim();
          await runPip(
            "/pip/download",
            { spec, with_deps, only_binary, index_url: (index_url || undefined) },
            "Download wheels: " + spec
          );
          await refreshPipStatus();
          showToast("Download complete", 1600);
        } catch (_) {
          showToast("Download failed", 2000);
        }
      });

      $("pipInstallOffline").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Installing (offline)...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          await runPip(
            "/pip/install",
            { spec, allow_network: false, no_deps: !with_deps, only_binary },
            "Install (offline): " + spec
          );
          showToast("Install complete", 1600);
        } catch (_) {
          showToast("Install failed", 2000);
        }
      });

      $("pipInstallNet").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Installing (network)...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          const index_url = String($("pipIndexUrl").value || "").trim();
          await runPip(
            "/pip/install",
            { spec, allow_network: true, no_deps: !with_deps, only_binary, index_url: (index_url || undefined) },
            "Install (network): " + spec
          );
          showToast("Install complete", 1600);
        } catch (_) {
          showToast("Install failed", 2000);
        }
      });

      $("permRemember").addEventListener("change", async () => {
        const enabled = !!$("permRemember").checked;
        permissionsRemember = enabled;
        try {
          const res = await fetch(API + "/permissions/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ remember_approvals: enabled }),
          });
          if (!res.ok) throw 0;
          showToast("Permission preference saved", 1500);
        } catch (_) {
          showToast("Failed to save preference", 2000);
        }
      });
      $("permClear").addEventListener("click", async () => {
        if (!window.confirm("Clear all saved tool approvals?")) return;
        try {
          const res = await fetch(API + "/permissions/clear", { method: "POST" });
          if (!res.ok) throw 0;
          showToast("Saved approvals cleared", 1800);
        } catch (_) {
          showToast("Failed to clear approvals", 2000);
        }
      });

      $("restartPython").addEventListener("click", async () => {
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.restartPythonWorker) {
          AndroidBridge.restartPythonWorker();
        } else {
          await fetch(API + "/python/restart", { method: "POST" });
        }
        pythonDetail.textContent = "Restart requested";
        setStatus(pythonStatus, "starting");
      });

      $("resetUi").addEventListener("click", () => {
        if (!window.confirm("Reset UI to defaults? This will overwrite any local changes.")) return;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUiToDefaults) {
          AndroidBridge.resetUiToDefaults();
        }
      });

      async function updateSshConfig() {
        const enabled = sshEnabled.checked;
        try {
          const res = await fetch(API + "/ssh/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ enabled }),
          });
          if (!res.ok) throw 0;
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to apply SSHD settings";
        }
      }

      sshEnabled.addEventListener("change", updateSshConfig);
      authNotification.addEventListener("click", async () => {
        sshDetail.textContent = "Enabling notification auth...";
        try {
          const permission_id = await requestPermission("ssh_noauth", "Enable SSH notification auth");
          const res = await fetch(API + "/ssh/noauth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 30 }),
          });
          if (!res.ok) throw 0;
          sshDetail.textContent = "Notification auth enabled";
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to enable notification auth";
        }
      });
      authPin.addEventListener("click", async () => {
        try {
          pinCode.textContent = "\u2022\u2022\u2022\u2022\u2022\u2022";
          pinCountdown.textContent = "Generating PIN...";
          pinBarFill.style.width = "0%";
          pinModal.classList.add("show");
          const permission_id = await requestPermission("ssh_pin", "Enable SSH PIN auth");
          const res = await fetch(API + "/ssh/pin/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 20 }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
          else if (lastPin) pinCode.textContent = lastPin;
          else pinCode.textContent = "PIN unavailable";
          pinModal.classList.add("show");
          pinExpiresAt = data.expires_at || (Date.now() + pinDurationMs);
          updatePinCountdown();
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to start PIN auth";
        }
      });

      copyClientKey.addEventListener("click", async () => {
        if (!currentClientKeyPublic) return;
        try {
          await navigator.clipboard.writeText(currentClientKeyPublic);
          copyClientKey.textContent = "Copied!";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        } catch (_) {
          copyClientKey.textContent = "Failed";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        }
      });

      pinClose.addEventListener("click", async () => {
        try {
          await fetch(API + "/ssh/pin/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({}),
          });
          await refreshPin();
          await refreshSsh();
        } catch (_) {
        } finally {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          lastPin = null;
          pinModal.classList.remove("show");
        }
      });

      window.onPythonStatus = function(status) {
        setStatus(pythonStatus, status);
      };

      loadPermissionPrefs();
      refreshPipStatus();
      refreshPython();
      refreshSsh();
      refreshPin();
      setInterval(refreshPython, 5000);
      setInterval(refreshSsh, 5000);
      setInterval(refreshPin, 1000);
      setInterval(updatePinCountdown, 1000);
    </script>
  </body>
</html>
