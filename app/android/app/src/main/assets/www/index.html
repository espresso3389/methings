<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Kugutz</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0e0e10;
        --bg-raised: #18181b;
        --bg-overlay: #1e1e22;
        --surface: #24242a;
        --border: #2e2e36;
        --border-focus: #5b5bd6;
        --ink: #ececf1;
        --ink-secondary: #a1a1aa;
        --ink-muted: #71717a;
        --accent: #6366f1;
        --accent-soft: rgba(99,102,241,0.12);
        --accent-hover: #818cf8;
        --green: #22c55e;
        --green-soft: rgba(34,197,94,0.12);
        --red: #ef4444;
        --red-soft: rgba(239,68,68,0.12);
        --amber: #f59e0b;
        --amber-soft: rgba(245,158,11,0.12);
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-full: 9999px;
        --shadow: 0 2px 8px rgba(0,0,0,0.3);
        --shadow-lg: 0 8px 24px rgba(0,0,0,0.4);
        --transition: 180ms ease;
      }

      * { box-sizing: border-box; margin: 0; padding: 0; }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--ink);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
        font-size: 15px;
        line-height: 1.5;
      }

      /* --- Pages --- */
      .page {
        display: none;
        flex: 1;
        flex-direction: column;
        overflow: hidden;
      }
      .page.active { display: flex; }

      /* --- Topbar --- */
      .topbar {
        flex-shrink: 0;
        height: 52px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px 0 16px;
        border-bottom: 1px solid var(--border);
        background: var(--bg-raised);
      }
      .topbar .title {
        font-weight: 700;
        font-size: 17px;
        letter-spacing: -0.2px;
      }
      .icon-btn {
        width: 38px;
        height: 38px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border);
        background: var(--surface);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 18px;
        color: var(--ink-secondary);
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .icon-btn svg,
      .send-btn svg,
      .attach-icon-btn svg {
        width: 19px;
        height: 19px;
        display: block;
      }
      .send-btn svg { width: 20px; height: 20px; }
      .icon-btn:active { transform: scale(0.95); }
      .icon-btn:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .icon-btn.secondary { background: transparent; border-color: transparent; }
      .icon-btn.secondary:hover { background: var(--surface); }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      /* --- Chat page --- */
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        -webkit-overflow-scrolling: touch;
      }
      .chat-welcome {
        text-align: center;
        color: var(--ink-muted);
        margin: auto 0;
        padding: 20px;
        font-size: 14px;
        line-height: 1.7;
      }
      .chat-welcome strong {
        display: block;
        color: var(--ink);
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 6px;
      }

      .msg {
        max-width: 85%;
        padding: 10px 14px;
        border-radius: var(--radius-lg);
        line-height: 1.6;
        word-wrap: break-word;
        overflow-wrap: anywhere;
        font-size: 15px;
      }
      .msg.user {
        align-self: flex-end;
        background: var(--accent);
        color: #fff;
        border-bottom-right-radius: 4px;
      }
      .msg.assistant {
        align-self: flex-start;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-bottom-left-radius: 4px;
      }
      .msg.debug {
        border-style: dashed;
        border-color: rgba(245,158,11,0.45);
        background: var(--amber-soft);
      }
      .msg.assistant.debug { color: var(--ink); }
      .msg.debug::before {
        content: "DEBUG";
        display: inline-block;
        font-size: 10px;
        font-weight: 800;
        letter-spacing: 0.6px;
        color: var(--amber);
        background: rgba(245,158,11,0.12);
        border: 1px solid rgba(245,158,11,0.35);
        border-radius: var(--radius-full);
        padding: 2px 8px;
        margin: 0 10px 6px 0;
        vertical-align: middle;
      }
      /* Multi-party timeline styling (actor tags are injected by the server). */
      .msg.actor-codex {
        border-color: rgba(14,165,233,0.5);
        background: rgba(14,165,233,0.08);
      }
      .msg.actor-codex::before {
        content: "CODEX";
        color: var(--cyan);
        background: rgba(14,165,233,0.12);
        border-color: rgba(14,165,233,0.35);
      }
      .msg.error {
        align-self: center;
        background: var(--red-soft);
        color: var(--red);
        font-size: 13px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(239,68,68,0.2);
        max-width: 95%;
      }

      /* Markdown in messages */
      .msg pre {
        background: #0d0d0f;
        color: #d4d4d8;
        padding: 10px 12px;
        border-radius: var(--radius-sm);
        overflow-x: auto;
        white-space: pre;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 13px;
        margin: 8px 0;
        line-height: 1.5;
        border: 1px solid var(--border);
      }
      .msg.user pre { background: rgba(0,0,0,0.2); border-color: rgba(255,255,255,0.1); color: #fff; }
      .msg code:not(pre code) {
        background: rgba(255,255,255,0.08);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 0.88em;
      }
      .msg.user code:not(pre code) { background: rgba(255,255,255,0.18); }
      .msg p { margin: 4px 0; }
      .msg ul, .msg ol { margin: 4px 0; padding-left: 20px; }
      .msg li { margin: 2px 0; }
      .msg blockquote {
        border-left: 3px solid var(--accent);
        margin: 8px 0;
        padding: 2px 0 2px 12px;
        color: var(--ink-secondary);
      }

      /* Inline attachments in chat */
      .attach-wrap { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
      .attach-card {
        background: #0d0d0f;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 10px;
      }
      .attach-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
      }
      .attach-actions { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }
      .attach-path {
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 12px;
        color: var(--ink-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .attach-icon-btn {
        width: 34px;
        height: 34px;
        border-radius: var(--radius-md);
        border: 1px solid rgba(161,161,170,0.25);
        background: rgba(255,255,255,0.04);
        color: var(--ink-secondary);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 16px;
      }
      .attach-icon-btn:hover { background: rgba(255,255,255,0.08); color: var(--ink); }

      /* Fullscreen viewer */
      .viewer {
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.92);
        display: none;
        z-index: 1200;
        touch-action: none;
      }
      .viewer.show { display: flex; flex-direction: column; }
      .viewer-top {
        height: 54px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
      }
      .viewer-top .viewer-title {
        font-size: 13px;
        color: rgba(255,255,255,0.78);
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 60vw;
      }
      .viewer-body {
        flex: 1;
        display: grid;
        place-items: center;
        overflow: hidden;
        position: relative;
      }
      .viewer-img {
        max-width: 100%;
        max-height: 100%;
        transform-origin: 0 0;
        will-change: transform;
      }
      .attach-body img,
      .attach-body video {
        width: 100%;
        max-height: 360px;
        object-fit: contain;
        background: #000;
        border-radius: var(--radius-sm);
      }
      .attach-body audio { width: 100%; }
      .attach-hint { color: var(--ink-muted); font-size: 12px; margin-top: 6px; }

      /* Thinking indicator */
      .thinking-dots { display: inline-flex; gap: 4px; align-items: center; padding: 4px 0; }
      .thinking-dots span {
        width: 6px; height: 6px;
        border-radius: 50%;
        background: var(--ink-muted);
        animation: thinking 1.2s infinite;
      }
      .thinking-dots.mini span { width: 5px; height: 5px; }
      .msg-working { margin-top: 8px; }
      .thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
      .thinking-dots span:nth-child(3) { animation-delay: 0.4s; }
      @keyframes thinking {
        0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
        30% { opacity: 1; transform: scale(1); }
      }

      /* Chat input */
      .chat-input-area {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        padding: 10px 12px 14px;
        border-top: 1px solid var(--border);
        background: var(--bg-raised);
        flex-shrink: 0;
      }
      .chat-input-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
      }
      .chat-left {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-shrink: 0;
        padding-bottom: 4px;
      }
      .chat-left .icon-btn {
        width: 40px;
        height: 40px;
        border-radius: var(--radius-md);
        font-size: 18px;
      }
      .chat-left .icon-btn.primary {
        background: rgba(99,102,241,0.14);
        border-color: rgba(99,102,241,0.35);
        color: #c7d2fe;
      }
      .chat-left .icon-btn.danger {
        background: rgba(239,68,68,0.12);
        border-color: rgba(239,68,68,0.35);
        color: #fecaca;
      }
      .chat-input-area textarea {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 10px 14px;
        font-family: inherit;
        font-size: 15px;
        resize: none;
        background: var(--surface);
        color: var(--ink);
        min-height: 42px;
        max-height: 120px;
        line-height: 1.4;
        outline: none;
        transition: border-color var(--transition);
      }
      .chat-input-area textarea::placeholder { color: var(--ink-muted); }
      .chat-input-area textarea:focus { border-color: var(--border-focus); }
      .send-btn {
        border: none;
        border-radius: 50%;
        width: 42px;
        height: 42px;
        background: var(--accent);
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        transition: background var(--transition), opacity var(--transition);
      }
      .send-btn:hover { background: var(--accent-hover); }
      .send-btn:active { transform: scale(0.95); }
      .send-btn:disabled { opacity: 0.35; cursor: default; }

      .composer-attachments {
        display: none;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .composer-attachments.show { display: flex; }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 9999px;
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(161,161,170,0.25);
        max-width: 100%;
      }
      .chip .chip-name {
        font-size: 13px;
        color: var(--ink);
        font-weight: 600;
        max-width: 62vw;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .chip .chip-sub {
        font-size: 11px;
        color: var(--ink-muted);
        white-space: nowrap;
      }
      .chip .chip-x {
        width: 24px;
        height: 24px;
        border-radius: 9999px;
        border: 1px solid rgba(161,161,170,0.25);
        background: rgba(0,0,0,0.15);
        color: var(--ink-secondary);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 13px;
        flex-shrink: 0;
      }
      .chip .chip-x:hover { color: var(--ink); background: rgba(255,255,255,0.08); }

      /* --- Settings page --- */
      .settings-scroll {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 12px 16px 28px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .card {
        background: var(--bg-raised);
        border-radius: var(--radius-lg);
        padding: 16px;
        border: 1px solid var(--border);
      }

      .card-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .card-icon {
        width: 34px;
        height: 34px;
        border-radius: var(--radius-sm);
        display: grid;
        place-items: center;
        font-size: 16px;
        flex-shrink: 0;
      }
      .card-icon.purple { background: var(--accent-soft); color: var(--accent); }
      .card-icon.green { background: var(--green-soft); color: var(--green); }
      .card-icon.amber { background: var(--amber-soft); color: var(--amber); }
      .card-icon.red { background: var(--red-soft); color: var(--red); }
      .card-title { font-weight: 700; font-size: 15px; }
      .card-desc { color: var(--ink-muted); font-size: 13px; line-height: 1.5; margin-bottom: 12px; }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        font-weight: 600;
        padding: 4px 10px;
        border-radius: var(--radius-full);
        text-transform: uppercase;
        letter-spacing: 0.4px;
      }
      .status-badge::before {
        content: "";
        width: 6px; height: 6px;
        border-radius: 50%;
      }
      .status-badge.ok { background: var(--green-soft); color: var(--green); }
      .status-badge.ok::before { background: var(--green); }
      .status-badge.offline { background: var(--red-soft); color: var(--red); }
      .status-badge.offline::before { background: var(--red); }
      .status-badge.starting { background: var(--amber-soft); color: var(--amber); }
      .status-badge.starting::before { background: var(--amber); }
      .status-badge.stopping { background: var(--amber-soft); color: var(--amber); }
      .status-badge.stopping::before { background: var(--amber); }

      /* Buttons */
      .btn {
        border: none;
        border-radius: var(--radius-full);
        padding: 8px 16px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        font-family: inherit;
        background: var(--surface);
        color: var(--ink-secondary);
        border: 1px solid var(--border);
        transition: background var(--transition), border-color var(--transition), color var(--transition);
      }
      .btn:hover { background: var(--bg-overlay); border-color: var(--ink-muted); color: var(--ink); }
      .btn:active { transform: scale(0.97); }
      .btn.primary {
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
      }
      .btn.primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
      .btn.danger {
        background: var(--red);
        color: #fff;
        border-color: var(--red);
      }
      .btn.danger:hover { background: #dc2626; border-color: #dc2626; }
      .btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }

      .muted { color: var(--ink-muted); font-size: 13px; word-break: break-word; overflow-wrap: anywhere; }

      /* Media preview */
      .media-preview {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        background: #0d0d0f;
        padding: 10px;
      }
      .media-preview img,
      .media-preview video {
        width: 100%;
        border-radius: var(--radius-sm);
        background: #000;
        max-height: 360px;
        object-fit: contain;
      }
      .media-preview audio { width: 100%; }
      .media-preview .hint { color: var(--ink-muted); font-size: 12px; margin-top: 6px; }

      .dropzone {
        border: 1px dashed rgba(161,161,170,0.45);
        background: rgba(99,102,241,0.06);
        border-radius: var(--radius-md);
        padding: 12px;
        transition: border-color var(--transition), background var(--transition);
      }
      .dropzone.dragover {
        border-color: rgba(129,140,248,0.9);
        background: rgba(99,102,241,0.14);
      }
      .dropzone .dz-title { font-weight: 700; font-size: 13px; }
      .dropzone .dz-sub { color: var(--ink-muted); font-size: 12px; margin-top: 4px; }

      .file-list {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        overflow: hidden;
        background: rgba(0,0,0,0.18);
      }
      .file-row {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid rgba(46,46,54,0.7);
      }
      .file-row:first-child { border-top: none; }
      .file-row:hover { background: rgba(255,255,255,0.04); }
      .file-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        color: var(--ink);
        font-weight: 600;
      }
      .file-meta {
        color: var(--ink-muted);
        font-size: 12px;
        white-space: nowrap;
      }
      .pill {
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        padding: 3px 8px;
        border-radius: var(--radius-full);
        border: 1px solid rgba(161,161,170,0.28);
        color: var(--ink-secondary);
        background: rgba(255,255,255,0.04);
        flex-shrink: 0;
      }

      /* Form fields */
      .field { margin-top: 10px; }
      .field label {
        display: block;
        color: var(--ink-muted);
        font-size: 12px;
        font-weight: 600;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .field select,
      .field input[type="text"],
      .field input[type="url"],
      .field input[type="password"] {
        width: 100%;
        padding: 9px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        font-family: inherit;
        font-size: 14px;
        background: var(--surface);
        color: var(--ink);
        outline: none;
        transition: border-color var(--transition);
      }
      .field select { appearance: auto; }
      .field select:focus,
      .field input:focus { border-color: var(--border-focus); }
      .field input::placeholder { color: var(--ink-muted); }

      /* Toggle switch */
      .toggle-row {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 4px 0;
      }
      .toggle-row .toggle-label { font-size: 14px; color: var(--ink-secondary); }
      .toggle {
        position: relative;
        width: 44px;
        height: 24px;
        flex-shrink: 0;
      }
      .toggle input { opacity: 0; width: 0; height: 0; position: absolute; }
      .toggle .slider {
        position: absolute;
        inset: 0;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-full);
        cursor: pointer;
        transition: background var(--transition), border-color var(--transition);
      }
      .toggle .slider::before {
        content: "";
        position: absolute;
        width: 18px; height: 18px;
        left: 2px; top: 2px;
        background: var(--ink-muted);
        border-radius: 50%;
        transition: transform var(--transition), background var(--transition);
      }
      .toggle input:checked + .slider { background: var(--accent); border-color: var(--accent); }
      .toggle input:checked + .slider::before { transform: translateX(20px); background: #fff; }

      /* Checkbox row */
      .check-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 3px 0;
        font-size: 14px;
        color: var(--ink-secondary);
      }
      .check-row input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--accent);
        flex-shrink: 0;
      }

      /* Textarea (memory editor) */
      .memory-textarea {
        width: 100%;
        min-height: 100px;
        max-height: 280px;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 13px;
        background: var(--surface);
        color: var(--ink);
        resize: vertical;
        outline: none;
        box-sizing: border-box;
        line-height: 1.5;
        transition: border-color var(--transition);
      }
      .memory-textarea::placeholder { color: var(--ink-muted); }
      .memory-textarea:focus { border-color: var(--border-focus); }

      /* Pre output */
      .output-pre {
        white-space: pre-wrap;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        font-size: 12px;
        background: var(--surface);
        color: var(--ink-secondary);
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        max-height: 220px;
        overflow: auto;
        margin-top: 10px;
        line-height: 1.5;
      }

      /* PIN modal */
      .modal {
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        display: none; align-items: center; justify-content: center;
        padding: 20px; z-index: 999;
      }
      .modal.show { display: flex; }
      .modal-card {
        width: 100%; max-width: 340px;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 20px;
        box-shadow: var(--shadow-lg);
        text-align: center;
      }
      .modal-card .card-title { margin-bottom: 12px; font-size: 16px; }
      .pin-code {
        font-size: 32px;
        font-weight: 700;
        letter-spacing: 4px;
        margin: 8px 0;
        font-family: "JetBrains Mono", "Fira Code", "Menlo", "Consolas", monospace;
        color: var(--accent);
      }
      .pin-countdown { color: var(--ink-muted); font-size: 13px; margin-bottom: 12px; }
      .pin-bar {
        width: 100%;
        height: 4px;
        background: var(--surface);
        border-radius: var(--radius-full);
        overflow: hidden;
        margin-bottom: 16px;
      }
      .pin-bar-fill {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.2s ease;
        border-radius: var(--radius-full);
      }

      /* Toast */
      .toast {
        position: fixed;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: var(--ink);
        color: var(--bg);
        padding: 10px 20px;
        border-radius: var(--radius-full);
        font-size: 13px;
        font-weight: 600;
        opacity: 0;
        transition: opacity 0.25s, transform 0.25s;
        pointer-events: none;
        z-index: 1000;
        box-shadow: var(--shadow);
      }
      .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

      /* Responsive */
      @media (max-width: 420px) {
        .settings-scroll { padding: 8px 10px 24px; }
        .card { padding: 14px; }
        .btn-group .btn { flex: 1; text-align: center; min-width: 0; }
      }
      @media (min-width: 640px) {
        .settings-scroll {
          max-width: 560px;
          margin: 0 auto;
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- ===== Chat Page ===== -->
    <div id="chatPage" class="page active">
      <div class="topbar">
        <div class="title">Kugutz</div>
        <button class="icon-btn" id="openSettingsBtn" title="Settings" aria-label="Settings"></button>
      </div>
      <div class="chat-messages" id="chatMessages">
        <div class="chat-welcome" id="chatWelcome">
          <strong>Kugutz Brain</strong>
          Configure your AI provider in Settings,<br>then start chatting.
        </div>
      </div>
      <div class="chat-input-area">
        <div class="composer-attachments" id="composerAttachments"></div>
        <div class="chat-input-row">
          <div class="chat-left">
            <button class="icon-btn primary" id="chatUploadBtn" title="Attach file(s)" aria-label="Attach file(s)"></button>
            <button class="icon-btn" id="chatRecordBtn" title="Record audio" aria-label="Record audio"></button>
          </div>
          <textarea id="chatInput" placeholder="Message..." rows="1"></textarea>
          <button class="send-btn" id="chatSend" title="Send" aria-label="Send"></button>
        </div>
      </div>
      <input type="file" id="chatUploadInput" multiple style="display:none" />
    </div>

    <!-- ===== Settings Page ===== -->
    <div id="settingsPage" class="page">
      <div class="topbar">
        <button class="icon-btn secondary" id="backToChatBtn" title="Back" aria-label="Back"></button>
        <div class="title">Settings</div>
        <div style="width:38px;"></div>
      </div>
      <div class="settings-scroll">
        <!-- Brain Config -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon purple">&#9733;</div>
            <div class="card-title">Brain</div>
          </div>
          <div class="field">
            <label>Model</label>
            <select id="brainVendorModel">
              <option value="" disabled>Choose a model...</option>
              <optgroup label="OpenAI">
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2-codex">GPT-5.2 Codex</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.2">GPT-5.2</option>
                <option data-vendor="openai" data-url="https://api.openai.com/v1" value="gpt-5.1-codex-mini">GPT-5.1 Codex Mini</option>
              </optgroup>
              <optgroup label="Anthropic">
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-opus-4-6">Claude Opus 4.6</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-sonnet-4-5">Claude Sonnet 4.5</option>
                <option data-vendor="anthropic" data-url="https://api.anthropic.com" value="claude-haiku-4-5">Claude Haiku 4.5</option>
              </optgroup>
              <option data-vendor="custom" value="custom">Custom...</option>
            </select>
          </div>
          <div id="brainCustomFields" style="display:none;">
            <div class="field">
              <label>Base URL</label>
              <input type="url" id="brainBaseUrl" placeholder="https://api.openai.com/v1" />
            </div>
            <div class="field">
              <label>Model ID</label>
              <input type="text" id="brainModelId" placeholder="gpt-5.2" />
            </div>
          </div>
          <div class="field">
            <label>API Key (plaintext)</label>
            <input type="text" id="brainApiKey" placeholder="(locked)" />
            <div class="muted" id="brainKeyStatus" style="margin-top:4px;"></div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="brainSave">Save</button>
          </div>
        </section>

        <!-- Web Search -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon green">&#9906;</div>
            <div class="card-title">Web Search</div>
          </div>
          <div class="card-desc">
            Default provider is DuckDuckGo. Brave Search is used only when an API key is configured here.
          </div>
          <div class="field">
            <label>Brave Search API Key (plaintext)</label>
            <input type="text" id="braveSearchApiKey" placeholder="(locked)" />
            <div class="muted" id="braveSearchKeyStatus" style="margin-top:4px;">Status unknown.</div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="braveSearchSave">Save</button>
            <button class="btn" id="braveSearchClear">Clear</button>
            <button class="btn" id="braveSearchCheck">Check</button>
          </div>
        </section>

        <!-- Memory -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon purple">&#9998;</div>
            <div class="card-title">Memory</div>
          </div>
          <div class="card-desc">Persistent notes the AI remembers across conversations.</div>
          <textarea id="memoryEditor"
            class="memory-textarea"
            placeholder="(empty -- the AI or you can add notes here)"></textarea>
          <div class="btn-group">
            <button class="btn primary" id="memorySave">Save</button>
            <button class="btn" id="memoryClear">Clear</button>
          </div>
        </section>

        <!-- SSHD -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon green">&#9741;</div>
            <div class="card-title">SSHD</div>
            <div id="sshStatus" class="status-badge starting" style="margin-left:auto;">checking</div>
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="sshEnabled" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Enable SSHD</span>
          </div>
          <div class="btn-group" style="margin-top:8px;">
            <button class="btn" id="authNotification">Notification</button>
            <button class="btn" id="authPin">PIN</button>
          </div>
          <p class="muted" id="sshDetail" style="margin-top:10px;">Waiting for status...</p>
          <div id="clientKeyRow" style="display:none;margin-top:8px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="muted" style="font-family:monospace;font-size:12px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" id="clientKeyFp"></span>
              <button class="btn" id="copyClientKey" style="padding:5px 10px;font-size:12px;">Copy</button>
            </div>
          </div>
        </section>

        <!-- Python Worker -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon amber">&#9881;</div>
            <div class="card-title">Python Worker</div>
            <div id="pythonStatus" class="status-badge offline" style="margin-left:auto;">offline</div>
          </div>
          <p class="muted">Emergency restart only.</p>
          <div class="btn-group">
            <button class="btn" id="restartPython">Restart</button>
          </div>
          <p class="muted" id="pythonDetail" style="margin-top:6px;"></p>
        </section>

        <!-- Python Packages -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon amber">&#9875;</div>
            <div class="card-title">Python Packages</div>
          </div>
          <div class="card-desc">
            Download wheels into an on-device cache, then install offline.
            Source builds are typically not supported on Android.
          </div>
          <div class="field">
            <label>Package spec</label>
            <input type="text" id="pipSpec" placeholder="e.g. pyusb requests==2.32.3" />
          </div>
          <div style="margin-top:8px;display:flex;gap:14px;flex-wrap:wrap;">
            <label class="check-row"><input type="checkbox" id="pipWithDeps" checked /> Include dependencies</label>
            <label class="check-row"><input type="checkbox" id="pipOnlyBinary" checked /> Wheels only</label>
          </div>
          <div class="field" style="margin-top:10px;">
            <label>Index URL (optional)</label>
            <input type="url" id="pipIndexUrl" placeholder="https://pypi.org/simple" />
          </div>
          <div class="btn-group">
            <button class="btn" id="pipDownload">Download wheels</button>
            <button class="btn primary" id="pipInstallOffline">Install (offline)</button>
            <button class="btn" id="pipInstallNet">Install (network)</button>
          </div>
          <pre id="pipStatus" class="output-pre" style="margin-top:10px;"></pre>
          <pre id="pipOutput" class="output-pre"></pre>
        </section>

        <!-- UI Maintenance -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon red">&#9888;</div>
            <div class="card-title">UI Maintenance</div>
          </div>
          <div class="row">
            <span class="muted">Reset the UI files to defaults.</span>
            <button class="btn" id="resetUi">Reset UI</button>
          </div>
          <div class="row" style="margin-top:10px;">
            <span class="muted">Reset agent docs (AGENTS/TOOLS/docs) to defaults.</span>
            <button class="btn" id="resetAgentDocs">Reset Agent Docs</button>
          </div>
        </section>

        <!-- Permissions -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon green">&#9872;</div>
            <div class="card-title">Permissions</div>
          </div>
          <div class="card-desc">
            If enabled, tool approvals are remembered (until you clear them), similar to Android runtime permissions.
          </div>
          <div class="toggle-row">
            <label class="toggle">
              <input type="checkbox" id="permRemember" />
              <span class="slider"></span>
            </label>
            <span class="toggle-label">Remember approvals</span>
          </div>
          <div class="btn-group">
            <button class="btn" id="permClear">Clear saved approvals</button>
          </div>
        </section>

        <!-- Cloud -->
        <section class="card">
          <div class="card-header">
            <div class="card-icon blue">&#9729;</div>
            <div class="card-title">Cloud</div>
          </div>
          <div class="card-desc">
            Controls extra confirmations for cloud requests that upload local files.
          </div>
          <div class="field">
            <label>Auto-upload without confirm (MB)</label>
            <input type="number" id="cloudAutoUploadMb" min="0" max="25" step="0.5" placeholder="1.0" />
            <div class="muted" style="margin-top:4px;">
              If a cloud request uploads more than this, the UI/agent should confirm before sending.
            </div>
          </div>
          <div class="field">
            <label>Min transfer speed (KB/s)</label>
            <input type="number" id="cloudMinKbps" min="0" max="50000" step="50" placeholder="0" />
            <div class="muted" style="margin-top:4px;">
              If set (>0), abort cloud requests when average upload/download rate drops below this.
            </div>
          </div>
          <div class="field">
            <label style="display:flex; align-items:center; gap:10px;">
              <input type="checkbox" id="cloudImgResizeEnabled" />
              <span>Resize images before upload</span>
            </label>
            <div class="muted" style="margin-top:4px;">
              Reduces upload size for vision requests (helps avoid extra confirmations).
            </div>
          </div>
          <div class="field" style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
              <label>Max image dim (px)</label>
              <input type="number" id="cloudImgMaxDim" min="64" max="4096" step="64" placeholder="512" />
            </div>
            <div>
              <label>JPEG quality</label>
              <input type="number" id="cloudImgJpegQ" min="30" max="95" step="1" placeholder="70" />
            </div>
          </div>
          <div class="btn-group">
            <button class="btn primary" id="cloudPrefsSave">Save</button>
          </div>
        </section>
      </div>
    </div>

    <!-- PIN Modal -->
    <div class="modal" id="pinModal" role="dialog" aria-modal="true" aria-labelledby="pinTitle">
      <div class="modal-card">
        <div class="card-title" id="pinTitle">PIN Authentication</div>
        <div class="pin-code" id="pinCode">------</div>
        <div class="pin-countdown" id="pinCountdown">PIN inactive.</div>
        <div class="pin-bar" aria-hidden="true">
          <div id="pinBarFill" class="pin-bar-fill"></div>
        </div>
        <button class="btn danger" id="pinClose" style="width:100%;">End PIN</button>
      </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Fullscreen Media Viewer (images) -->
    <div class="viewer" id="viewer" role="dialog" aria-modal="true">
      <div class="viewer-top">
        <button class="icon-btn secondary" id="viewerClose" title="Close" aria-label="Close"></button>
        <div class="viewer-title" id="viewerTitle"></div>
        <button class="icon-btn" id="viewerShare" title="Share" aria-label="Share"></button>
      </div>
      <div class="viewer-body" id="viewerBody">
        <img class="viewer-img" id="viewerImg" alt="" />
      </div>
    </div>

    <script>
      // ==============================
      // Helpers
      // ==============================
      const API = location.origin;
      const WS_BASE = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      function $(id) { return document.getElementById(id); }

      const ICON = {
        settings: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-1.42 3.42h-.2a2 2 0 0 1-1.65-1.06l-.02-.04a1.65 1.65 0 0 0-1.51-.93 1.65 1.65 0 0 0-1.52.93l-.02.04A2 2 0 0 1 11.8 22h-.2a2 2 0 0 1-1.42-3.42l.06-.06A1.65 1.65 0 0 0 10.6 15a1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 0 1 5.63 6h.2a2 2 0 0 1 1.65 1.06l.02.04a1.65 1.65 0 0 0 1.51.93 1.65 1.65 0 0 0 1.52-.93l.02-.04A2 2 0 0 1 14.2 6h.2a2 2 0 0 1 1.42 3.42l-.06.06a1.65 1.65 0 0 0-.33 1.82 1.65 1.65 0 0 0 .33 1.82l.06.06A2 2 0 0 1 19.4 15Z"/></svg>',
        attach: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21.44 11.05 12.25 20.24a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.82-2.83l8.49-8.48"/></svg>',
        mic: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>',
        stop: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>',
        send: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>',
        back: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>',
        close: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M18 6 6 18"/><path d="M6 6l12 12"/></svg>',
        share: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><path d="M8.6 13.5 15.4 17.5"/><path d="M15.4 6.5 8.6 10.5"/></svg>',
      };

      // Set static button icons (record button is handled by setRecordUi()).
      try { $("openSettingsBtn").innerHTML = ICON.settings; } catch (_) {}
      try { $("chatUploadBtn").innerHTML = ICON.attach; } catch (_) {}
      try { $("chatSend").innerHTML = ICON.send; } catch (_) {}
      try { $("backToChatBtn").innerHTML = ICON.back; } catch (_) {}
      try { $("viewerClose").innerHTML = ICON.close; } catch (_) {}
      try { $("viewerShare").innerHTML = ICON.share; } catch (_) {}

      function showToast(msg, ms) {
        const t = $("toast");
        t.textContent = msg;
        t.classList.add("show");
        setTimeout(() => t.classList.remove("show"), ms || 2000);
      }

      // ==============================
      // Router
      // ==============================
      function navigateTo(pageId) {
        document.querySelectorAll(".page").forEach(p => p.classList.remove("active"));
        $(pageId).classList.add("active");
      }
      function handleHash() {
        const h = location.hash.replace("#", "") || "chat";
        if (h === "settings") {
          guardedOpenSettings();
        } else {
          navigateTo("chatPage");
        }
      }
      window.addEventListener("hashchange", handleHash);
      handleHash();

      $("openSettingsBtn").addEventListener("click", () => {
        location.hash = "settings";
      });
      $("backToChatBtn").addEventListener("click", () => {
        location.hash = "chat";
      });

      let pendingSettingsUnlock = null;
      function getSettingsUnlockRemainingMs() {
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getSettingsUnlockRemainingMs) {
            const v = Number(AndroidBridge.getSettingsUnlockRemainingMs());
            return isFinite(v) ? Math.max(0, v) : 0;
          }
        } catch (_) {}
        return 0;
      }

      function setSettingsUiLocked(locked) {
        try {
          $("brainApiKey").disabled = locked;
          $("braveSearchApiKey").disabled = locked;
        } catch (_) {}
      }

      function requestSettingsUnlock() {
        if (pendingSettingsUnlock) return pendingSettingsUnlock;
        pendingSettingsUnlock = new Promise((resolve) => {
          window.__resolveSettingsUnlock = resolve;
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.requestSettingsUnlock) {
              AndroidBridge.requestSettingsUnlock();
            } else {
              resolve({ ok: true, remaining_ms: 30000, fallback: true });
            }
          } catch (_) {
            resolve({ ok: false });
          }
        }).finally(() => { pendingSettingsUnlock = null; });
        return pendingSettingsUnlock;
      }

      window.onSettingsUnlockResult = function(payload) {
        try {
          if (window.__resolveSettingsUnlock) {
            window.__resolveSettingsUnlock(payload || { ok: false });
            window.__resolveSettingsUnlock = null;
          }
        } catch (_) {}
      };

      function refreshSecretsFromBridge() {
        const locked = getSettingsUnlockRemainingMs() <= 0;
        setSettingsUiLocked(locked);
        if (locked) {
          $("brainApiKey").value = "";
          $("brainApiKey").placeholder = "(locked)";
          $("braveSearchApiKey").value = "";
          $("braveSearchApiKey").placeholder = "(locked)";
          return;
        }
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBrainApiKeyPlain) {
            $("brainApiKey").value = AndroidBridge.getBrainApiKeyPlain() || "";
            $("brainApiKey").placeholder = "";
          }
        } catch (_) {}
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.getBraveSearchApiKeyPlain) {
            $("braveSearchApiKey").value = AndroidBridge.getBraveSearchApiKeyPlain() || "";
            $("braveSearchApiKey").placeholder = "";
          }
        } catch (_) {}
      }

      async function guardedOpenSettings() {
        if (getSettingsUnlockRemainingMs() <= 0) {
          const r = await requestSettingsUnlock();
          if (!r || !r.ok) {
            showToast("Settings locked", 1600);
            location.hash = "chat";
            return;
          }
        }
        navigateTo("settingsPage");
        refreshSecretsFromBridge();
        if (typeof loadMemory === "function") loadMemory();
        if (typeof checkBraveSearchKey === "function") checkBraveSearchKey();
        if (typeof loadBrainConfig === "function") loadBrainConfig();
      }

      async function ensureSettingsUnlocked() {
        if (getSettingsUnlockRemainingMs() > 0) return true;
        const brainBefore = $("brainApiKey").value;
        const braveBefore = $("braveSearchApiKey").value;
        const r = await requestSettingsUnlock();
        if (!r || !r.ok) {
          showToast("Settings locked", 1600);
          return false;
        }
        setSettingsUiLocked(false);
        if (!brainBefore && !braveBefore) {
          refreshSecretsFromBridge();
        }
        return true;
      }

      // ==============================
      // Markdown renderer (minimal)
      // ==============================
      function renderMarkdown(text) {
        let h = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Fenced code blocks
        h = h.replace(/```(\w*)\n([\s\S]*?)```/g, function(_, lang, code) {
          return "<pre><code>" + code.replace(/<br\s*\/?>/g, "\n") + "</code></pre>";
        });

        // Inline code
        h = h.replace(/`([^`\n]+)`/g, "<code>$1</code>");

        // Bold
        h = h.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");

        // Italic
        h = h.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, "<em>$1</em>");

        // Blockquote lines
        h = h.replace(/(^|\n)&gt; (.+)/g, "$1<blockquote>$2</blockquote>");

        // Paragraphs
        h = h.replace(/\n\n+/g, "</p><p>");
        h = "<p>" + h + "</p>";
        h = h.replace(/<p><\/p>/g, "");

        // Single newlines -> <br> (not inside <pre>)
        const parts = h.split(/(<pre[\s\S]*?<\/pre>)/g);
        for (let i = 0; i < parts.length; i++) {
          if (!parts[i].startsWith("<pre")) {
            parts[i] = parts[i].replace(/\n/g, "<br>");
          }
        }
        h = parts.join("");

        return h;
      }

      // ==============================
      // Media helpers
      // ==============================
      function extOf(name) {
        const n = String(name || "").trim().toLowerCase();
        const i = n.lastIndexOf(".");
        return i >= 0 ? n.slice(i + 1) : "";
      }
      function kindFor(name) {
        const e = extOf(name);
        if (["png","jpg","jpeg","gif","webp","bmp","svg"].includes(e)) return "image";
        if (["mp4","webm","mkv","mov","m4v","3gp"].includes(e)) return "video";
        if (["mp3","wav","ogg","m4a","aac","flac","webm"].includes(e)) return "audio";
        if (["txt","md","json","log","py","js","html","css"].includes(e)) return "text";
        return "bin";
      }

      function mimeForPath(p) {
        const e = extOf(p);
        if (["png"].includes(e)) return "image/png";
        if (["jpg","jpeg"].includes(e)) return "image/jpeg";
        if (["gif"].includes(e)) return "image/gif";
        if (["webp"].includes(e)) return "image/webp";
        if (["svg"].includes(e)) return "image/svg+xml";
        if (["mp4","m4v"].includes(e)) return "video/mp4";
        if (["webm"].includes(e)) return "video/webm";
        if (["mov"].includes(e)) return "video/quicktime";
        if (["3gp"].includes(e)) return "video/3gpp";
        if (["mp3"].includes(e)) return "audio/mpeg";
        if (["wav"].includes(e)) return "audio/wav";
        if (["ogg"].includes(e)) return "audio/ogg";
        if (["m4a","aac"].includes(e)) return "audio/aac";
        if (["flac"].includes(e)) return "audio/flac";
        if (["json"].includes(e)) return "application/json";
        if (["txt","md","log","py","js","html","css"].includes(e)) return "text/plain";
        return "application/octet-stream";
      }

      function safeRelPath(p) {
        // Normalize common "rel_path:" render variants:
        // - Trailing punctuation: "captures/latest.jpg." or "...jpg," breaks ext detection.
        // - Wrapped in quotes/backticks/brackets.
        let s = String(p || "").trim();
        s = s.replace(/^\/+/, "");
        s = s.replace(/^["'`<(\[]+/, "");
        s = s.replace(/["'`>\])]+$/, "");
        s = s.replace(/[.,;:]+$/, "");
        if (!s) return "";
        if (s.split("/").some(seg => seg === "..")) return "";
        return s;
      }

      function extractRelPathsFromText(text) {
        const t = String(text || "");
        const out = [];
        const seen = new Set();

        // JSON-ish: "rel_path":"captures/foo.jpg"
        const reJson = /"rel_path"\s*:\s*"([^"]+)"/gi;
        let m;
        while ((m = reJson.exec(t)) !== null) {
          const p = safeRelPath(m[1]);
          if (p && !seen.has(p)) { out.push(p); seen.add(p); }
        }

        // Plain: rel_path: captures/foo.jpg
        // Also support spaces by capturing to end-of-line (common for uploaded filenames like "Slack - Ding.mp3").
        const rePlainQuoted = /\brel_path\b\s*[:=]\s*`([^`]+)`/gi;
        while ((m = rePlainQuoted.exec(t)) !== null) {
          const p = safeRelPath(m[1]);
          if (p && !seen.has(p)) { out.push(p); seen.add(p); }
        }
        const rePlainEol = /\brel_path\b\s*[:=]\s*([^\r\n]+)/gi;
        while ((m = rePlainEol.exec(t)) !== null) {
          const p = safeRelPath(m[1]);
          if (p && !seen.has(p)) { out.push(p); seen.add(p); }
        }

        // Loose fallback (common folders + media extensions).
        const reLoose = /\b(?:captures|uploads|downloads)\/[a-zA-Z0-9._\-\/]+\.(?:png|jpe?g|gif|webp|bmp|svg|mp4|webm|mkv|mov|m4v|3gp|mp3|wav|ogg|m4a|aac|flac)\b/gi;
        while ((m = reLoose.exec(t)) !== null) {
          const p = safeRelPath(m[0]);
          if (p && !seen.has(p)) { out.push(p); seen.add(p); }
        }

        return out.slice(0, 4);
      }

      function renderInlineAttachments(msgDiv, rawText) {
        const paths = extractRelPathsFromText(rawText);
        if (!paths.length) return;

        // Avoid duplicating attachment cards when the same bubble is re-rendered/upgraded
        // by polling/rotation recovery.
        try {
          const old = msgDiv.querySelector(".attach-wrap");
          if (old) old.remove();
        } catch (_) {}

        const wrap = document.createElement("div");
        wrap.className = "attach-wrap";

        for (const p0 of paths) {
          const p = safeRelPath(p0);
          if (!p) continue;
          const kind = kindFor(p);
          const card = document.createElement("div");
          card.className = "attach-card";

          const head = document.createElement("div");
          head.className = "attach-head";
          const pathEl = document.createElement("div");
          pathEl.className = "attach-path";
          pathEl.textContent = p;
          const actions = document.createElement("div");
          actions.className = "attach-actions";
          const shareBtn = document.createElement("button");
          shareBtn.className = "attach-icon-btn";
          shareBtn.title = "Share";
          shareBtn.setAttribute("aria-label", "Share");
          shareBtn.innerHTML = ICON.share;
          shareBtn.addEventListener("click", async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            try {
              if (typeof AndroidBridge !== "undefined" && AndroidBridge.shareUserFile) {
                AndroidBridge.shareUserFile(p, mimeForPath(p));
              } else {
                showToast("Share not available", 1600);
              }
            } catch (_) {
              showToast("Share failed", 1800);
            }
          });
          actions.appendChild(shareBtn);
          head.appendChild(pathEl);
          head.appendChild(actions);

          const body = document.createElement("div");
          body.className = "attach-body";
          const hint = document.createElement("div");
          hint.className = "attach-hint";
          hint.textContent = "Loading preview...";

          card.appendChild(head);
          card.appendChild(body);
          card.appendChild(hint);

          wrap.appendChild(card);

          (async () => {
            try {
              const src = API + "/user/file?path=" + encodeURIComponent(p);
              if (kind === "image") {
                const img = document.createElement("img");
                img.alt = p;
                img.loading = "lazy";
                img.src = src;
                img.dataset.relPath = p;
                img.style.cursor = "zoom-in";
                const open = () => { try { openViewerFor(p); } catch (_) {} };
                img.addEventListener("click", open);
                card.addEventListener("click", (ev) => {
                  // Don't steal clicks from the Share icon.
                  if (ev.target && (ev.target.closest && ev.target.closest(".attach-icon-btn"))) return;
                  open();
                });
                img.addEventListener("error", () => { hint.textContent = "Preview failed"; });
                img.addEventListener("load", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                body.appendChild(img);
                hint.textContent = "Image (tap to zoom)";
              } else if (kind === "video") {
                const v = document.createElement("video");
                v.controls = true;
                v.playsInline = true;
                v.preload = "metadata";
                v.src = src;
                v.addEventListener("loadedmetadata", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                body.appendChild(v);
                hint.textContent = "Video";
              } else if (kind === "audio") {
                const a = document.createElement("audio");
                a.controls = true;
                a.preload = "metadata";
                a.src = src;
                a.addEventListener("loadedmetadata", () => { try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {} });
                body.appendChild(a);
                hint.textContent = "Audio";
              } else {
                hint.textContent = "No inline preview for this file type.";
              }
            } catch (e) {
              hint.textContent = "Preview failed.";
            }
          })();
        }

        if (wrap.childNodes.length) {
          msgDiv.appendChild(wrap);
          try { if (stickToBottom) scrollToBottomSoon(); } catch (_) {}
        }
      }

      // ==============================
      // Fullscreen image viewer (tap image, pinch zoom, swipe)
      // ==============================
      const viewer = $("viewer");
      const viewerClose = $("viewerClose");
      const viewerShare = $("viewerShare");
      const viewerTitle = $("viewerTitle");
      const viewerImg = $("viewerImg");
      const viewerBody = $("viewerBody");

      let viewerPaths = [];
      let viewerIndex = 0;
      let vScale = 1.0;
      let vTx = 0.0;
      let vTy = 0.0;
      let vTouchMode = "";
      let vStartDist = 0.0;
      let vStartScale = 1.0;
      let vStartTx = 0.0;
      let vStartTy = 0.0;
      let vStartX = 0.0;
      let vStartY = 0.0;
      let vSwipeStartX = 0.0;
      let vSwipeStartY = 0.0;
      let vSwipeAt = 0;

      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
      function applyViewerTransform() {
        viewerImg.style.transform = `translate(${vTx}px, ${vTy}px) scale(${vScale})`;
      }
      function resetViewerTransform() {
        vScale = 1.0; vTx = 0.0; vTy = 0.0;
        applyViewerTransform();
      }
      function collectViewerPaths() {
        const imgs = Array.from(document.querySelectorAll('.attach-body img[data-rel-path]'));
        const out = [];
        const seen = new Set();
        for (const im of imgs) {
          const p = safeRelPath(im.dataset.relPath || "");
          if (p && !seen.has(p)) { out.push(p); seen.add(p); }
        }
        return out;
      }
      async function setViewerImage(p) {
        const rel = safeRelPath(p);
        if (!rel) return;
        viewerTitle.textContent = rel;
        viewerImg.src = API + "/user/file?path=" + encodeURIComponent(rel);
        viewerImg.alt = rel;
        resetViewerTransform();
      }
      async function openViewerFor(p) {
        const rel = safeRelPath(p);
        if (!rel) return;
        viewerPaths = collectViewerPaths();
        const idx = viewerPaths.indexOf(rel);
        viewerIndex = idx >= 0 ? idx : 0;
        viewer.classList.add("show");
        await setViewerImage(rel);
      }
      function closeViewer() {
        viewer.classList.remove("show");
        viewerImg.src = "";
        viewerPaths = [];
        viewerIndex = 0;
        resetViewerTransform();
      }
      async function viewerNext(dir) {
        if (!viewerPaths.length) return;
        viewerIndex = (viewerIndex + dir + viewerPaths.length) % viewerPaths.length;
        await setViewerImage(viewerPaths[viewerIndex]);
      }

      viewerClose.addEventListener("click", closeViewer);
      viewer.addEventListener("click", (ev) => {
        if (ev.target === viewer) closeViewer();
      });
      viewerShare.addEventListener("click", async () => {
        const p = viewerTitle.textContent || "";
        const rel = safeRelPath(p);
        if (!rel) return;
        try {
          if (typeof AndroidBridge !== "undefined" && AndroidBridge.shareUserFile) {
            AndroidBridge.shareUserFile(rel, mimeForPath(rel));
          } else {
            showToast("Share not available", 1600);
          }
        } catch (_) {
          showToast("Share failed", 1800);
        }
      });

      function dist2(a, b) {
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy);
      }

      viewerBody.addEventListener("touchstart", (ev) => {
        if (!viewer.classList.contains("show")) return;
        if (!ev.touches || ev.touches.length === 0) return;
        if (ev.touches.length === 2) {
          vTouchMode = "pinch";
          vStartDist = dist2(ev.touches[0], ev.touches[1]);
          vStartScale = vScale;
          vStartTx = vTx;
          vStartTy = vTy;
        } else {
          vTouchMode = (vScale > 1.02) ? "pan" : "swipe";
          vStartX = ev.touches[0].clientX;
          vStartY = ev.touches[0].clientY;
          vStartTx = vTx;
          vStartTy = vTy;
          vSwipeStartX = vStartX;
          vSwipeStartY = vStartY;
          vSwipeAt = Date.now();
        }
      }, { passive: false });

      viewerBody.addEventListener("touchmove", (ev) => {
        if (!viewer.classList.contains("show")) return;
        if (!ev.touches || ev.touches.length === 0) return;
        ev.preventDefault();
        if (ev.touches.length === 2) {
          vTouchMode = "pinch";
          const d = dist2(ev.touches[0], ev.touches[1]);
          const ratio = vStartDist > 0 ? (d / vStartDist) : 1.0;
          vScale = clamp(vStartScale * ratio, 1.0, 6.0);
          applyViewerTransform();
          return;
        }
        const x = ev.touches[0].clientX;
        const y = ev.touches[0].clientY;
        const dx = x - vStartX;
        const dy = y - vStartY;
        if (vTouchMode === "pan") {
          vTx = vStartTx + dx;
          vTy = vStartTy + dy;
          applyViewerTransform();
        } else if (vTouchMode === "swipe") {
          // Small visual feedback: translate a bit.
          vTx = dx;
          vTy = 0;
          applyViewerTransform();
        }
      }, { passive: false });

      viewerBody.addEventListener("touchend", async (ev) => {
        if (!viewer.classList.contains("show")) return;
        const now = Date.now();
        if (vTouchMode === "swipe") {
          const dx = vTx;
          const dt = Math.max(1, now - vSwipeAt);
          const vx = dx / dt; // px/ms
          resetViewerTransform();
          if (Math.abs(dx) > 90 || Math.abs(vx) > 0.7) {
            await viewerNext(dx < 0 ? +1 : -1);
          }
        } else if (vTouchMode === "pinch") {
          if (vScale < 1.02) resetViewerTransform();
        }
        vTouchMode = "";
      }, { passive: false });

      viewerImg.addEventListener("dblclick", (ev) => {
        ev.preventDefault();
        resetViewerTransform();
      });

      // ==============================
      // Chat
      // ==============================
      const chatMessages = $("chatMessages");
      const chatInput = $("chatInput");
      const chatSend = $("chatSend");
      const chatWelcome = $("chatWelcome");
      const CHAT_STORAGE_PREFIX = "kugutz.chat.conversation.v1.";
      const CHAT_SESSION_KEY = "kugutz.chat.session_id.v1";
      let conversation = [];
      let streaming = false;
      let chatSessionId = "";
      let lastServerTs = 0;
      let stickToBottom = true;

      function genSessionId() {
        return "s_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 10);
      }

      function loadSessionId() {
        try {
          const existing = localStorage.getItem(CHAT_SESSION_KEY);
          if (existing && typeof existing === "string" && existing.trim()) return existing.trim();
        } catch (_) {}
        const created = genSessionId();
        try { localStorage.setItem(CHAT_SESSION_KEY, created); } catch (_) {}
        return created;
      }
      chatSessionId = loadSessionId();

      function convoStorageKey() {
        return CHAT_STORAGE_PREFIX + chatSessionId;
      }

      function saveConversation() {
        try {
          localStorage.setItem(convoStorageKey(), JSON.stringify(conversation));
        } catch (_) {}
      }

      function restoreConversation() {
        try {
          const raw = localStorage.getItem(convoStorageKey());
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return;
          // Keep meta/ts so we can de-dupe/upgrade by item_id after rotation.
          conversation = parsed.filter(m =>
            m && (m.role === "user" || m.role === "assistant") && typeof m.content === "string"
          ).map(m => ({
            role: m.role,
            content: m.content,
            meta: (m.meta && typeof m.meta === "object") ? m.meta : {},
            ts: Number(m.ts || 0) || 0,
          }));
          for (const msg of conversation) {
            addMsg(msg.role, msg.content, Object.assign({}, msg.meta || {}, { _ts: msg.ts || 0 }));
          }
        } catch (_) {}
      }

      function isNearBottom(el, slackPx) {
        try {
          const slack = typeof slackPx === "number" ? slackPx : 120;
          return (el.scrollHeight - el.scrollTop - el.clientHeight) <= slack;
        } catch (_) {
          return true;
        }
      }

      function scrollToBottomSoon() {
        if (!chatMessages) return;
        requestAnimationFrame(() => {
          try { chatMessages.scrollTop = chatMessages.scrollHeight; } catch (_) {}
        });
      }

      chatMessages.addEventListener("scroll", () => {
        stickToBottom = isNearBottom(chatMessages, 140);
      }, { passive: true });

      function addMsg(role, content, meta) {
        if (chatWelcome.parentNode) chatWelcome.remove();
        const shouldScroll = isNearBottom(chatMessages, 140);
        const div = document.createElement("div");
        const m = (meta && typeof meta === "object") ? meta : {};
        const isDebug = !!(m.debug);
        const actorRaw = (m.actor && typeof m.actor === "string") ? m.actor : "";
        const actor = actorRaw.trim().toLowerCase();
        const actorClass = actor ? (" actor-" + actor.replace(/[^a-z0-9_-]/g, "")) : "";
        div.className = "msg " + role + (isDebug ? " debug" : "") + actorClass;
        if (m.item_id) div.dataset.itemId = String(m.item_id);
        if (m.session_id) div.dataset.sessionId = String(m.session_id);
        if (m.debug) div.dataset.debug = "1";
        if (actor) div.dataset.actor = actor;
        if (meta && meta._ts) div.dataset.ts = String(meta._ts);
        if (role === "assistant" || role === "user") {
          div.innerHTML = renderMarkdown(content);
          // Attachments should render for both user and assistant messages.
          try { renderInlineAttachments(div, content); } catch (_) {}
        } else {
          div.textContent = content;
        }
        chatMessages.appendChild(div);
        if (shouldScroll || isDebug || stickToBottom) scrollToBottomSoon();
        return div;
      }

      function setMsgWorking(div, working) {
        if (!div) return;
        const existing = div.querySelector(".msg-working");
        if (!working) {
          if (existing) existing.remove();
          return;
        }
        // If this bubble is already the dedicated thinking placeholder (has dots),
        // don't add a second set of dots.
        if (div.querySelector(".thinking-dots")) return;
        if (existing) return;
        const w = document.createElement("div");
        w.className = "msg-working";
        w.innerHTML = '<div class="thinking-dots mini"><span></span><span></span><span></span></div>';
        div.appendChild(w);
      }

      function markWorkingByItemId(itemId) {
        if (!itemId) return;
        const div = findRenderedByItem("assistant", itemId);
        if (div) setMsgWorking(div, true);
      }

      function clearWorkingByItemId(itemId) {
        if (!itemId) return;
        const div = findRenderedByItem("assistant", itemId);
        if (div) setMsgWorking(div, false);
      }

      function upsertConversationEntry(role, itemId, text, meta, ts) {
        if (!itemId) return;
        const rid = String(itemId);
        for (let i = conversation.length - 1; i >= 0; i--) {
          const m = conversation[i];
          const mi = m && m.meta ? (m.meta.item_id || m.meta.itemId || "") : "";
          if (m && m.role === role && String(mi) === rid) {
            m.content = text;
            m.meta = Object.assign({}, m.meta || {}, meta || {});
            if (ts) m.ts = ts;
            return;
          }
        }
        conversation.push({ role, content: text, meta: meta || {}, ts: ts || Date.now() });
      }

      function addThinkingIndicator() {
        if (chatWelcome.parentNode) chatWelcome.remove();
        const shouldScroll = isNearBottom(chatMessages, 140);
        const div = document.createElement("div");
        div.className = "msg assistant";
        div.innerHTML = '<div class="thinking-dots"><span></span><span></span><span></span></div>';
        chatMessages.appendChild(div);
        if (shouldScroll || stickToBottom) scrollToBottomSoon();
        return div;
      }

      async function syncConversationFromServer() {
        try {
          const res = await fetch(API + "/brain/messages?limit=300&session_id=" + encodeURIComponent(chatSessionId));
          if (!res.ok) return;
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          const rebuilt = [];
          let maxTs = 0;
          // Track tool activity to restore working indicators after rotation.
          const lastToolTsByItem = new Map();
          const lastAssistantTsByItem = new Map();
          for (const msg of list) {
            if (!msg) continue;
            const role = msg.role;
            if (typeof msg.text !== "string" || !msg.text.trim()) continue;
            maxTs = Math.max(maxTs, Number(msg.ts || 0));
            const meta = (msg.meta && typeof msg.meta === "object") ? msg.meta : {};
            const itemId = meta.item_id || meta.itemId || "";
            const ts = Number(msg.ts || 0) || 0;
            if (role === "tool" && itemId) {
              const cur = Number(lastToolTsByItem.get(itemId) || 0);
              if (ts > cur) lastToolTsByItem.set(itemId, ts);
              continue;
            }
            if (role === "assistant" && itemId) {
              const cur = Number(lastAssistantTsByItem.get(itemId) || 0);
              if (ts > cur) lastAssistantTsByItem.set(itemId, ts);
            }
            if (role !== "user" && role !== "assistant") continue;
            rebuilt.push({ role: role, content: msg.text, meta: meta, ts: ts });
          }
          if (!rebuilt.length) return;
          lastServerTs = Math.max(lastServerTs, maxTs);
          conversation = rebuilt.slice(-200).map(m => ({ role: m.role, content: m.content, meta: m.meta || {}, ts: m.ts || 0 }));
          chatMessages.textContent = "";
          for (const msg of conversation) addMsg(msg.role, msg.content, Object.assign({}, msg.meta || {}, { _ts: msg.ts || 0 }));
          // Restore working indicators for items that have tool activity after the last assistant bubble.
          for (const [itemId, tTs] of lastToolTsByItem.entries()) {
            const aTs = Number(lastAssistantTsByItem.get(itemId) || 0);
            if (tTs > aTs) markWorkingByItemId(itemId);
          }
          saveConversation();
        } catch (_) {}
      }

      function findRenderedByItem(role, itemId) {
        if (!itemId) return null;
        try {
          const esc = (typeof CSS !== "undefined" && CSS.escape) ? CSS.escape : (s) => String(s).replace(/"/g, '\\"');
          // There can be multiple bubbles with the same item_id (e.g., permission required + approved).
          // Always target the most recent one so "working" dots attach to the right bubble.
          const nodes = chatMessages.querySelectorAll('.msg.' + role + '[data-item-id="' + esc(String(itemId)) + '"]');
          return (nodes && nodes.length) ? nodes[nodes.length - 1] : null;
        } catch (_) {
          return null;
        }
      }

      async function pollServerMessages() {
        // Keep chat UI updated even when messages are injected by the system (e.g., debug comments).
        if (!chatSessionId) return;
        try {
          const res = await fetch(API + "/brain/messages?limit=200&session_id=" + encodeURIComponent(chatSessionId));
          if (!res.ok) return;
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          let maxTs = lastServerTs;
          for (const msg of list) {
            if (!msg) continue;
            const text = (typeof msg.text === "string") ? msg.text.trim() : "";
            if (!text) continue;
            const ts = Number(msg.ts || 0);
            const meta = (msg && msg.meta && typeof msg.meta === "object") ? msg.meta : {};
            maxTs = Math.max(maxTs, ts);
            if (ts && ts <= lastServerTs) continue;

            // De-dupe: if we already rendered this item_id bubble locally, upgrade it instead of appending.
            const itemId = meta.item_id || "";
            if (msg.role === "tool") {
              // Tool messages are not rendered, but they indicate the agent is actively working.
              if (itemId) markWorkingByItemId(itemId);
              continue;
            }
            if (msg.role !== "user" && msg.role !== "assistant") continue;
            if (itemId) {
              const existing = findRenderedByItem(msg.role, itemId);
              if (existing) {
                existing.dataset.ts = String(ts || "");
                if (meta.debug) existing.classList.add("debug");
                if (msg.role === "assistant" && existing.querySelector(".thinking-dots")) {
                  existing.innerHTML = renderMarkdown(text);
                }
                // Always refresh attachments and persist upgraded content for rotation recovery.
                try { renderInlineAttachments(existing, text); } catch (_) {}
                upsertConversationEntry(msg.role, itemId, text, meta, ts);
                if (msg.role === "assistant") clearWorkingByItemId(itemId);
                // Permission resume events: show working indicator for the resumed item id.
                try {
                  const rid = (meta && (meta.resume_item_id || meta.resumeItemId)) ? String(meta.resume_item_id || meta.resumeItemId) : "";
                  if (rid) markWorkingByItemId(rid);
                } catch (_) {}
                continue;
              }
            }

            addMsg(msg.role, text, Object.assign({}, meta, { _ts: ts }));
            conversation.push({ role: msg.role, content: text, meta: meta, ts: ts });
            if (msg.role === "assistant" && itemId) clearWorkingByItemId(itemId);
            try {
              const rid = (meta && (meta.resume_item_id || meta.resumeItemId)) ? String(meta.resume_item_id || meta.resumeItemId) : "";
              if (rid) markWorkingByItemId(rid);
            } catch (_) {}
          }
          if (maxTs > lastServerTs) {
            lastServerTs = maxTs;
            conversation = conversation.slice(-220);
            saveConversation();
          }
        } catch (_) {}
      }

      function autoResize() {
        chatInput.style.height = "auto";
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + "px";
      }
      chatInput.addEventListener("input", autoResize);
      chatInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendChat(); }
      });
      chatSend.addEventListener("click", sendChat);
      restoreConversation();
      syncConversationFromServer();
      setInterval(pollServerMessages, 900);

      async function sendChat() {
        if (streaming) return;
        const text = chatInput.value.trim();
        const hasAtt = pendingAttachments.length > 0;
        if (!text && !hasAtt) return;
        stickToBottom = true;

        // Render a local echo immediately with file chips info; actual upload happens before agent call.
        chatInput.value = "";
        autoResize();

        const previewLines = [];
        if (text) previewLines.push(text);
        for (const a of pendingAttachments) {
          previewLines.push("`" + a.name + "`");
        }
        const previewText = previewLines.join("\n");

        conversation.push({ role: "user", content: previewText, meta: { local_echo: true }, ts: Date.now() });
        saveConversation();
        const uDiv = addMsg("user", previewText, { local_echo: true, uploading: hasAtt });

        // Upload attachments (if any) then send a final message with rel_path lines.
        const finalText = await finalizeAndUploadAttachments(text, uDiv);
        await sendAgentChat(finalText, uDiv);
      }

      async function sendAgentChat(text, uDiv) {
        streaming = true;
        chatSend.disabled = true;
        const aDiv = addThinkingIndicator();
        try {
          async function readError(res, fallbackPrefix) {
            const raw = await res.text().catch(() => "");
            try {
              const obj = raw ? JSON.parse(raw) : {};
              const msg = (obj && (obj.error || obj.detail || obj.message)) ? (obj.error || obj.detail || obj.message) : "";
              if (msg) return msg;
            } catch (_) {}
            if (raw && raw.trim()) return raw.trim().slice(0, 200);
            return fallbackPrefix + " (" + res.status + ")";
          }

          const boot = await fetch(API + "/brain/agent/bootstrap", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: "{}",
          });
          if (!boot.ok) {
            throw new Error(await readError(boot, "Agent bootstrap failed"));
          }

          const res = await fetch(API + "/brain/inbox/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ text, meta: { source: "chat_ui", session_id: chatSessionId } }),
          });
          if (!res.ok) {
            throw new Error(await readError(res, "Agent queue failed"));
          }
          const queued = await res.json();
          const itemId = queued.id || "";
          if (!itemId) {
            throw new Error("Agent item id missing");
          }
          try {
            if (uDiv) uDiv.dataset.itemId = String(itemId);
            aDiv.dataset.itemId = String(itemId);
          } catch (_) {}
          // Persist item_id on the local-echo user message so it survives rotation and can be upgraded.
          try {
            for (let i = conversation.length - 1; i >= 0; i--) {
              const m = conversation[i];
              if (m && m.role === "user" && m.meta && m.meta.local_echo && !m.meta.item_id) {
                m.meta.item_id = String(itemId);
                break;
              }
            }
            saveConversation();
          } catch (_) {}

          const answer = await waitForAgentReply(itemId);
          if (!answer) {
            throw new Error("Agent timed out");
          }
          const memRe = /<<MEMORY_UPDATE>>([\s\S]*?)<<END_MEMORY>>/g;
          const cleaned = (answer || "").replace(memRe, "").trim();

          if (cleaned) {
            aDiv.innerHTML = renderMarkdown(cleaned);
            try { renderInlineAttachments(aDiv, cleaned); } catch (_) {}
            setMsgWorking(aDiv, false);
            conversation.push({ role: "assistant", content: cleaned, meta: { item_id: itemId }, ts: Date.now() });
            saveConversation();
          } else {
            aDiv.remove();
          }
        } catch (err) {
          if (aDiv.parentNode) aDiv.remove();
          const msg = err.message || "Agent request failed";
          const friendly = {
            "brain_not_configured": "Configure Brain in Settings first.",
            "agent_vendor_not_supported": "Agent mode currently supports OpenAI-compatible providers only.",
          };
          addMsg("error", friendly[msg] || msg);
        } finally {
          streaming = false;
          chatSend.disabled = false;
        }
      }

      // ==============================
      // Pending attachments (Slack-like)
      // ==============================
      const composerAttachments = $("composerAttachments");
      let pendingAttachments = [];
      let uploadBusy = false;
      let recordingBusy = false;

      function fmtBytes(n) {
        const v = Number(n || 0);
        if (!isFinite(v) || v <= 0) return "0 B";
        const units = ["B","KB","MB","GB"];
        let x = v, u = 0;
        while (x >= 1024 && u < units.length - 1) { x /= 1024; u++; }
        return (u === 0 ? String(Math.round(x)) : x.toFixed(1)) + " " + units[u];
      }

      function renderComposerAttachments() {
        if (!composerAttachments) return;
        composerAttachments.innerHTML = "";
        if (!pendingAttachments.length) {
          composerAttachments.classList.remove("show");
          return;
        }
        composerAttachments.classList.add("show");
        pendingAttachments.forEach((a, idx) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          const name = document.createElement("div");
          name.className = "chip-name";
          name.textContent = a.name;
          const sub = document.createElement("div");
          sub.className = "chip-sub";
          sub.textContent = a.size ? fmtBytes(a.size) : (a.kind === "recording" ? "recording" : "");
          const x = document.createElement("button");
          x.className = "chip-x";
          x.title = "Remove";
          x.setAttribute("aria-label", "Remove");
          x.textContent = "x";
          x.addEventListener("click", () => {
            // Revoke object URLs if we created any.
            if (a._localUrl) { try { URL.revokeObjectURL(a._localUrl); } catch (_) {} }
            pendingAttachments.splice(idx, 1);
            renderComposerAttachments();
          });
          chip.appendChild(name);
          chip.appendChild(sub);
          chip.appendChild(x);
          composerAttachments.appendChild(chip);
        });
      }

      function addPendingFile(f) {
        if (!f) return;
        pendingAttachments.push({
          kind: "file",
          name: String(f.name || "file"),
          size: Number(f.size || 0),
          file: f,
        });
        renderComposerAttachments();
      }

      function addPendingRecording(blob, name) {
        if (!blob) return;
        pendingAttachments.push({
          kind: "recording",
          name: String(name || ("recording_" + Date.now() + ".webm")),
          size: Number(blob.size || 0),
          blob: blob,
        });
        renderComposerAttachments();
      }

      async function finalizeAndUploadAttachments(comment, uDiv) {
        const text = String(comment || "").trim();
        if (!pendingAttachments.length) return text || "(no text)";
        if (uploadBusy) return text || "(upload in progress)";
        uploadBusy = true;
        chatSend.disabled = true;

        // Copy and clear composer immediately (so user can continue composing next message).
        const items = pendingAttachments.slice();
        pendingAttachments = [];
        renderComposerAttachments();

        const rels = [];
        for (const a of items) {
          try {
            const fd = new FormData();
            if (a.kind === "file") {
              fd.append("file", a.file, a.name);
              fd.append("dir", "uploads/chat");
            } else {
              fd.append("file", a.blob, a.name);
              fd.append("dir", "uploads/recordings");
            }
            const res = await fetch(API + "/user/upload", { method: "POST", body: fd });
            const data = await res.json().catch(() => ({}));
            if (res.ok && data && data.path) {
              rels.push(String(data.path));
            } else {
              rels.push("");
              addMsg("assistant", "Attachment upload failed: " + a.name + " -> " + JSON.stringify(data), { debug: true });
            }
          } catch (e) {
            rels.push("");
            addMsg("assistant", "Attachment upload error: " + a.name + " -> " + String(e), { debug: true });
          }
        }

        const lines = [];
        if (text) lines.push(text);
        for (const p of rels.filter(Boolean)) {
          lines.push("rel_path: " + p);
        }
        const finalText = lines.join("\n");

        // Update local echo bubble with final message so inline media renders.
        try {
          uDiv.innerHTML = renderMarkdown(finalText);
          try { renderInlineAttachments(uDiv, finalText); } catch (_) {}
        } catch (_) {}

        uploadBusy = false;
        chatSend.disabled = false;
        saveConversation();
        return finalText || "(sent)";
      }

      // Chat-left media buttons (attach + record)
      (function initChatAttachAndRecord() {
        const uploadBtn = $("chatUploadBtn");
        const uploadInput = $("chatUploadInput");
        const recBtn = $("chatRecordBtn");
        let rStream = null;
        let rRec = null;
        let rChunks = [];
        if (uploadBtn && uploadInput) {
          uploadBtn.addEventListener("click", () => uploadInput.click());
          uploadInput.addEventListener("change", () => {
            const list = uploadInput.files ? Array.from(uploadInput.files) : [];
            list.forEach(addPendingFile);
            uploadInput.value = "";
          });
        }

        function setRecordUi(recording) {
          if (!recBtn) return;
          if (recording) {
            recBtn.classList.add("danger");
            recBtn.title = "Stop recording";
            recBtn.setAttribute("aria-label", "Stop recording");
            recBtn.innerHTML = ICON.stop;
          } else {
            recBtn.classList.remove("danger");
            recBtn.title = "Record audio";
            recBtn.setAttribute("aria-label", "Record audio");
            recBtn.innerHTML = ICON.mic;
          }
        }

        if (recBtn) {
          setRecordUi(false);
          recBtn.addEventListener("click", async () => {
            if (recordingBusy) return;
            // Toggle stop if active.
            if (rRec && rRec.state !== "inactive") {
              try { rRec.stop(); } catch (_) {}
              setRecordUi(false);
              recordingBusy = false;
              return;
            }
            try {
              recordingBusy = true;
              await requestPermission("device.mic", "Record audio");
              rChunks = [];
              rStream = await navigator.mediaDevices.getUserMedia({ audio: true });
              rRec = new MediaRecorder(rStream);
              rRec.ondataavailable = (e) => { if (e.data && e.data.size) rChunks.push(e.data); };
              rRec.onstop = () => {
                const blob = new Blob(rChunks, { type: rRec.mimeType || "audio/webm" });
                try { if (rStream) rStream.getTracks().forEach(t => t.stop()); } catch (_) {}
                rStream = null;
                rRec = null;
                rChunks = [];
                recordingBusy = false;
                setRecordUi(false);
                try {
                  const ts = new Date().toISOString().replace(/[:.]/g, "-");
                  addPendingRecording(blob, "audio_recording_" + ts + ".webm");
                } catch (_) {}
              };
              rRec.start();
              setRecordUi(true);
              showToast("Recording... tap again to stop", 1400);
            } catch (_) {
              setRecordUi(false);
              recordingBusy = false;
              showToast("Record failed", 1600);
            }
          });
        }
      })();

      async function waitForAgentReply(itemId) {
        const deadline = Date.now() + 15 * 60 * 1000;
        let lastToolError = "";
        while (Date.now() < deadline) {
          const res = await fetch(
            API + "/brain/messages?limit=200&session_id=" + encodeURIComponent(chatSessionId)
          );
          if (!res.ok) {
            await new Promise(r => setTimeout(r, 700));
            continue;
          }
          const data = await res.json().catch(() => ({}));
          const list = Array.isArray(data.messages) ? data.messages : [];
          for (const msg of list) {
            const meta = msg && msg.meta ? msg.meta : {};
            if (meta.item_id !== itemId) continue;
            if (msg.role === "assistant" && typeof msg.text === "string" && msg.text.trim()) {
              return msg.text.trim();
            }
            if (msg.role === "tool" && typeof msg.text === "string") {
              try {
                const parsed = JSON.parse(msg.text);
                const result = parsed && parsed.result ? parsed.result : {};
                if (result.error) {
                  lastToolError = result.error;
                }
              } catch (_) {}
            }
          }
          await new Promise(r => setTimeout(r, 700));
        }
        if (lastToolError) {
          throw new Error(lastToolError);
        }
        return "";
      }

      // ==============================
      // Brain Config
      // ==============================
      const brainSelect = $("brainVendorModel");
      const brainCustom = $("brainCustomFields");

      function getSelectedPreset() {
        const opt = brainSelect.selectedOptions[0];
        if (!opt || !opt.dataset.vendor) return null;
        if (opt.dataset.vendor === "custom") return { vendor: "custom" };
        return {
          vendor: opt.dataset.vendor,
          base_url: opt.dataset.url,
          model: opt.value,
        };
      }

      brainSelect.addEventListener("change", () => {
        const p = getSelectedPreset();
        brainCustom.style.display = (p && p.vendor === "custom") ? "block" : "none";
      });

      async function loadBrainConfig() {
        try {
          const res = await fetch(API + "/brain/config");
          if (!res.ok) return;
          const data = await res.json();
          $("brainKeyStatus").textContent = data.has_api_key ? "API key is set." : "No API key configured.";

          const vendor = data.vendor || "";
          const model = data.model || "";
          let matched = false;
          for (const opt of brainSelect.options) {
            if (opt.dataset.vendor && opt.dataset.vendor !== "custom"
                && opt.dataset.vendor === vendor && opt.value === model) {
              opt.selected = true;
              matched = true;
              break;
            }
          }
          if (!matched && model) {
            for (const opt of brainSelect.options) {
              if (opt.value === "custom") { opt.selected = true; break; }
            }
            brainCustom.style.display = "block";
            $("brainBaseUrl").value = data.base_url || "";
            $("brainModelId").value = model;
          } else {
            brainCustom.style.display = "none";
          }
        } catch (_) {}
      }

      $("brainSave").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        const preset = getSelectedPreset();
        if (!preset) { showToast("Choose a model first"); return; }

        const payload = {};
        if (preset.vendor === "custom") {
          const baseUrl = $("brainBaseUrl").value.trim();
          const modelId = $("brainModelId").value.trim();
          if (!baseUrl || !modelId) { showToast("Fill in Base URL and Model"); return; }
          payload.vendor = "custom";
          payload.base_url = baseUrl;
          payload.model = modelId;
        } else {
          payload.vendor = preset.vendor;
          payload.base_url = preset.base_url;
          payload.model = preset.model;
        }

        const apiKey = $("brainApiKey").value.trim();
        payload.api_key = apiKey;

        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBrainApiKeyPlain) {
              AndroidBridge.setBrainApiKeyPlain(apiKey);
            }
          } catch (_) {}

          const res = await fetch(API + "/brain/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) { showToast("Failed to save config"); return; }
          await loadBrainConfig();
          refreshSecretsFromBridge();
          showToast("Brain config saved");
        } catch (_) {
          showToast("Connection error");
        }
      });

      loadBrainConfig();

      // ==============================
      // Memory Editor
      // ==============================
      const memoryEditor = $("memoryEditor");

      async function loadMemory() {
        try {
          const res = await fetch(API + "/brain/memory");
          if (!res.ok) return;
          const data = await res.json();
          memoryEditor.value = data.content || "";
        } catch (_) {}
      }

      $("memorySave").addEventListener("click", async () => {
        try {
          const res = await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: memoryEditor.value }),
          });
          if (res.ok) showToast("Memory saved");
          else showToast("Failed to save memory");
        } catch (_) { showToast("Connection error"); }
      });

      $("memoryClear").addEventListener("click", async () => {
        if (!confirm("Clear all memory? This cannot be undone.")) return;
        memoryEditor.value = "";
        try {
          await fetch(API + "/brain/memory", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ content: "" }),
          });
          showToast("Memory cleared");
        } catch (_) { showToast("Connection error"); }
      });

      loadMemory();

      // ==============================
      // Web Search Keys
      // ==============================
      async function checkBraveSearchKey() {
        try {
          $("braveSearchKeyStatus").textContent = "Checking...";
          try {
            if (getSettingsUnlockRemainingMs() > 0
                && typeof AndroidBridge !== "undefined"
                && AndroidBridge.getBraveSearchApiKeyPlain) {
              const k = (AndroidBridge.getBraveSearchApiKeyPlain() || "").trim();
              $("braveSearchKeyStatus").textContent = k ? "API key is set." : "No API key configured.";
              return;
            }
          } catch (_) {}
          const permission_id = await requestPermission("credentials", "Check Brave Search API key status");
          const res = await fetch(API + "/vault/credentials/has", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", permission_id }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          $("braveSearchKeyStatus").textContent = data.present ? "API key is set." : "No API key configured.";
        } catch (_) {
          $("braveSearchKeyStatus").textContent = "Failed to check status.";
        }
      }

      $("braveSearchCheck").addEventListener("click", checkBraveSearchKey);
      $("braveSearchSave").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        const key = $("braveSearchApiKey").value.trim();
        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain(key);
              refreshSecretsFromBridge();
              showToast("Brave key saved");
              await checkBraveSearchKey();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Set Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: key, permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key saved");
          await checkBraveSearchKey();
        } catch (_) {
          showToast("Failed to save key");
        }
      });

      $("braveSearchClear").addEventListener("click", async () => {
        if (!(await ensureSettingsUnlocked())) return;
        try {
          try {
            if (typeof AndroidBridge !== "undefined" && AndroidBridge.setBraveSearchApiKeyPlain) {
              AndroidBridge.setBraveSearchApiKeyPlain("");
              refreshSecretsFromBridge();
              showToast("Brave key cleared");
              await checkBraveSearchKey();
              return;
            }
          } catch (_) {}

          const permission_id = await requestPermission("credentials", "Clear Brave Search API key");
          const res = await fetch(API + "/vault/credentials", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ name: "brave_search_api_key", value: "", permission_id }),
          });
          if (!res.ok) throw 0;
          showToast("Brave key cleared");
          await checkBraveSearchKey();
        } catch (_) {
          showToast("Failed to clear key");
        }
      });

      // ==============================
      // Settings: SSHD, Python, etc.
      // ==============================
      const pythonStatus = $("pythonStatus");
      const pythonDetail = $("pythonDetail");
      const sshStatus = $("sshStatus");
      const sshEnabled = $("sshEnabled");
      const authNotification = $("authNotification");
      const authPin = $("authPin");
      const sshDetail = $("sshDetail");
      const clientKeyRow = $("clientKeyRow");
      const clientKeyFp = $("clientKeyFp");
      const copyClientKey = $("copyClientKey");
      let currentClientKeyPublic = "";
      const pinModal = $("pinModal");
      const pinCode = $("pinCode");
      const pinCountdown = $("pinCountdown");
      const pinClose = $("pinClose");
      const pinBarFill = $("pinBarFill");
      const pinDurationMs = 20000;
      let pinExpiresAt = null;
      let lastPin = null;

      function setStatus(el, value) {
        el.textContent = value;
        el.classList.remove("ok", "offline", "starting", "stopping");
        if (value === "ok") el.classList.add("ok");
        else if (value === "offline") el.classList.add("offline");
        else if (value === "stopping") el.classList.add("stopping");
        else el.classList.add("starting");
      }

      async function refreshPython() {
        try {
          const res = await fetch(API + "/python/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(pythonStatus, data.status || "offline");
        } catch (_) {
          setStatus(pythonStatus, "offline");
        }
      }

      async function refreshSsh() {
        try {
          const res = await fetch(API + "/ssh/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          setStatus(sshStatus, data.running ? "ok" : "offline");
          sshEnabled.checked = !!data.enabled;
          sshDetail.textContent = "ssh " + (data.host || "aaa.bbb.ccc.ddd") + " -p " + (data.port || 2222);
          if (data.client_key_fingerprint) {
            clientKeyFp.textContent = data.client_key_fingerprint;
            clientKeyRow.style.display = "block";
          } else {
            clientKeyRow.style.display = "none";
          }
          currentClientKeyPublic = data.client_key_public || "";
        } catch (_) {
          setStatus(sshStatus, "offline");
          sshDetail.textContent = "SSHD status unavailable";
          clientKeyRow.style.display = "none";
        }
      }

      async function refreshPin() {
        try {
          const res = await fetch(API + "/ssh/pin/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.active) {
            pinExpiresAt = data.expires_at || null;
            if (!pinModal.classList.contains("show")) pinModal.classList.add("show");
            if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
            else if (lastPin && pinCode.textContent === "------") pinCode.textContent = lastPin;
            updatePinCountdown();
          } else {
            pinExpiresAt = null;
            pinBarFill.style.width = "0%";
            pinCountdown.textContent = "PIN inactive.";
            pinCode.textContent = "------";
            lastPin = null;
            if (pinModal.classList.contains("show")) {
              pinModal.classList.remove("show");
              await refreshSsh();
            }
          }
        } catch (_) {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN unavailable.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
        }
      }

      function updatePinCountdown() {
        if (!pinExpiresAt) {
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          return;
        }
        const rem = pinExpiresAt - Date.now();
        if (rem <= 0) {
          pinBarFill.style.width = "0%";
          pinExpiresAt = null;
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          pinModal.classList.remove("show");
          return;
        }
        pinCountdown.textContent = "Active (" + Math.ceil(rem / 1000) + "s)";
        pinBarFill.style.width = Math.round(Math.max(0, Math.min(1, rem / pinDurationMs)) * 100) + "%";
      }

      // ==============================
      // Permissions prefs
      // ==============================
      let permissionsRemember = true;
      async function loadPermissionPrefs() {
        try {
          const res = await fetch(API + "/permissions/prefs");
          if (!res.ok) throw 0;
          const data = await res.json();
          permissionsRemember = !!data.remember_approvals;
          $("permRemember").checked = permissionsRemember;
        } catch (_) {
          permissionsRemember = true;
          $("permRemember").checked = true;
        }
      }

      async function requestPermission(tool, detail) {
        const res = await fetch(API + "/permissions/request", {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify({ tool, detail, scope: (permissionsRemember ? "persistent" : "once") }),
        });
        if (!res.ok) throw new Error("permission request failed");
        const data = await res.json();
        if (data.status === "approved") return data.id;
        const deadline = Date.now() + 30000;
        while (Date.now() < deadline) {
          await new Promise(r => setTimeout(r, 500));
          try {
            const sr = await fetch(API + "/permissions/" + data.id);
            if (!sr.ok) continue;
            const sd = await sr.json();
            if (sd.status === "approved") return data.id;
            if (sd.status === "denied") throw new Error("permission denied");
          } catch (_) {}
        }
        throw new Error("permission timeout");
      }

      // ==============================
      // Pip helpers
      // ==============================
      async function refreshPipStatus() {
        try {
          const res = await fetch(API + "/pip/status");
          if (!res.ok) throw 0;
          const data = await res.json();
          const lines = [];
          if (data.abi) lines.push("ABI: " + data.abi);
          if (data.wheelhouse_bundled) lines.push("Bundled wheels: " + data.wheelhouse_bundled);
          if (data.wheelhouse_user) lines.push("User wheel cache: " + data.wheelhouse_user);
          if (data.pip_find_links) lines.push("PIP_FIND_LINKS: " + data.pip_find_links);
          $("pipStatus").textContent = lines.join("\n");
        } catch (_) {
          $("pipStatus").textContent = "pip status unavailable.";
        }
      }

      function getPipSpec() {
        return String($("pipSpec").value || "").trim();
      }

      function setPipOutput(text) {
        $("pipOutput").textContent = text || "";
      }

      async function runPip(endpoint, payload, detail) {
        const permission_id = await requestPermission("pip", detail);
        payload = Object.assign({}, payload, { permission_id });
        const res = await fetch(API + endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json; charset=utf-8" },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        const code = data.code;
        const out = data.output || (data.error ? ("error: " + data.error) : "");
        setPipOutput((typeof code === "number" ? ("exit=" + code + "\n\n") : "") + out);
        if (!res.ok) throw new Error("pip failed");
        return data;
      }

      $("pipDownload").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Downloading wheels...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          const index_url = String($("pipIndexUrl").value || "").trim();
          await runPip(
            "/pip/download",
            { spec, with_deps, only_binary, index_url: (index_url || undefined) },
            "Download wheels: " + spec
          );
          await refreshPipStatus();
          showToast("Download complete", 1600);
        } catch (_) {
          showToast("Download failed", 2000);
        }
      });

      $("pipInstallOffline").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Installing (offline)...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          await runPip(
            "/pip/install",
            { spec, allow_network: false, no_deps: !with_deps, only_binary },
            "Install (offline): " + spec
          );
          showToast("Install complete", 1600);
        } catch (_) {
          showToast("Install failed", 2000);
        }
      });

      $("pipInstallNet").addEventListener("click", async () => {
        const spec = getPipSpec();
        if (!spec) { showToast("Enter a package spec", 1800); return; }
        setPipOutput("Installing (network)...\n");
        try {
          const with_deps = !!$("pipWithDeps").checked;
          const only_binary = !!$("pipOnlyBinary").checked;
          const index_url = String($("pipIndexUrl").value || "").trim();
          await runPip(
            "/pip/install",
            { spec, allow_network: true, no_deps: !with_deps, only_binary, index_url: (index_url || undefined) },
            "Install (network): " + spec
          );
          showToast("Install complete", 1600);
        } catch (_) {
          showToast("Install failed", 2000);
        }
      });

      $("permRemember").addEventListener("change", async () => {
        const enabled = !!$("permRemember").checked;
        permissionsRemember = enabled;
        try {
          const res = await fetch(API + "/permissions/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ remember_approvals: enabled }),
          });
          if (!res.ok) throw 0;
          showToast("Permission preference saved", 1500);
        } catch (_) {
          showToast("Failed to save preference", 2000);
        }
      });
      $("permClear").addEventListener("click", async () => {
        if (!window.confirm("Clear all saved tool approvals?")) return;
        try {
          const res = await fetch(API + "/permissions/clear", { method: "POST" });
          if (!res.ok) throw 0;
          showToast("Saved approvals cleared", 1800);
        } catch (_) {
          showToast("Failed to clear approvals", 2000);
        }
      });

      async function loadCloudPrefs() {
        try {
          const res = await fetch(API + "/cloud/prefs");
          if (!res.ok) throw 0;
          const data = await res.json().catch(() => ({}));
          const v = Number(data.auto_upload_no_confirm_mb);
          $("cloudAutoUploadMb").value = (isFinite(v) ? String(v) : "1.0");
          const k = Number(data.min_transfer_kbps);
          $("cloudMinKbps").value = (isFinite(k) ? String(k) : "0");
          $("cloudImgResizeEnabled").checked = !!data.image_resize_enabled;
          const md = Number(data.image_resize_max_dim_px);
          $("cloudImgMaxDim").value = (isFinite(md) ? String(md) : "512");
          const q = Number(data.image_resize_jpeg_quality);
          $("cloudImgJpegQ").value = (isFinite(q) ? String(q) : "70");
        } catch (_) {
          $("cloudAutoUploadMb").value = "1.0";
          $("cloudMinKbps").value = "0";
          $("cloudImgResizeEnabled").checked = true;
          $("cloudImgMaxDim").value = "512";
          $("cloudImgJpegQ").value = "70";
        }
      }

      $("cloudPrefsSave").addEventListener("click", async () => {
        const raw = String($("cloudAutoUploadMb").value || "").trim();
        const v = parseFloat(raw);
        if (!isFinite(v) || v < 0) { showToast("Enter a valid number", 1600); return; }
        const rawK = String($("cloudMinKbps").value || "").trim();
        const k = parseFloat(rawK);
        if (!isFinite(k) || k < 0) { showToast("Enter a valid number", 1600); return; }
        const enabled = !!$("cloudImgResizeEnabled").checked;
        const md = parseInt(String($("cloudImgMaxDim").value || "").trim() || "512", 10);
        if (!Number.isFinite(md) || md < 64) { showToast("Enter a valid max dim", 1600); return; }
        const q = parseInt(String($("cloudImgJpegQ").value || "").trim() || "70", 10);
        if (!Number.isFinite(q) || q < 30) { showToast("Enter a valid JPEG quality", 1600); return; }
        try {
          const res = await fetch(API + "/cloud/prefs", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({
              auto_upload_no_confirm_mb: v,
              min_transfer_kbps: k,
              image_resize_enabled: enabled,
              image_resize_max_dim_px: md,
              image_resize_jpeg_quality: q,
            }),
          });
          if (!res.ok) throw 0;
          showToast("Cloud prefs saved", 1600);
        } catch (_) {
          showToast("Failed to save cloud prefs", 1800);
        }
      });

      $("restartPython").addEventListener("click", async () => {
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.restartPythonWorker) {
          AndroidBridge.restartPythonWorker();
        } else {
          await fetch(API + "/python/restart", { method: "POST" });
        }
        pythonDetail.textContent = "Restart requested";
        setStatus(pythonStatus, "starting");
      });

      $("resetUi").addEventListener("click", () => {
        if (!window.confirm("Reset UI to defaults? This will overwrite any local changes.")) return;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUiToDefaults) {
          AndroidBridge.resetUiToDefaults();
        }
      });

      $("resetAgentDocs").addEventListener("click", () => {
        if (!window.confirm("Reset AGENTS.md / TOOLS.md / docs/ to defaults? This will overwrite those files.")) return;
        if (typeof AndroidBridge !== "undefined" && AndroidBridge.resetUserDefaultsToDefaults) {
          AndroidBridge.resetUserDefaultsToDefaults();
        } else {
          showToast("Reset not available", 1600);
        }
      });

      async function updateSshConfig() {
        const enabled = sshEnabled.checked;
        try {
          const res = await fetch(API + "/ssh/config", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ enabled }),
          });
          if (!res.ok) throw 0;
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to apply SSHD settings";
        }
      }

      sshEnabled.addEventListener("change", updateSshConfig);
      authNotification.addEventListener("click", async () => {
        sshDetail.textContent = "Enabling notification auth...";
        try {
          const permission_id = await requestPermission("ssh_noauth", "Enable SSH notification auth");
          const res = await fetch(API + "/ssh/noauth/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 30 }),
          });
          if (!res.ok) throw 0;
          sshDetail.textContent = "Notification auth enabled";
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to enable notification auth";
        }
      });
      authPin.addEventListener("click", async () => {
        try {
          pinCode.textContent = "\u2022\u2022\u2022\u2022\u2022\u2022";
          pinCountdown.textContent = "Generating PIN...";
          pinBarFill.style.width = "0%";
          pinModal.classList.add("show");
          const permission_id = await requestPermission("ssh_pin", "Enable SSH PIN auth");
          const res = await fetch(API + "/ssh/pin/start", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({ permission_id, seconds: 20 }),
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          if (data.pin) { pinCode.textContent = data.pin; lastPin = data.pin; }
          else if (lastPin) pinCode.textContent = lastPin;
          else pinCode.textContent = "PIN unavailable";
          pinModal.classList.add("show");
          pinExpiresAt = data.expires_at || (Date.now() + pinDurationMs);
          updatePinCountdown();
          await refreshSsh();
        } catch (_) {
          sshDetail.textContent = "Failed to start PIN auth";
        }
      });

      copyClientKey.addEventListener("click", async () => {
        if (!currentClientKeyPublic) return;
        try {
          await navigator.clipboard.writeText(currentClientKeyPublic);
          copyClientKey.textContent = "Copied!";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        } catch (_) {
          copyClientKey.textContent = "Failed";
          setTimeout(() => { copyClientKey.textContent = "Copy"; }, 1500);
        }
      });

      pinClose.addEventListener("click", async () => {
        try {
          await fetch(API + "/ssh/pin/stop", {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify({}),
          });
          await refreshPin();
          await refreshSsh();
        } catch (_) {
        } finally {
          pinExpiresAt = null;
          pinBarFill.style.width = "0%";
          pinCountdown.textContent = "PIN inactive.";
          pinCode.textContent = "------";
          lastPin = null;
          pinModal.classList.remove("show");
        }
      });

      window.onPythonStatus = function(status) {
        setStatus(pythonStatus, status);
      };

      loadPermissionPrefs();
      loadCloudPrefs();
      refreshPipStatus();
      refreshPython();
      refreshSsh();
      refreshPin();
      setInterval(refreshPython, 5000);
      setInterval(refreshSsh, 5000);
      setInterval(refreshPin, 1000);
      setInterval(updatePinCountdown, 1000);
    </script>
  </body>
</html>
