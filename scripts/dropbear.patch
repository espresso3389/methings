diff --git a/src/loginrec.c b/src/loginrec.c
index 3118bf6..14e6299 100644
--- a/src/loginrec.c
+++ b/src/loginrec.c
@@ -268,10 +268,11 @@ login_init_entry(struct logininfo *li, int pid, const char *username,
 	if (username) {
 		strlcpy(li->username, username, sizeof(li->username));
 		pw = getpwnam(li->username);
-		if (pw == NULL)
-			dropbear_exit("login_init_entry: Cannot find user \"%s\"",
-					li->username);
-		li->uid = pw->pw_uid;
+		if (pw == NULL) {
+			li->uid = geteuid();
+		} else {
+			li->uid = pw->pw_uid;
+		}
 	}
 
 	if (hostname)
diff --git a/src/sshpty.c b/src/sshpty.c
index 9f12d67..fd69661 100644
--- a/src/sshpty.c
+++ b/src/sshpty.c
@@ -91,7 +91,48 @@ pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, int namebuflen)
 	}
 	return 1;
 #else /* HAVE__GETPTY */
-#if defined(USE_DEV_PTMX)
+#if defined(__ANDROID__)
+	int ptm;
+	char *pts;
+
+	ptm = open("/dev/ptmx", O_RDWR | O_NOCTTY);
+	if (ptm < 0) {
+		dropbear_log(LOG_WARNING,
+				"pty_allocate: /dev/ptmx: %.100s", strerror(errno));
+		return 0;
+	}
+	if (grantpt(ptm) < 0) {
+		dropbear_log(LOG_WARNING,
+				"grantpt: %.100s", strerror(errno));
+		close(ptm);
+		return 0;
+	}
+	if (unlockpt(ptm) < 0) {
+		dropbear_log(LOG_WARNING,
+				"unlockpt: %.100s", strerror(errno));
+		close(ptm);
+		return 0;
+	}
+	pts = ptsname(ptm);
+	if (pts == NULL) {
+		dropbear_log(LOG_WARNING,
+				"Slave pty side name could not be obtained.");
+		close(ptm);
+		return 0;
+	}
+	strlcpy(namebuf, pts, namebuflen);
+	*ptyfd = ptm;
+
+	*ttyfd = open(namebuf, O_RDWR | O_NOCTTY);
+	if (*ttyfd < 0) {
+		dropbear_log(LOG_ERR,
+			"error opening pts %.100s: %.100s", namebuf, strerror(errno));
+		close(*ptyfd);
+		return 0;
+	}
+	return 1;
+
+#elif defined(USE_DEV_PTMX)
 	/*
 	 * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3
 	 * also has bsd-style ptys, but they simply do not work.)
@@ -360,6 +401,9 @@ pty_setowner(struct passwd *pw, const char *tty_name)
 	mode_t mode;
 	struct stat st;
 
+	if (!pw || !tty_name) {
+		return;
+	}
 	/* Determine the group to make the owner of the tty. */
 	grp = getgrnam("tty");
 	if (grp) {
@@ -376,7 +420,7 @@ pty_setowner(struct passwd *pw, const char *tty_name)
 	 * tty is owned by root.
 	 */
 	if (stat(tty_name, &st)) {
-		dropbear_exit("pty_setowner: stat(%.101s) failed: %.100s",
+		dropbear_log(LOG_WARNING, "pty_setowner: stat(%.101s) failed: %.100s",
 				tty_name, strerror(errno));
 	}
 
@@ -391,7 +435,7 @@ pty_setowner(struct passwd *pw, const char *tty_name)
 						tty_name, (unsigned int)pw->pw_uid, (unsigned int)gid,
 						strerror(errno));
 			} else {
-				dropbear_exit("chown(%.100s, %u, %u) failed: %.100s",
+				dropbear_log(LOG_WARNING, "chown(%.100s, %u, %u) failed: %.100s",
 				    tty_name, (unsigned int)pw->pw_uid, (unsigned int)gid,
 				    strerror(errno));
 			}
@@ -406,7 +450,7 @@ pty_setowner(struct passwd *pw, const char *tty_name)
 					"chmod(%.100s, 0%o) failed: %.100s",
 					tty_name, mode, strerror(errno));
 			} else {
-				dropbear_exit("chmod(%.100s, 0%o) failed: %.100s",
+				dropbear_log(LOG_WARNING, "chmod(%.100s, 0%o) failed: %.100s",
 				    tty_name, mode, strerror(errno));
 			}
 		}
diff --git a/src/svr-auth.c b/src/svr-auth.c
index de01458..81e7a95 100644
--- a/src/svr-auth.c
+++ b/src/svr-auth.c
@@ -38,6 +38,98 @@
 
 static int checkusername(const char *username, unsigned int userlen);
 
+#ifdef __ANDROID__
+static int noauth_prompt(const char *username) {
+	const char *dir = getenv("DROPBEAR_NOAUTH_PROMPT_DIR");
+	const char *timeout_env = getenv("DROPBEAR_NOAUTH_PROMPT_TIMEOUT");
+	long timeout = 10;
+	long now = time(NULL);
+	long deadline;
+	pid_t pid = getpid();
+	static unsigned int counter = 0;
+	char id[128];
+	char reqfile[512];
+	char respfile[512];
+	FILE *fp;
+	int allowed = 0;
+
+	if (!dir || !dir[0]) {
+		return 0;
+	}
+	if (timeout_env && timeout_env[0]) {
+		timeout = strtol(timeout_env, NULL, 10);
+		if (timeout <= 0) {
+			timeout = 10;
+		}
+	}
+	counter++;
+	snprintf(id, sizeof(id), "req_%ld_%d_%u", now, (int)pid, counter);
+	snprintf(reqfile, sizeof(reqfile), "%s/%s.req", dir, id);
+	snprintf(respfile, sizeof(respfile), "%s/%s.resp", dir, id);
+
+	fp = fopen(reqfile, "w");
+	if (!fp) {
+		return 0;
+	}
+	fprintf(fp, "%s\t%s\t%s\t%ld\n",
+		id,
+		username ? username : "",
+		svr_ses.addrstring ? svr_ses.addrstring : "",
+		now);
+	fclose(fp);
+
+	deadline = time(NULL) + timeout;
+	while (time(NULL) <= deadline) {
+		fp = fopen(respfile, "r");
+		if (fp) {
+			char verdict[16] = {0};
+			if (fscanf(fp, "%15s", verdict) == 1) {
+				if (strcmp(verdict, "allow") == 0 || strcmp(verdict, "1") == 0) {
+					allowed = 1;
+				}
+			}
+			fclose(fp);
+			break;
+		}
+		usleep(200 * 1000);
+	}
+	remove(reqfile);
+	remove(respfile);
+	return allowed;
+}
+
+static int pin_allowed(void) {
+	const char *file = getenv("DROPBEAR_PIN_FILE");
+	long expires = 0;
+	char pinbuf[16] = {0};
+	FILE *fp;
+	if (!file || !file[0]) {
+		dropbear_log(LOG_WARNING, "pin auth file env missing");
+		return 0;
+	}
+	fp = fopen(file, "r");
+	if (!fp) {
+		dropbear_log(LOG_WARNING, "pin auth file open failed: %s (%s)", file, strerror(errno));
+		return 0;
+	}
+	if (fscanf(fp, "%ld %15s", &expires, pinbuf) < 1) {
+		fclose(fp);
+		dropbear_log(LOG_WARNING, "pin auth file parse failed: %s", file);
+		return 0;
+	}
+	fclose(fp);
+	if (expires <= 0) {
+		dropbear_log(LOG_WARNING, "pin auth file expired (<=0): %s", file);
+		return 0;
+	}
+	if (time(NULL) > (time_t)expires) {
+		dropbear_log(LOG_WARNING, "pin auth file expired: %s", file);
+	}
+	return time(NULL) <= (time_t)expires;
+}
+
+#endif
+
 /* initialise the first time for a session, resetting all parameters */
 void svr_authinitialise() {
 	memset(&ses.authstate, 0, sizeof(ses.authstate));
@@ -46,7 +138,14 @@ void svr_authinitialise() {
 #endif
 #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
 	if (!svr_opts.noauthpass) {
+#if defined(DROPBEAR_SVR_PASSWORD_AUTH_PIN_ONLY)
+		if (pin_allowed()) {
+			ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+			ses.authstate.authtypes &= ~AUTH_TYPE_PUBKEY;
+		}
+#else
 		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+#endif
 	}
 #endif
 }
@@ -123,6 +222,20 @@ void recv_msg_userauth_request() {
 			strncmp(methodname, AUTH_METHOD_NONE,
 				AUTH_METHOD_NONE_LEN) == 0) {
 		TRACE(("recv_msg_userauth_request: 'none' request"))
+#ifdef __ANDROID__
+		if (pin_allowed()) {
+			send_msg_userauth_failure(0, 1);
+			goto out;
+		}
+		if (valid_user && noauth_prompt(username)) {
+			dropbear_log(LOG_NOTICE,
+					"Auth succeeded with app approval for '%s' from %s",
+					username,
+					svr_ses.addrstring);
+			send_msg_userauth_success();
+			goto out;
+		}
+#endif
 		if (valid_user
 				&& svr_opts.allowblankpass
 				&& !svr_opts.noauthpass
@@ -151,6 +264,14 @@ void recv_msg_userauth_request() {
 		if (methodlen == AUTH_METHOD_PASSWORD_LEN &&
 				strncmp(methodname, AUTH_METHOD_PASSWORD,
 					AUTH_METHOD_PASSWORD_LEN) == 0) {
+#if defined(DROPBEAR_SVR_PASSWORD_AUTH_PIN_ONLY)
+			if (!pin_allowed()) {
+				ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD;
+				send_msg_userauth_failure(0, 1);
+				goto out;
+			}
+			ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+#endif
 			svr_auth_password(valid_user);
 			goto out;
 		}
@@ -175,6 +296,12 @@ void recv_msg_userauth_request() {
 	if (methodlen == AUTH_METHOD_PUBKEY_LEN &&
 			strncmp(methodname, AUTH_METHOD_PUBKEY,
 				AUTH_METHOD_PUBKEY_LEN) == 0) {
+#if defined(DROPBEAR_SVR_PASSWORD_AUTH_PIN_ONLY)
+		if (pin_allowed()) {
+			send_msg_userauth_failure(0, 1);
+			goto out;
+		}
+#endif
 		svr_auth_pubkey(valid_user);
 		goto out;
 	}
@@ -263,12 +390,19 @@ static int checkusername(const char *username, unsigned int userlen) {
 
 	/* check that user exists */
 	if (!ses.authstate.pw_name) {
-		TRACE(("leave checkusername: user '%s' doesn't exist", username))
+		uid_t euid = geteuid();
+		gid_t egid = getegid();
+		const char *home = getenv("HOME");
+		TRACE(("checkusername: no passwd entry, using app uid"))
 		dropbear_log(LOG_WARNING,
-				"Login attempt for nonexistent user from %s",
-				svr_ses.addrstring);
-		ses.authstate.checkusername_failed = 1;
-		return DROPBEAR_FAILURE;
+				"No passwd entry for user '%s', using app uid",
+				username);
+		ses.authstate.pw_uid = euid;
+		ses.authstate.pw_gid = egid;
+		ses.authstate.pw_name = m_strdup(username);
+		ses.authstate.pw_dir = m_strdup(home ? home : "/");
+		ses.authstate.pw_shell = m_strdup("/system/bin/sh");
+		ses.authstate.pw_passwd = m_strdup("!!");
 	}
 
 	/* check if we are running as non-root, and login user is different from the server */
@@ -305,34 +439,9 @@ static int checkusername(const char *username, unsigned int userlen) {
 	}
 #endif /* HAVE_GETGROUPLIST */
 
-	TRACE(("shell is %s", ses.authstate.pw_shell))
-
-	/* check that the shell is set */
-	usershell = ses.authstate.pw_shell;
-	if (usershell[0] == '\0') {
-		/* empty shell in /etc/passwd means /bin/sh according to passwd(5) */
-		usershell = "/bin/sh";
-	}
+		TRACE(("shell is %s", ses.authstate.pw_shell))
+	goto goodshell;
 
-	/* check the shell is valid. If /etc/shells doesn't exist, getusershell()
-	 * should return some standard shells like "/bin/sh" and "/bin/csh" (this
-	 * is platform-specific) */
-	setusershell();
-	while ((listshell = getusershell()) != NULL) {
-		TRACE(("test shell is '%s'", listshell))
-		if (strcmp(listshell, usershell) == 0) {
-			/* have a match */
-			goto goodshell;
-		}
-	}
-	/* no matching shell */
-	endusershell();
-	TRACE(("no matching shell"))
-	ses.authstate.checkusername_failed = 1;
-	dropbear_log(LOG_WARNING, "User '%s' has invalid shell, rejected",
-				ses.authstate.pw_name);
-	return DROPBEAR_FAILURE;
-	
 goodshell:
 	endusershell();
 	TRACE(("matching shell"))
diff --git a/src/svr-authpasswd.c b/src/svr-authpasswd.c
index 899a8ab..ccb5b12 100644
--- a/src/svr-authpasswd.c
+++ b/src/svr-authpasswd.c
@@ -65,6 +65,39 @@ void svr_auth_password(int valid_user) {
 	}
 
 	password = buf_getstring(ses.payload, &passwordlen);
+#if defined(__ANDROID__)
+	{
+		const char *pinfile = getenv("DROPBEAR_PIN_FILE");
+		if (pinfile && pinfile[0] && valid_user) {
+			FILE *fp = fopen(pinfile, "r");
+			if (fp) {
+				long expires = 0;
+				char pinbuf[16] = {0};
+				if (fscanf(fp, "%ld %15s", &expires, pinbuf) == 2) {
+					if (expires > 0 && time(NULL) <= (time_t)expires) {
+						if (passwordlen == strlen(pinbuf) &&
+								memcmp(password, pinbuf, passwordlen) == 0) {
+							fclose(fp);
+							remove(pinfile);
+							m_burn(password, passwordlen);
+							m_free(password);
+							send_msg_userauth_success();
+							return;
+						}
+					}
+				}
+				fclose(fp);
+			}
+		}
+	}
+#endif
+#if defined(DROPBEAR_SVR_PASSWORD_AUTH_PIN_ONLY)
+	m_burn(password, passwordlen);
+	m_free(password);
+	send_msg_userauth_failure(0, 1);
+	return;
+#endif
+#if !defined(DROPBEAR_SVR_PASSWORD_AUTH_PIN_ONLY)
 	if (valid_user && passwordlen <= DROPBEAR_MAX_PASSWORD_LEN) {
 		/* the first bytes of passwdcrypt are the salt */
 		passwdcrypt = ses.authstate.pw_passwd;
@@ -129,6 +162,7 @@ void svr_auth_password(int valid_user) {
 				svr_ses.addrstring);
 		send_msg_userauth_failure(0, 1);
 	}
+#endif
 }
 
 #endif
diff --git a/src/svr-authpubkey.c b/src/svr-authpubkey.c
index 94ae728..09ee3b4 100644
--- a/src/svr-authpubkey.c
+++ b/src/svr-authpubkey.c
@@ -470,13 +470,9 @@ static int checkpubkey(const char* keyalgo, unsigned int keyalgolen,
 	TRACE(("enter checkpubkey"))
 
 #if DROPBEAR_SVR_MULTIUSER
-	/* access the file as the authenticating user. */
+	/* Avoid setegid/seteuid on Android app sandboxes */
 	origuid = getuid();
 	origgid = getgid();
-	if ((setegid(ses.authstate.pw_gid)) < 0 ||
-		(seteuid(ses.authstate.pw_uid)) < 0) {
-		dropbear_exit("Failed to set euid");
-	}
 #endif
 	/* check file permissions, also whether file exists */
 	if (checkpubkeyperms() == DROPBEAR_FAILURE) {
@@ -484,17 +480,17 @@ static int checkpubkey(const char* keyalgo, unsigned int keyalgolen,
 	} else {
 		/* we don't need to check pw and pw_dir for validity, since
 		 * its been done in checkpubkeyperms. */
-		filename = authorized_keys_filepath();
-		authfile = fopen(filename, "r");
-		if (!authfile) {
-			TRACE(("checkpubkey: failed opening %s: %s", filename, strerror(errno)))
-		}
+	filename = authorized_keys_filepath();
+	authfile = fopen(filename, "r");
+	if (!authfile) {
+		dropbear_log(LOG_WARNING, "authorized_keys open failed: %s (%s)",
+				filename, strerror(errno));
+		TRACE(("checkpubkey: failed opening %s: %s", filename, strerror(errno)))
 	}
-#if DROPBEAR_SVR_MULTIUSER
-	if ((seteuid(origuid)) < 0 ||
-		(setegid(origgid)) < 0) {
-		dropbear_exit("Failed to revert euid");
 	}
+#if DROPBEAR_SVR_MULTIUSER
+	(void)origuid;
+	(void)origgid;
 #endif
 
 	if (authfile == NULL) {
@@ -533,6 +529,9 @@ out:
 	if (authfile) {
 		fclose(authfile);
 	}
+	if (ret != DROPBEAR_SUCCESS) {
+		dropbear_log(LOG_NOTICE, "pubkey auth failed: no matching key in authorized_keys");
+	}
 	if (line) {
 		buf_free(line);
 	}
@@ -549,32 +548,7 @@ out:
  * When this path is inside the user's home dir it checks up to and including
  * the home dir, otherwise it checks every path component. */
 static int checkpubkeyperms() {
-	char *path = authorized_keys_filepath(), *sep = NULL;
-	int ret = DROPBEAR_SUCCESS;
-
-	TRACE(("enter checkpubkeyperms"))
-
-	/* Walk back up path checking permissions, stopping at either homedir,
-	 * or root if the path is outside of the homedir. */
-	while ((sep = strrchr(path, '/')) != NULL) {
-		if (sep == path) {	/* root directory */
-			sep++;
-		}
-		*sep = '\0';
-		if (checkfileperm(path) != DROPBEAR_SUCCESS) {
-			TRACE(("checkpubkeyperms: bad perm on %s", path))
-			ret = DROPBEAR_FAILURE;
-		}
-		if (strcmp(path, ses.authstate.pw_dir) == 0 || strcmp(path, "/") == 0) {
-			break;
-		}
-	}
-
-	/* all looks ok, return success */
-	m_free(path);
-
-	TRACE(("leave checkpubkeyperms"))
-	return ret;
+	return DROPBEAR_SUCCESS;
 }
 
 /* Checks that a file is owned by the user or root, and isn't writable by
diff --git a/src/svr-chansession.c b/src/svr-chansession.c
index 11205f3..a9fb50c 100644
--- a/src/svr-chansession.c
+++ b/src/svr-chansession.c
@@ -597,6 +597,12 @@ static int sessionpty(struct ChanSess * chansess) {
 		TRACE(("leave sessionpty: term len too long"))
 		return DROPBEAR_FAILURE;
 	}
+#ifdef __ANDROID__
+	dropbear_log(LOG_WARNING, "pty requested but unsupported; rejecting pty request");
+	m_free(chansess->term);
+	chansess->term = NULL;
+	return DROPBEAR_FAILURE;
+#endif
 
 	/* allocate the pty */
 	if (chansess->master != -1) {
@@ -604,7 +610,14 @@ static int sessionpty(struct ChanSess * chansess) {
 	}
 	if (pty_allocate(&chansess->master, &chansess->slave, namebuf, 64) == 0) {
 		TRACE(("leave sessionpty: failed to allocate pty"))
+#ifdef __ANDROID__
+		dropbear_log(LOG_WARNING, "pty_allocate failed, rejecting pty request");
+		m_free(chansess->term);
+		chansess->term = NULL;
 		return DROPBEAR_FAILURE;
+#else
+		return DROPBEAR_FAILURE;
+#endif
 	}
 	
 	chansess->tty = m_strdup(namebuf);
@@ -613,9 +626,11 @@ static int sessionpty(struct ChanSess * chansess) {
 	}
 
 	pw = getpwnam(ses.authstate.pw_name);
-	if (!pw)
-		dropbear_exit("getpwnam failed after succeeding previously");
-	pty_setowner(pw, chansess->tty);
+	if (pw) {
+		pty_setowner(pw, chansess->tty);
+	} else {
+		dropbear_log(LOG_WARNING, "getpwnam failed, skipping pty_setowner");
+	}
 
 	/* Set up the rows/col counts */
 	sessionwinchange(chansess);
@@ -1050,6 +1065,63 @@ static void execchild(const void *user_data) {
 	svr_agentset(chansess);
 #endif
 
+#if defined(__ANDROID__)
+	if (chansess->cmd == NULL && chansess->term == NULL) {
+		const char *prompt = "kugutz> ";
+		char linebuf[1024];
+		while (1) {
+			size_t pos = 0;
+			(void)write(1, prompt, strlen(prompt));
+			while (1) {
+				char ch;
+				ssize_t r = read(0, &ch, 1);
+				if (r <= 0) {
+					_exit(0);
+				}
+				if (ch == '\r') {
+					(void)write(1, "\r\n", 2);
+					break;
+				}
+				if (ch == '\n') {
+					(void)write(1, "\r\n", 2);
+					break;
+				}
+				if (ch == '\b' || ch == 0x7f) {
+					if (pos > 0) {
+						pos--;
+					}
+					continue;
+				}
+				if (pos + 1 < sizeof(linebuf)) {
+					linebuf[pos++] = ch;
+				}
+			}
+			linebuf[pos] = '\0';
+			if (pos == 0) {
+				continue;
+			}
+			if (strcmp(linebuf, "exit") == 0 || strcmp(linebuf, "logout") == 0) {
+				_exit(0);
+			}
+			if (strncmp(linebuf, "cd ", 3) == 0) {
+				if (chdir(linebuf + 3) < 0) {
+					dprintf(2, "cd: %s\n", strerror(errno));
+				}
+				continue;
+			}
+			pid_t pid = fork();
+			if (pid == 0) {
+				execl("/system/bin/sh", "sh", "-c", linebuf, (char *)NULL);
+				_exit(127);
+			} else if (pid > 0) {
+				int status = 0;
+				(void)waitpid(pid, &status, 0);
+			} else {
+				dprintf(2, "fork failed: %s\n", strerror(errno));
+			}
+		}
+	}
+#endif
 	usershell = m_strdup(get_user_shell());
 	run_shell_command(chansess->cmd, ses.maxfd, usershell);
 
diff --git a/src/sysoptions.h b/src/sysoptions.h
index a13548d..0009289 100644
--- a/src/sysoptions.h
+++ b/src/sysoptions.h
@@ -335,7 +335,7 @@
 #error "DROPBEAR_SVR_PAM_AUTH requires PAM headers. Perhaps ./configure --enable-pam ?"
 #endif
 
-#if DROPBEAR_SVR_PASSWORD_AUTH && !HAVE_CRYPT
+#if DROPBEAR_SVR_PASSWORD_AUTH && !HAVE_CRYPT && !DROPBEAR_SVR_PASSWORD_AUTH_PIN_ONLY
 	#error "DROPBEAR_SVR_PASSWORD_AUTH requires `crypt()'."
 #endif
 
